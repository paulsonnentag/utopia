/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/codemirror.tsx");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@codemirror/next/closebrackets/dist/index.es.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@codemirror/next/closebrackets/dist/index.es.js ***!
  \**********************************************************************/
/*! exports provided: closeBrackets, handleBackspace, handleInsertion */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"closeBrackets\", function() { return closeBrackets; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"handleBackspace\", function() { return handleBackspace; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"handleInsertion\", function() { return handleInsertion; });\n/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../view */ \"./node_modules/@codemirror/next/view/dist/index.es.js\");\n/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../state */ \"./node_modules/@codemirror/next/state/dist/index.es.js\");\n/* harmony import */ var _text__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../text */ \"./node_modules/@codemirror/next/text/dist/index.es.js\");\n/* harmony import */ var w3c_keyname__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! w3c-keyname */ \"./node_modules/w3c-keyname/index.es.js\");\n\n\n\n\n\nconst defaults = {\n    closeBrackets: [\"(\", \"[\", \"{\", \"'\", '\"'],\n    closeBracketsBefore: \")]}'\\\":;>\"\n};\n/// Extension to enable bracket-closing behavior. When a closeable\n/// bracket is typed, its closing bracket is immediately inserted\n/// after the cursor. When closing a bracket directly in front of that\n/// closing bracket, the cursor moves over the existing bracket. When\n/// backspacing in between brackets, both are removed.\nconst closeBrackets = _view__WEBPACK_IMPORTED_MODULE_0__[\"EditorView\"].handleDOMEvents({ keydown });\nconst definedClosing = \"()[]{}<>\";\nfunction closing(ch) {\n    for (let i = 0; i < definedClosing.length; i += 2)\n        if (definedClosing.charCodeAt(i) == ch)\n            return definedClosing.charAt(i + 1);\n    return Object(_text__WEBPACK_IMPORTED_MODULE_2__[\"fromCodePoint\"])(ch < 128 ? ch : ch + 1);\n}\nfunction config(state, pos) {\n    let syntax = state.behavior(_state__WEBPACK_IMPORTED_MODULE_1__[\"EditorState\"].syntax);\n    if (syntax.length == 0)\n        return defaults;\n    return syntax[0].languageDataAt(state, pos);\n}\nfunction keydown(view, event) {\n    if (event.ctrlKey || event.metaKey)\n        return false;\n    if (event.keyCode == 8) { // Backspace\n        let tr = handleBackspace(view.state);\n        if (!tr)\n            return false;\n        view.dispatch(tr);\n        return true;\n    }\n    let key = Object(w3c_keyname__WEBPACK_IMPORTED_MODULE_3__[\"keyName\"])(event);\n    if (key.length > 2 || key.length == 2 && Object(_text__WEBPACK_IMPORTED_MODULE_2__[\"codePointAt\"])(key, 0) < _text__WEBPACK_IMPORTED_MODULE_2__[\"minPairCodePoint\"])\n        return false;\n    let tr = handleInsertion(view.state, key);\n    if (!tr)\n        return false;\n    view.dispatch(tr);\n    return true;\n}\n/// Function that implements the extension's backspace behavior.\n/// Exported mostly for testing purposes.\nfunction handleBackspace(state) {\n    let conf = config(state, state.selection.primary.head);\n    let tokens = conf.closeBrackets || defaults.closeBrackets;\n    let tr = state.t(), dont = null;\n    tr.forEachRange(range => {\n        if (!range.empty)\n            return dont = range;\n        let before = prevChar(state.doc, range.head);\n        for (let token of tokens) {\n            if (token == before && nextChar(state.doc, range.head) == closing(Object(_text__WEBPACK_IMPORTED_MODULE_2__[\"codePointAt\"])(token, 0))) {\n                tr.replace(range.head - token.length, range.head + token.length, \"\");\n                return new _state__WEBPACK_IMPORTED_MODULE_1__[\"SelectionRange\"](range.head - token.length);\n            }\n        }\n        return dont = range;\n    });\n    return dont ? null : tr.scrollIntoView();\n}\n/// Implements the extension's behavior on text insertion. Again,\n/// exported mostly for testing.\nfunction handleInsertion(state, ch) {\n    let conf = config(state, state.selection.primary.head);\n    let tokens = conf.closeBrackets || defaults.closeBrackets;\n    for (let tok of tokens) {\n        let closed = closing(Object(_text__WEBPACK_IMPORTED_MODULE_2__[\"codePointAt\"])(tok, 0));\n        if (ch == tok)\n            return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1)\n                : handleOpen(state, tok, closed, conf.closeBracketsBefore || defaults.closeBracketsBefore);\n        if (ch == closed)\n            return handleClose(state, tok, closed);\n    }\n    return null;\n}\nfunction nextChar(doc, pos) {\n    let next = doc.slice(pos, pos + 2);\n    return next.length == 2 && Object(_text__WEBPACK_IMPORTED_MODULE_2__[\"codePointAt\"])(next, 0) < _text__WEBPACK_IMPORTED_MODULE_2__[\"minPairCodePoint\"] ? next.slice(0, 1) : next;\n}\nfunction prevChar(doc, pos) {\n    let prev = doc.slice(pos - 2, pos);\n    return prev.length == 2 && Object(_text__WEBPACK_IMPORTED_MODULE_2__[\"codePointAt\"])(prev, 0) < _text__WEBPACK_IMPORTED_MODULE_2__[\"minPairCodePoint\"] ? prev.slice(1) : prev;\n}\nfunction handleOpen(state, open, close, closeBefore) {\n    let tr = state.t(), dont = null;\n    tr.forEachRange(range => {\n        if (!range.empty) {\n            tr.replace(range.to, range.to, close);\n            tr.replace(range.from, range.from, open);\n            return new _state__WEBPACK_IMPORTED_MODULE_1__[\"SelectionRange\"](range.anchor + open.length, range.head + open.length);\n        }\n        let next = nextChar(state.doc, range.head);\n        if (!next || /\\s/.test(next) || closeBefore.indexOf(next) > -1) {\n            tr.replace(range.head, range.head, open + close);\n            return new _state__WEBPACK_IMPORTED_MODULE_1__[\"SelectionRange\"](range.head + open.length, range.head + open.length);\n        }\n        return dont = range;\n    });\n    return dont ? null : tr.scrollIntoView();\n}\nfunction handleClose(state, open, close) {\n    let tr = state.t(), dont = null;\n    tr.forEachRange(range => {\n        if (range.empty && close == nextChar(state.doc, range.head))\n            return new _state__WEBPACK_IMPORTED_MODULE_1__[\"SelectionRange\"](range.head + close.length);\n        return dont = range;\n    });\n    return dont ? null : tr.scrollIntoView();\n}\n// Handles cases where the open and close token are the same, and\n// possibly triple quotes (as in `\"\"\"abc\"\"\"`-style quoting).\nfunction handleSame(state, token, allowTriple) {\n    let tr = state.t(), dont = null;\n    tr.forEachRange(range => {\n        if (!range.empty) {\n            tr.replace(range.to, range.to, token);\n            tr.replace(range.from, range.from, token);\n            return new _state__WEBPACK_IMPORTED_MODULE_1__[\"SelectionRange\"](range.anchor + token.length, range.head + token.length);\n        }\n        let pos = range.head, next = nextChar(state.doc, pos);\n        if (next == token) {\n            if (nodeStart(state, pos)) {\n                tr.replace(pos, pos, token + token);\n                return new _state__WEBPACK_IMPORTED_MODULE_1__[\"SelectionRange\"](pos + token.length);\n            }\n            else {\n                let isTriple = allowTriple && state.doc.slice(pos, pos + token.length * 3) == token + token + token;\n                return new _state__WEBPACK_IMPORTED_MODULE_1__[\"SelectionRange\"](pos + token.length * (isTriple ? 3 : 1));\n            }\n        }\n        else if (allowTriple && state.doc.slice(pos - 2 * token.length, pos) == token + token &&\n            nodeStart(state, pos - 2 * token.length)) {\n            tr.replace(pos, pos, token + token + token + token);\n            return new _state__WEBPACK_IMPORTED_MODULE_1__[\"SelectionRange\"](pos + token.length);\n        }\n        else if (!Object(_text__WEBPACK_IMPORTED_MODULE_2__[\"isWordChar\"])(next)) {\n            let prev = state.doc.slice(pos - 1, pos);\n            if (!Object(_text__WEBPACK_IMPORTED_MODULE_2__[\"isWordChar\"])(prev) && prev != token) {\n                tr.replace(pos, pos, token + token);\n                return new _state__WEBPACK_IMPORTED_MODULE_1__[\"SelectionRange\"](pos + token.length);\n            }\n        }\n        return dont = range;\n    });\n    return dont ? null : tr.scrollIntoView();\n}\nfunction nodeStart(state, pos) {\n    let syntax = state.behavior(_state__WEBPACK_IMPORTED_MODULE_1__[\"EditorState\"].syntax);\n    if (syntax.length == 0)\n        return false;\n    let tree = syntax[0].getPartialTree(state, pos, pos).resolve(pos + 1);\n    return tree.parent && tree.start == pos;\n}\n\n\n\n\n//# sourceURL=webpack:///./node_modules/@codemirror/next/closebrackets/dist/index.es.js?");

/***/ }),

/***/ "./node_modules/@codemirror/next/commands/dist/index.es.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@codemirror/next/commands/dist/index.es.js ***!
  \*****************************************************************/
/*! exports provided: baseKeymap, deleteCharBackward, deleteCharForward, extendCharLeft, extendCharRight, extendLineDown, extendLineEnd, extendLineStart, extendLineUp, extendWordLeft, extendWordRight, indentSelection, insertNewlineAndIndent, macBaseKeymap, moveCharLeft, moveCharRight, moveLineDown, moveLineEnd, moveLineStart, moveLineUp, moveWordLeft, moveWordRight, pcBaseKeymap, selectAll, selectDocEnd, selectDocStart */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"baseKeymap\", function() { return baseKeymap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"deleteCharBackward\", function() { return deleteCharBackward; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"deleteCharForward\", function() { return deleteCharForward; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"extendCharLeft\", function() { return extendCharLeft; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"extendCharRight\", function() { return extendCharRight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"extendLineDown\", function() { return extendLineDown; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"extendLineEnd\", function() { return extendLineEnd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"extendLineStart\", function() { return extendLineStart; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"extendLineUp\", function() { return extendLineUp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"extendWordLeft\", function() { return extendWordLeft; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"extendWordRight\", function() { return extendWordRight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"indentSelection\", function() { return indentSelection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"insertNewlineAndIndent\", function() { return insertNewlineAndIndent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"macBaseKeymap\", function() { return macBaseKeymap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"moveCharLeft\", function() { return moveCharLeft; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"moveCharRight\", function() { return moveCharRight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"moveLineDown\", function() { return moveLineDown; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"moveLineEnd\", function() { return moveLineEnd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"moveLineStart\", function() { return moveLineStart; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"moveLineUp\", function() { return moveLineUp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"moveWordLeft\", function() { return moveWordLeft; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"moveWordRight\", function() { return moveWordRight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pcBaseKeymap\", function() { return pcBaseKeymap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"selectAll\", function() { return selectAll; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"selectDocEnd\", function() { return selectDocEnd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"selectDocStart\", function() { return selectDocStart; });\n/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../state */ \"./node_modules/@codemirror/next/state/dist/index.es.js\");\n\n\nfunction moveSelection(view, dir, granularity) {\n    let transaction = view.state.t().forEachRange(range => {\n        if (!range.empty && granularity != \"lineboundary\")\n            return new _state__WEBPACK_IMPORTED_MODULE_0__[\"SelectionRange\"](dir == \"left\" || dir == \"backward\" ? range.from : range.to);\n        return new _state__WEBPACK_IMPORTED_MODULE_0__[\"SelectionRange\"](view.movePos(range.head, dir, granularity, \"move\"));\n    });\n    if (transaction.selection.eq(view.state.selection))\n        return false;\n    if (granularity == \"line\")\n        transaction.annotate(_state__WEBPACK_IMPORTED_MODULE_0__[\"Transaction\"].preserveGoalColumn(true));\n    view.dispatch(transaction.scrollIntoView());\n    return true;\n}\n/// Move the selection one character to the left (which is backward in\n/// left-to-right text, forward in right-to-left text).\nconst moveCharLeft = view => moveSelection(view, \"left\", \"character\");\n/// Move the selection one character to the right.\nconst moveCharRight = view => moveSelection(view, \"right\", \"character\");\n/// Move the selection one word to the left.\nconst moveWordLeft = view => moveSelection(view, \"left\", \"word\");\n/// Move the selection one word to the right.\nconst moveWordRight = view => moveSelection(view, \"right\", \"word\");\n/// Move the selection one line up.\nconst moveLineUp = view => moveSelection(view, \"backward\", \"line\");\n/// Move the selection one line down.\nconst moveLineDown = view => moveSelection(view, \"forward\", \"line\");\n/// Move the selection to the start of the line.\nconst moveLineStart = view => moveSelection(view, \"backward\", \"lineboundary\");\n/// Move the selection to the end of the line.\nconst moveLineEnd = view => moveSelection(view, \"forward\", \"lineboundary\");\nfunction extendSelection(view, dir, granularity) {\n    let transaction = view.state.t().forEachRange(range => {\n        return new _state__WEBPACK_IMPORTED_MODULE_0__[\"SelectionRange\"](range.anchor, view.movePos(range.head, dir, granularity, \"extend\"));\n    });\n    if (transaction.selection.eq(view.state.selection))\n        return false;\n    if (granularity == \"line\")\n        transaction.annotate(_state__WEBPACK_IMPORTED_MODULE_0__[\"Transaction\"].preserveGoalColumn(true));\n    view.dispatch(transaction.scrollIntoView());\n    return true;\n}\n/// Move the selection head one character to the left, while leaving\n/// the anchor in place.\nconst extendCharLeft = view => extendSelection(view, \"left\", \"character\");\n/// Move the selection head one character to the right.\nconst extendCharRight = view => extendSelection(view, \"right\", \"character\");\n/// Move the selection head one word to the left.\nconst extendWordLeft = view => extendSelection(view, \"left\", \"word\");\n/// Move the selection head one word to the right.\nconst extendWordRight = view => extendSelection(view, \"right\", \"word\");\n/// Move the selection head one line up.\nconst extendLineUp = view => extendSelection(view, \"backward\", \"line\");\n/// Move the selection head one line down.\nconst extendLineDown = view => extendSelection(view, \"forward\", \"line\");\n/// Move the selection head to the start of the line.\nconst extendLineStart = view => extendSelection(view, \"backward\", \"lineboundary\");\n/// Move the selection head to the end of the line.\nconst extendLineEnd = view => extendSelection(view, \"forward\", \"lineboundary\");\n/// Move the selection to the start of the document.\nconst selectDocStart = ({ state, dispatch }) => {\n    dispatch(state.t().setSelection(_state__WEBPACK_IMPORTED_MODULE_0__[\"EditorSelection\"].single(0)).scrollIntoView());\n    return true;\n};\n/// Move the selection to the end of the document.\nconst selectDocEnd = ({ state, dispatch }) => {\n    dispatch(state.t().setSelection(_state__WEBPACK_IMPORTED_MODULE_0__[\"EditorSelection\"].single(state.doc.length)).scrollIntoView());\n    return true;\n};\n/// Select the entire document.\nconst selectAll = ({ state, dispatch }) => {\n    dispatch(state.t().setSelection(_state__WEBPACK_IMPORTED_MODULE_0__[\"EditorSelection\"].single(0, state.doc.length)));\n    return true;\n};\nfunction deleteText(view, dir) {\n    let transaction = view.state.t().forEachRange((range, transaction) => {\n        let { from, to } = range;\n        if (from == to) {\n            let target = view.movePos(range.head, dir, \"character\", \"move\");\n            from = Math.min(from, target);\n            to = Math.max(to, target);\n        }\n        if (from == to)\n            return range;\n        transaction.replace(from, to, \"\");\n        return new _state__WEBPACK_IMPORTED_MODULE_0__[\"SelectionRange\"](from);\n    });\n    if (!transaction.docChanged)\n        return false;\n    view.dispatch(transaction.scrollIntoView());\n    return true;\n}\n/// Delete the character before the cursor (which is the one to left\n/// in left-to-right text, but the one to the right in right-to-left\n/// text).\nconst deleteCharBackward = view => deleteText(view, \"backward\");\n/// Delete the character after the cursor.\nconst deleteCharForward = view => deleteText(view, \"forward\");\n// FIXME support indenting by tab, configurable indent units\nfunction space(n) {\n    let result = \"\";\n    for (let i = 0; i < n; i++)\n        result += \" \";\n    return result;\n}\nfunction getIndentation(state, pos) {\n    for (let f of state.behavior(_state__WEBPACK_IMPORTED_MODULE_0__[\"EditorState\"].indentation)) {\n        let result = f(state, pos);\n        if (result > -1)\n            return result;\n    }\n    return -1;\n}\n/// Replace the selection with a newline and indent the newly created\n/// line(s).\nconst insertNewlineAndIndent = ({ state, dispatch }) => {\n    let i = 0, indentation = state.selection.ranges.map(r => {\n        let indent = getIndentation(state, r.from);\n        return indent > -1 ? indent : /^\\s*/.exec(state.doc.lineAt(r.from).slice(0, 50))[0].length;\n    });\n    dispatch(state.t().forEachRange(({ from, to }, tr) => {\n        let indent = indentation[i++], line = tr.doc.lineAt(to);\n        while (to < line.end && /s/.test(line.slice(to - line.start, to + 1 - line.start)))\n            to++;\n        tr.replace(from, to, [\"\", space(indent)]);\n        return new _state__WEBPACK_IMPORTED_MODULE_0__[\"SelectionRange\"](from + indent + 1);\n    }).scrollIntoView());\n    return true;\n};\n/// Auto-indent the selected lines. This uses the [indentation\n/// behavor](#state.EditorState^indentation) as source.\nconst indentSelection = ({ state, dispatch }) => {\n    // FIXME this will base all indentation on the same state, which is\n    // wrong (indentation looks at the indent of previous lines, which may\n    // be changed).\n    let lastLine = -1, positions = [];\n    for (let range of state.selection.ranges) {\n        for (let { start, end } = state.doc.lineAt(range.from);;) {\n            if (start != lastLine) {\n                lastLine = start;\n                let indent = getIndentation(state, start), current;\n                if (indent > -1 &&\n                    indent != (current = /^\\s*/.exec(state.doc.slice(start, Math.min(end, start + 100)))[0].length))\n                    positions.push({ pos: start, current, indent });\n            }\n            if (end + 1 > range.to)\n                break;\n            ({ start, end } = state.doc.lineAt(end + 1));\n        }\n    }\n    if (positions.length > 0) {\n        let tr = state.t();\n        for (let { pos, current, indent } of positions) {\n            let start = tr.changes.mapPos(pos);\n            tr.replace(start, start + current, space(indent));\n        }\n        dispatch(tr);\n    }\n    return true;\n};\n/// The default keymap for Linux/Windows/non-Mac platforms. Binds the\n/// arrows for cursor motion, shift-arrow for selection extension,\n/// ctrl-arrows for by-word motion, home/end for line start/end,\n/// ctrl-home/end for document start/end, ctrl-a to select all,\n/// backspace/delete for deletion, and enter for newline-and-indent.\nconst pcBaseKeymap = {\n    \"ArrowLeft\": moveCharLeft,\n    \"ArrowRight\": moveCharRight,\n    \"Shift-ArrowLeft\": extendCharLeft,\n    \"Shift-ArrowRight\": extendCharRight,\n    \"Mod-ArrowLeft\": moveWordLeft,\n    \"Mod-ArrowRight\": moveWordRight,\n    \"Shift-Mod-ArrowLeft\": extendWordLeft,\n    \"Shift-Mod-ArrowRight\": extendWordRight,\n    \"ArrowUp\": moveLineUp,\n    \"ArrowDown\": moveLineDown,\n    \"Shift-ArrowUp\": extendLineUp,\n    \"Shift-ArrowDown\": extendLineDown,\n    \"Home\": moveLineStart,\n    \"End\": moveLineEnd,\n    \"Shift-Home\": extendLineStart,\n    \"Shift-End\": extendLineEnd,\n    \"Mod-Home\": selectDocStart,\n    \"Mod-End\": selectDocEnd,\n    \"Mod-a\": selectAll,\n    \"Backspace\": deleteCharBackward,\n    \"Delete\": deleteCharForward,\n    \"Enter\": insertNewlineAndIndent\n};\n/// The default keymap for Mac platforms. Includes the bindings from\n/// the [PC keymap](#commands.pcBaseKeymap) (using Cmd instead of\n/// Ctrl), and adds Mac-specific default bindings.\nconst macBaseKeymap = {\n    \"Control-b\": moveCharLeft,\n    \"Control-f\": moveCharRight,\n    \"Shift-Control-b\": extendCharLeft,\n    \"Shift-Control-f\": extendCharRight,\n    \"Control-p\": moveLineUp,\n    \"Control-n\": moveLineDown,\n    \"Shift-Control-p\": extendLineUp,\n    \"Shift-Control-n\": extendLineDown,\n    \"Control-a\": moveLineStart,\n    \"Control-e\": moveLineEnd,\n    \"Shift-Control-a\": extendLineStart,\n    \"Shift-Control-e\": extendLineEnd,\n    \"Cmd-ArrowUp\": selectDocStart,\n    \"Cmd-ArrowDown\": selectDocEnd,\n    \"Control-d\": deleteCharForward,\n    \"Control-h\": deleteCharBackward\n};\nfor (let key in pcBaseKeymap)\n    macBaseKeymap[key] = pcBaseKeymap[key];\nconst mac = typeof navigator != \"undefined\" ? /Mac/.test(navigator.platform)\n    : typeof os != \"undefined\" ? os.platform() == \"darwin\" : false;\n/// The default keymap for the current platform.\nconst baseKeymap = mac ? macBaseKeymap : pcBaseKeymap;\n\n\n\n\n//# sourceURL=webpack:///./node_modules/@codemirror/next/commands/dist/index.es.js?");

/***/ }),

/***/ "./node_modules/@codemirror/next/extension/dist/index.es.js":
/*!******************************************************************!*\
  !*** ./node_modules/@codemirror/next/extension/dist/index.es.js ***!
  \******************************************************************/
/*! exports provided: Configuration, ExtensionGroup, combineConfig, fillConfig */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Configuration\", function() { return Configuration; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ExtensionGroup\", function() { return ExtensionGroup; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"combineConfig\", function() { return combineConfig; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fillConfig\", function() { return fillConfig; });\nclass BehaviorData {\n    constructor(combine, isStatic, id) {\n        this.combine = combine;\n        this.id = id;\n        this.static = isStatic;\n        this.empty = combine(none);\n    }\n    static get(behavior) {\n        let value = behavior._data;\n        if (!value)\n            throw new RangeError(\"Not a behavior\");\n        return value;\n    }\n}\n/// All extensions are associated with an extension group. This is\n/// used to distinguish extensions meant for different types of hosts\n/// (such as the editor view and state).\nclass ExtensionGroup {\n    /// Create a new group. Client code probably doesn't need to do\n    /// this. `getStore` retrieves the id-to-value map from a context\n    /// object.\n    constructor(getStore) {\n        this.getStore = getStore;\n        this.nextStorageID = 0;\n        /// Mark an extension with a precedence below the default\n        /// precedence, which will cause default-precedence extensions to\n        /// override it even if they are specified later in the extension\n        /// ordering.\n        this.fallback = setPrec(-1 /* Fallback */);\n        /// Mark an extension with normal precedence.\n        this.normal = setPrec(0 /* Default */);\n        /// Mark an extension with a precedence above the default precedence.\n        this.extend = setPrec(1 /* Extend */);\n        /// Mark an extension with a precedence above the default and\n        /// `extend` precedences.\n        this.override = setPrec(2 /* Override */);\n    }\n    behavior(options = {}) {\n        let behavior = (value) => new ExtensionValue(0 /* Behavior */, behavior, { static: value }, this);\n        behavior._data = new BehaviorData(options.combine || (array => array), !!options.static, this.storageID());\n        return behavior;\n    }\n    /// Create an extension that adds a dynamically computed value for a\n    /// given behavior. Dynamic behavior should usually just read and\n    /// possibly transform a field from the context.\n    dynamic(behavior, read) {\n        if (BehaviorData.get(behavior).static)\n            throw new Error(\"Can't create a dynamic source for a static behavior\");\n        return new ExtensionValue(0 /* Behavior */, behavior, { dynamic: read }, this);\n    }\n    /// Resolve an array of extensions by expanding all extensions until\n    /// only behaviors are left, and then collecting the behaviors into\n    /// arrays of values, preserving precedence ordering throughout.\n    resolve(extensions) {\n        let flat = [];\n        flatten(extensions, 0 /* Default */, new Set(), flat);\n        // Collect the behavior values.\n        let foreign = [];\n        let readBehavior = Object.create(null);\n        for (let ext of flat) {\n            if (ext.type != this) {\n                // Collect extensions of the wrong type into configuration.foreign\n                foreign.push(ext);\n                continue;\n            }\n            let behavior = BehaviorData.get(ext.id);\n            if (Object.prototype.hasOwnProperty.call(readBehavior, behavior.id))\n                continue; // Already collected\n            let values = [];\n            for (let e of flat)\n                if (e.id == ext.id)\n                    e.collect(values);\n            let dynamic = [], parts = [];\n            values.forEach(ext => {\n                if (ext.value.dynamic) {\n                    dynamic.push({ read: ext.value.dynamic, index: parts.length });\n                    parts.push(null);\n                }\n                else {\n                    parts.push(ext.value.static);\n                }\n            });\n            if (dynamic.length == 0) {\n                let value = behavior.combine(parts);\n                readBehavior[behavior.id] = () => value;\n            }\n            else {\n                let cached, cachedValue;\n                readBehavior[behavior.id] = (context) => {\n                    let values = this.getStore(context), found = values[behavior.id];\n                    if (found !== undefined || Object.prototype.hasOwnProperty.call(values, behavior.id))\n                        return found;\n                    let array = parts.slice(), changed = false;\n                    for (let { read, index } of dynamic) {\n                        let newValue = array[index] = read(context);\n                        if (!cached || cached[index] != newValue)\n                            changed = true;\n                    }\n                    cached = array;\n                    return values[behavior.id] = changed ? cachedValue = behavior.combine(array) : cachedValue;\n                };\n            }\n        }\n        return new Configuration(this, extensions, readBehavior, foreign);\n    }\n    /// Allocate a unique storage number for use in field storage. Not\n    /// something client code is likely to need.\n    storageID() { return ++this.nextStorageID; }\n}\nfunction setPrec(prec) {\n    return (extension) => extension instanceof ExtensionValue\n        ? new ExtensionValue(extension.kind, extension.id, extension.value, extension.type, prec)\n        : new ExtensionValue(1 /* Array */, null, extension, null, prec);\n}\n/// And extension is a value that describes a way in which something\n/// is to be extended. FIXME simplify or split\nclass ExtensionValue {\n    /// @internal\n    constructor(\n    /// @internal\n    kind, \n    /// @internal\n    id, \n    /// Holds the field for behaviors, and the array of extensions for\n    /// multi extensions. @internal\n    value, \n    /// @internal\n    type, \n    /// @internal\n    prec = -2 /* None */) {\n        this.kind = kind;\n        this.id = id;\n        this.value = value;\n        this.type = type;\n        this.prec = prec;\n    }\n    // Insert this extension in an array of extensions so that it\n    // appears after any already-present extensions with the same or\n    // lower precedence, but before any extensions with higher\n    // precedence.\n    collect(array) {\n        let i = 0;\n        while (i < array.length && array[i].prec >= this.prec)\n            i++;\n        array.splice(i, 0, this);\n    }\n}\nfunction flatten(extension, prec, seen, target = []) {\n    if (seen.has(extension))\n        return;\n    seen.add(extension);\n    if (Array.isArray(extension)) {\n        for (let ext of extension)\n            flatten(ext, prec, seen, target);\n    }\n    else {\n        let value = extension;\n        if (value.kind == 1 /* Array */) {\n            for (let ext of value.value)\n                flatten(ext, value.prec == -2 /* None */ ? prec : value.prec, seen, target);\n        }\n        else {\n            target.push(value.prec != -2 /* None */ ? value : new ExtensionValue(value.kind, value.id, value.value, value.type, prec));\n        }\n    }\n}\nconst none = [];\n/// A configuration describes the fields and behaviors that exist in a\n/// given set of extensions. It is created with\n/// [`ExtensionGroup.resolve`](#extension.ExtensionGroup.resolve).\nclass Configuration {\n    /// @internal\n    constructor(type, extensions, readBehavior, \n    /// Any extensions that weren't an instance of the target\n    /// extension group when resolving.\n    foreign = []) {\n        this.type = type;\n        this.extensions = extensions;\n        this.readBehavior = readBehavior;\n        this.foreign = foreign;\n    }\n    /// Retrieve the value of a given behavior. When the behavior is\n    /// [static](#extension.ExtensionGroup.behavior), the `context`\n    /// argument can be omitted.\n    getBehavior(behavior, context) {\n        let data = BehaviorData.get(behavior);\n        if (!context && !data.static)\n            throw new RangeError(\"Need a context to retrieve non-static behavior\");\n        let f = this.readBehavior[data.id];\n        return f ? f(context) : data.empty;\n    }\n    /// Replace one or more extensions with new ones, producing a new\n    /// configuration.\n    replaceExtensions(replace) {\n        // FIXME this isn't great yetâ€”have to track the current value to\n        // be able to replace it Do we need it at all anymore? Or can we\n        // just expect client code to store instantiated extensions and\n        // reshuffle them as needed?\n        let extensions = this.extensions.map(e => {\n            for (let [from, to] of replace)\n                if (e == from)\n                    return to;\n            return e;\n        });\n        return this.type.resolve(extensions);\n    }\n}\n/// Utility function for combining behaviors to fill in a config\n/// object from an array of provided configs. Will, by default, error\n/// when a field gets two values that aren't ===-equal, but you can\n/// provide combine functions per field to do something else.\nfunction combineConfig(configs, defaults, // Should hold only the optional properties of Config, but I haven't managed to express that\ncombine = {}) {\n    let result = {};\n    for (let config of configs)\n        for (let key of Object.keys(config)) {\n            let value = config[key], current = result[key];\n            if (current === undefined)\n                result[key] = value;\n            else if (current === value || value === undefined) ; // No conflict\n            else if (Object.hasOwnProperty.call(combine, key))\n                result[key] = combine[key](current, value);\n            else\n                throw new Error(\"Config merge conflict for field \" + key);\n        }\n    for (let key in defaults)\n        if (result[key] === undefined)\n            result[key] = defaults[key];\n    return result;\n}\n/// Defaults the fields in a configuration object to values given in\n/// `defaults` if they are not already present.\nfunction fillConfig(config, defaults) {\n    let result = {};\n    for (let key in config)\n        result[key] = config[key];\n    for (let key in defaults)\n        if (result[key] === undefined)\n            result[key] = defaults[key];\n    return result;\n}\n\n\n\n\n//# sourceURL=webpack:///./node_modules/@codemirror/next/extension/dist/index.es.js?");

/***/ }),

/***/ "./node_modules/@codemirror/next/history/dist/index.es.js":
/*!****************************************************************!*\
  !*** ./node_modules/@codemirror/next/history/dist/index.es.js ***!
  \****************************************************************/
/*! exports provided: closeHistory, history, redo, redoDepth, redoSelection, redoSelectionDepth, undo, undoDepth, undoSelection, undoSelectionDepth */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"closeHistory\", function() { return closeHistory; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"history\", function() { return history; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"redo\", function() { return redo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"redoDepth\", function() { return redoDepth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"redoSelection\", function() { return redoSelection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"redoSelectionDepth\", function() { return redoSelectionDepth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"undo\", function() { return undo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"undoDepth\", function() { return undoDepth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"undoSelection\", function() { return undoSelection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"undoSelectionDepth\", function() { return undoSelectionDepth; });\n/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../state */ \"./node_modules/@codemirror/next/state/dist/index.es.js\");\n/* harmony import */ var _extension__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../extension */ \"./node_modules/@codemirror/next/extension/dist/index.es.js\");\n\n\n\nclass Item {\n    constructor(map, inverted = null, selection = null) {\n        this.map = map;\n        this.inverted = inverted;\n        this.selection = selection;\n    }\n    get isChange() { return this.inverted != null; }\n}\nfunction updateBranch(branch, to, maxLen, newItem) {\n    let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;\n    let newBranch = branch.slice(start, to);\n    newBranch.push(newItem);\n    return newBranch;\n}\nfunction isAdjacent(prev, cur) {\n    return !!prev && cur.from <= prev.mapPos(prev.to, 1) && cur.to >= prev.mapPos(prev.from);\n}\nfunction addChanges(branch, changes, inverted, selectionBefore, maxLen, mayMerge) {\n    if (branch.length) {\n        const lastItem = branch[branch.length - 1];\n        if (lastItem.selection && lastItem.isChange == Boolean(inverted) && mayMerge(lastItem))\n            return inverted ? updateBranch(branch, branch.length - 1, maxLen, new Item(lastItem.map.appendSet(changes.desc), inverted.appendSet(lastItem.inverted), lastItem.selection)) : branch;\n    }\n    return updateBranch(branch, branch.length, maxLen, new Item(changes.desc, inverted, selectionBefore));\n}\nfunction popChanges(branch, only) {\n    let map = null;\n    let idx = branch.length - 1;\n    for (;; idx--) {\n        if (idx < 0)\n            throw new RangeError(\"popChanges called on empty branch\");\n        let entry = branch[idx];\n        if (entry.isChange || (only == 1 /* Any */ && entry.selection))\n            break;\n        map = map ? entry.map.appendSet(map) : entry.map;\n    }\n    let changeItem = branch[idx];\n    let newBranch = branch.slice(0, idx), changes = changeItem.inverted || _state__WEBPACK_IMPORTED_MODULE_0__[\"ChangeSet\"].empty, selection = changeItem.selection;\n    if (map) {\n        let startIndex = changeItem.map.length;\n        map = changeItem.map.appendSet(map);\n        let mappedChanges = [];\n        for (let i = 0; i < changes.length; i++) {\n            let mapped = changes.changes[i].map(map.partialMapping(startIndex - i));\n            if (mapped) {\n                map = map.append(mapped.desc);\n                mappedChanges.push(mapped);\n            }\n        }\n        newBranch.push(new Item(map));\n        changes = new _state__WEBPACK_IMPORTED_MODULE_0__[\"ChangeSet\"](mappedChanges); // FIXME preserve mirror data?\n        selection = selection.map(map);\n    }\n    return { changes, branch: newBranch, selection };\n}\nfunction nope() { return false; }\nfunction eqSelectionShape(a, b) {\n    return a.ranges.length == b.ranges.length &&\n        a.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0;\n}\nclass HistoryState {\n    constructor(done, undone, prevTime = null, prevUserEvent = undefined) {\n        this.done = done;\n        this.undone = undone;\n        this.prevTime = prevTime;\n        this.prevUserEvent = prevUserEvent;\n    }\n    resetTime() {\n        return new HistoryState(this.done, this.undone);\n    }\n    addChanges(changes, inverted, selection, time, userEvent, newGroupDelay, maxLen) {\n        let mayMerge = nope;\n        if (this.prevTime !== null && time - this.prevTime < newGroupDelay &&\n            (inverted || (this.prevUserEvent == userEvent && userEvent == \"keyboard\")))\n            mayMerge = inverted\n                ? prev => isAdjacent(prev.map.changes[prev.map.length - 1], changes.changes[0])\n                : prev => eqSelectionShape(prev.selection, selection);\n        return new HistoryState(addChanges(this.done, changes, inverted, selection, maxLen, mayMerge), this.undone, time, userEvent);\n    }\n    addMapping(map, maxLen) {\n        if (this.done.length == 0)\n            return this;\n        return new HistoryState(updateBranch(this.done, this.done.length, maxLen, new Item(map)), this.undone);\n    }\n    canPop(done, only) {\n        const target = done == 0 /* Done */ ? this.done : this.undone;\n        for (const { isChange, selection } of target)\n            if (isChange || (only == 1 /* Any */ && selection))\n                return true;\n        return false;\n    }\n    pop(done, only, transaction, maxLen) {\n        let { changes, branch, selection } = popChanges(done == 0 /* Done */ ? this.done : this.undone, only);\n        let oldSelection = transaction.selection;\n        for (let change of changes.changes)\n            transaction.change(change);\n        transaction.setSelection(selection);\n        let otherBranch = (done == 0 /* Done */ ? this.undone : this.done);\n        otherBranch = addChanges(otherBranch, transaction.changes, transaction.changes.length > 0 ? transaction.invertedChanges() : null, oldSelection, maxLen, nope);\n        return { transaction, state: new HistoryState(done == 0 /* Done */ ? branch : otherBranch, done == 0 /* Done */ ? otherBranch : branch) };\n    }\n    eventCount(done, only) {\n        let count = 0, branch = done == 0 /* Done */ ? this.done : this.undone;\n        for (const { isChange, selection } of branch)\n            if (isChange || (only == 1 /* Any */ && selection))\n                ++count;\n        return count;\n    }\n}\nHistoryState.empty = new HistoryState([], []);\n\nconst historyStateAnnotation = _state__WEBPACK_IMPORTED_MODULE_0__[\"Annotation\"].define();\nconst closeHistoryAnnotation = _state__WEBPACK_IMPORTED_MODULE_0__[\"Annotation\"].define();\nconst historyField = new _state__WEBPACK_IMPORTED_MODULE_0__[\"StateField\"]({\n    init(editorState) {\n        return HistoryState.empty;\n    },\n    apply(tr, state, editorState) {\n        const fromMeta = tr.annotation(historyStateAnnotation);\n        if (fromMeta)\n            return fromMeta;\n        if (tr.annotation(closeHistoryAnnotation))\n            state = state.resetTime();\n        if (!tr.changes.length && !tr.selectionSet)\n            return state;\n        let config = editorState.behavior(historyConfig);\n        if (tr.annotation(_state__WEBPACK_IMPORTED_MODULE_0__[\"Transaction\"].addToHistory) !== false)\n            return state.addChanges(tr.changes, tr.changes.length ? tr.invertedChanges() : null, tr.startState.selection, tr.annotation(_state__WEBPACK_IMPORTED_MODULE_0__[\"Transaction\"].time), tr.annotation(_state__WEBPACK_IMPORTED_MODULE_0__[\"Transaction\"].userEvent), config.newGroupDelay, config.minDepth);\n        return state.addMapping(tr.changes.desc, config.minDepth);\n    }\n});\nconst historyConfig = _state__WEBPACK_IMPORTED_MODULE_0__[\"EditorState\"].extend.behavior({\n    combine(configs) {\n        return Object(_extension__WEBPACK_IMPORTED_MODULE_1__[\"combineConfig\"])(configs, {\n            minDepth: 100,\n            newGroupDelay: 500\n        }, { minDepth: Math.max, newGroupDelay: Math.min });\n    }\n});\n/// Create a history extension with the given configuration.\nfunction history(config = {}) {\n    return [\n        historyField.extension,\n        historyConfig(config)\n    ];\n}\nfunction cmd(target, only) {\n    return function ({ state, dispatch }) {\n        let config = state.behavior(historyConfig);\n        let historyState = state.field(historyField, false);\n        if (!historyState || !historyState.canPop(target, only))\n            return false;\n        const { transaction, state: newState } = historyState.pop(target, only, state.t(), config.minDepth);\n        dispatch(transaction.annotate(historyStateAnnotation(newState)));\n        return true;\n    };\n}\n/// Undo a single group of history events. Returns false if no group\n/// was available.\nconst undo = cmd(0 /* Done */, 0 /* OnlyChanges */);\n/// Redo a group of history events. Returns false if no group was\n/// available.\nconst redo = cmd(1 /* Undone */, 0 /* OnlyChanges */);\n/// Undo a selection change.\nconst undoSelection = cmd(0 /* Done */, 1 /* Any */);\n/// Redo a selection change.\nconst redoSelection = cmd(1 /* Undone */, 1 /* Any */);\n/// Set a flag on the given transaction that will prevent further steps\n/// from being appended to an existing history event (so that they\n/// require a separate undo command to undo).\nfunction closeHistory(tr) {\n    return tr.annotate(closeHistoryAnnotation(true));\n}\nfunction depth(target, only) {\n    return function (state) {\n        let histState = state.field(historyField, false);\n        return histState ? histState.eventCount(target, only) : 0;\n    };\n}\n/// The amount of undoable change events available in a given state.\nconst undoDepth = depth(0 /* Done */, 0 /* OnlyChanges */);\n/// The amount of redoable change events available in a given state.\nconst redoDepth = depth(1 /* Undone */, 0 /* OnlyChanges */);\n/// The amount of undoable events available in a given state.\nconst redoSelectionDepth = depth(0 /* Done */, 1 /* Any */);\n/// The amount of redoable events available in a given state.\nconst undoSelectionDepth = depth(1 /* Undone */, 1 /* Any */);\n\n\n\n\n//# sourceURL=webpack:///./node_modules/@codemirror/next/history/dist/index.es.js?");

/***/ }),

/***/ "./node_modules/@codemirror/next/keymap/dist/index.es.js":
/*!***************************************************************!*\
  !*** ./node_modules/@codemirror/next/keymap/dist/index.es.js ***!
  \***************************************************************/
/*! exports provided: NormalizedKeymap, keymap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NormalizedKeymap\", function() { return NormalizedKeymap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"keymap\", function() { return keymap; });\n/* harmony import */ var w3c_keyname__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! w3c-keyname */ \"./node_modules/w3c-keyname/index.es.js\");\n/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../view */ \"./node_modules/@codemirror/next/view/dist/index.es.js\");\n\n\n\nconst mac = typeof navigator != \"undefined\" ? /Mac/.test(navigator.platform) : false;\nfunction normalizeKeyName(name) {\n    const parts = name.split(/-(?!$)/);\n    let result = parts[parts.length - 1];\n    if (result == \"Space\")\n        result = \" \";\n    let alt, ctrl, shift, meta;\n    for (let i = 0; i < parts.length - 1; ++i) {\n        const mod = parts[i];\n        if (/^(cmd|meta|m)$/i.test(mod))\n            meta = true;\n        else if (/^a(lt)?$/i.test(mod))\n            alt = true;\n        else if (/^(c|ctrl|control)$/i.test(mod))\n            ctrl = true;\n        else if (/^s(hift)?$/i.test(mod))\n            shift = true;\n        else if (/^mod$/i.test(mod)) {\n            if (mac)\n                meta = true;\n            else\n                ctrl = true;\n        }\n        else\n            throw new Error(\"Unrecognized modifier name: \" + mod);\n    }\n    if (alt)\n        result = \"Alt-\" + result;\n    if (ctrl)\n        result = \"Ctrl-\" + result;\n    if (meta)\n        result = \"Meta-\" + result;\n    if (shift)\n        result = \"Shift-\" + result;\n    return result;\n}\nfunction modifiers(name, event, shift) {\n    if (event.altKey)\n        name = \"Alt-\" + name;\n    if (event.ctrlKey)\n        name = \"Ctrl-\" + name;\n    if (event.metaKey)\n        name = \"Meta-\" + name;\n    if (shift !== false && event.shiftKey)\n        name = \"Shift-\" + name;\n    return name;\n}\n/// Create a view extension that registers a keymap.\n///\n/// You can add multiple keymap behaviors to an editor. Their\n/// priorities determine their precedence (the ones specified early or\n/// with high priority get to dispatch first). When a handler has\n/// returned `true` for a given key, no further handlers are called.\nconst keymap = (map) => {\n    let set = new NormalizedKeymap(map);\n    return _view__WEBPACK_IMPORTED_MODULE_1__[\"EditorView\"].handleDOMEvents({\n        keydown(view, event) {\n            let handler = set.get(event);\n            return handler ? handler(view) : false;\n        }\n    });\n};\n/// Stores a set of keybindings in normalized form, and helps looking\n/// up the binding for a keyboard event. Only needed when binding keys\n/// in some custom way.\nclass NormalizedKeymap {\n    /// Create a normalized map.\n    constructor(map) {\n        this.map = Object.create(null);\n        for (const prop in map)\n            this.map[normalizeKeyName(prop)] = map[prop];\n    }\n    /// Look up the binding for the given keyboard event, or `undefined`\n    /// if none is found.\n    get(event) {\n        const name = Object(w3c_keyname__WEBPACK_IMPORTED_MODULE_0__[\"keyName\"])(event), isChar = name.length == 1 && name != \" \";\n        const direct = this.map[modifiers(name, event, !isChar)];\n        if (direct)\n            return direct;\n        let baseName;\n        if (isChar && (event.shiftKey || event.altKey || event.metaKey) &&\n            (baseName = w3c_keyname__WEBPACK_IMPORTED_MODULE_0__[\"base\"][event.keyCode]) && baseName != name) {\n            const fromCode = this.map[modifiers(baseName, event, true)];\n            if (fromCode)\n                return fromCode;\n        }\n        return undefined;\n    }\n}\n\n\n\n\n//# sourceURL=webpack:///./node_modules/@codemirror/next/keymap/dist/index.es.js?");

/***/ }),

/***/ "./node_modules/@codemirror/next/matchbrackets/dist/index.es.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@codemirror/next/matchbrackets/dist/index.es.js ***!
  \**********************************************************************/
/*! exports provided: bracketMatching, matchBrackets */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"bracketMatching\", function() { return bracketMatching; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"matchBrackets\", function() { return matchBrackets; });\n/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../state */ \"./node_modules/@codemirror/next/state/dist/index.es.js\");\n/* harmony import */ var _extension__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../extension */ \"./node_modules/@codemirror/next/extension/dist/index.es.js\");\n/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../view */ \"./node_modules/@codemirror/next/view/dist/index.es.js\");\n/* harmony import */ var lezer_tree__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lezer-tree */ \"./node_modules/lezer-tree/dist/tree.js\");\n/* harmony import */ var lezer_tree__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lezer_tree__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _syntax__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../syntax */ \"./node_modules/@codemirror/next/syntax/dist/index.es.js\");\n/* harmony import */ var style_mod__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! style-mod */ \"./node_modules/style-mod/src/style-mod.js\");\n\n\n\n\n\n\n\nconst defaultStyles = new style_mod__WEBPACK_IMPORTED_MODULE_5__[\"StyleModule\"]({\n    matchingBracket: { color: \"#0b0\" },\n    nonmatchingBracket: { color: \"#a22\" }\n});\nconst DEFAULT_SCAN_DIST = 10000, DEFAULT_BRACKETS = \"()[]{}\";\nconst bracketMatchingConfig = _view__WEBPACK_IMPORTED_MODULE_2__[\"EditorView\"].extend.behavior({\n    combine(configs) {\n        return Object(_extension__WEBPACK_IMPORTED_MODULE_1__[\"combineConfig\"])(configs, {\n            afterCursor: true,\n            brackets: DEFAULT_BRACKETS,\n            maxScanDistance: DEFAULT_SCAN_DIST\n        });\n    }\n});\nconst bracketMatchingUnique = [\n    _view__WEBPACK_IMPORTED_MODULE_2__[\"EditorView\"].extend.fallback(_view__WEBPACK_IMPORTED_MODULE_2__[\"EditorView\"].styleModule(defaultStyles)),\n    _view__WEBPACK_IMPORTED_MODULE_2__[\"ViewPlugin\"].decoration({\n        create() { return _view__WEBPACK_IMPORTED_MODULE_2__[\"Decoration\"].none; },\n        update(deco, update) {\n            if (!update.transactions.length)\n                return deco;\n            let { state } = update, decorations = [];\n            let config = update.view.behavior(bracketMatchingConfig);\n            for (let range of state.selection.ranges) {\n                if (!range.empty)\n                    continue;\n                let match = matchBrackets(state, range.head, -1, config)\n                    || (range.head > 0 && matchBrackets(state, range.head - 1, 1, config))\n                    || (config.afterCursor &&\n                        (matchBrackets(state, range.head, 1, config) ||\n                            (range.head < state.doc.length && matchBrackets(state, range.head + 1, -1, config))));\n                if (!match)\n                    continue;\n                let styleName = match.matched ? \"matchingBracket\" : \"nonmatchingBracket\";\n                let style = update.view.cssClass(styleName) + \" \" + defaultStyles[styleName];\n                decorations.push(_view__WEBPACK_IMPORTED_MODULE_2__[\"Decoration\"].mark(match.start.from, match.start.to, { class: style }));\n                if (match.end)\n                    decorations.push(_view__WEBPACK_IMPORTED_MODULE_2__[\"Decoration\"].mark(match.end.from, match.end.to, { class: style }));\n            }\n            return _view__WEBPACK_IMPORTED_MODULE_2__[\"Decoration\"].set(decorations);\n        }\n    })\n];\n/// Create an extension that enables bracket matching. Whenever the\n/// cursor is next to a bracket, that bracket and the one it matches\n/// are highlighted. Or, when no matching bracket is found, another\n/// highlighting style is used to indicate this.\nfunction bracketMatching(config = {}) {\n    return [bracketMatchingConfig(config), bracketMatchingUnique];\n}\nfunction getTree(state, pos, dir, maxScanDistance) {\n    for (let syntax of state.behavior(_state__WEBPACK_IMPORTED_MODULE_0__[\"EditorState\"].syntax)) {\n        return syntax.getPartialTree(state, dir < 0 ? Math.max(0, pos - maxScanDistance) : pos, dir < 0 ? pos : Math.min(state.doc.length, pos + maxScanDistance));\n    }\n    return lezer_tree__WEBPACK_IMPORTED_MODULE_3__[\"Tree\"].empty;\n}\nfunction matchingNodes(node, dir, brackets) {\n    let byProp = node.prop(dir < 0 ? _syntax__WEBPACK_IMPORTED_MODULE_4__[\"closeNodeProp\"] : _syntax__WEBPACK_IMPORTED_MODULE_4__[\"openNodeProp\"]);\n    if (byProp)\n        return byProp;\n    if (node.name.length == 1) {\n        let index = brackets.indexOf(node.name);\n        if (index > -1 && index % 2 == (dir < 0 ? 1 : 0))\n            return [brackets[index + dir]];\n    }\n    return null;\n}\n/// Find the matching bracket for the token at `pos`, scanning\n/// direction `dir`. Only the `brackets` and `maxScanDistance`\n/// properties are used from `config`, if given. Returns null if no\n/// bracket was found at `pos`, or a match result otherwise.\nfunction matchBrackets(state, pos, dir, config = {}) {\n    let maxScanDistance = config.maxScanDistance || DEFAULT_SCAN_DIST, brackets = config.brackets || DEFAULT_BRACKETS;\n    let tree = getTree(state, pos, dir, maxScanDistance);\n    let sub = tree.resolve(pos, dir), matches;\n    if (matches = matchingNodes(sub.type, dir, brackets))\n        return matchMarkedBrackets(state, pos, dir, sub, matches, brackets);\n    else\n        return matchPlainBrackets(state, pos, dir, tree, sub.type, maxScanDistance, brackets);\n}\nfunction matchMarkedBrackets(state, pos, dir, token, matching, brackets) {\n    let parent = token.parent, firstToken = { from: token.start, to: token.end };\n    let depth = 0;\n    return (parent && parent.iterate({\n        from: dir < 0 ? token.start : token.end,\n        to: dir < 0 ? parent.start : parent.end,\n        enter(type, from, to) {\n            if (dir < 0 ? to > token.start : from < token.end)\n                return undefined;\n            if (depth == 0 && matching.indexOf(type.name) > -1) {\n                return { start: firstToken, end: { from, to }, matched: true };\n            }\n            else if (matchingNodes(type, dir, brackets)) {\n                depth++;\n            }\n            else if (matchingNodes(type, -dir, brackets)) {\n                depth--;\n                if (depth == 0)\n                    return { start: firstToken, end: { from, to }, matched: false };\n            }\n            return false;\n        }\n    })) || { start: firstToken, matched: false };\n}\nfunction matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {\n    let startCh = dir < 0 ? state.doc.slice(pos - 1, pos) : state.doc.slice(pos, pos + 1);\n    let bracket = brackets.indexOf(startCh);\n    if (bracket < 0 || (bracket % 2 == 0) != (dir > 0))\n        return null;\n    let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos };\n    let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;\n    for (let distance = 0; !(iter.next()).done && distance <= maxScanDistance;) {\n        let text = iter.value;\n        if (dir < 0)\n            distance += text.length;\n        let basePos = pos + distance * dir;\n        for (let pos = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos != end; pos += dir) {\n            let found = brackets.indexOf(text[pos]);\n            if (found < 0 || tree.resolve(basePos + pos, 1).type != tokenType)\n                continue;\n            if ((found % 2 == 0) == (dir > 0)) {\n                depth++;\n            }\n            else if (depth == 1) { // Closing\n                return { start: startToken, end: { from: basePos + pos, to: basePos + pos + 1 }, matched: (found >> 1) == (bracket >> 1) };\n            }\n            else {\n                depth--;\n            }\n        }\n        if (dir > 0)\n            distance += text.length;\n    }\n    return iter.done ? { start: startToken, matched: false } : null;\n}\n\n\n\n\n//# sourceURL=webpack:///./node_modules/@codemirror/next/matchbrackets/dist/index.es.js?");

/***/ }),

/***/ "./node_modules/@codemirror/next/rangeset/dist/index.es.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@codemirror/next/rangeset/dist/index.es.js ***!
  \*****************************************************************/
/*! exports provided: Range, RangeSet, RangeValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Range\", function() { return Range; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RangeSet\", function() { return RangeSet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RangeValue\", function() { return RangeValue; });\n/// Each range is associated with a value, which must inherit from\n/// this class.\nclass RangeValue {\n    /// Compare this value with another value. The default\n    /// implementation compares by identity.\n    eq(other) { return this == other; }\n}\nRangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;\nRangeValue.prototype.point = false;\n/// A range associates a value with a range of positions.\nclass Range {\n    constructor(from, to, value) {\n        this.from = from;\n        this.to = to;\n        this.value = value;\n    }\n    /// @internal\n    map(changes, oldOffset, newOffset) {\n        let mapped = this.value.map(changes, this.from + oldOffset, this.to + oldOffset);\n        if (mapped) {\n            mapped.from -= newOffset;\n            mapped.to -= newOffset;\n        }\n        return mapped;\n    }\n    /// @internal\n    move(offset) {\n        return offset ? new Range(this.from + offset, this.to + offset, this.value) : this;\n    }\n    /// @internal Here so that we can put active ranges on a heap and\n    /// take them off at their end\n    get heapPos() { return this.to; }\n    /// @internal\n    get heapSide() { return this.value.endSide; }\n}\nconst none = [];\nfunction maybeNone(array) { return array.length ? array : none; }\nconst BASE_NODE_SIZE_SHIFT = 5, BASE_NODE_SIZE = 1 << BASE_NODE_SIZE_SHIFT;\n/// A range set stores a collection of [ranges](#rangeset.Range) in a\n/// way that makes them efficient to [map](#rangeset.RangeSet.map) and\n/// [update](#rangeset.RangeSet.update). This is an immutable data\n/// structure.\nclass RangeSet {\n    /// @internal\n    constructor(\n    /// @internal The text length covered by this set\n    length, \n    /// The number of ranges in this set\n    size, \n    /// @internal The locally stored rangesâ€”which are all of them for\n    /// leaf nodes, and the ones that don't fit in child sets for\n    /// non-leaves. Sorted by start position, then side.\n    local, \n    /// @internal The child sets, in position order. Their total\n    /// length may be smaller than .length if the end is empty (never\n    /// greater)\n    children) {\n        this.length = length;\n        this.size = size;\n        this.local = local;\n        this.children = children;\n    }\n    /// Update this set, returning the modified set. The range that gets\n    /// filtered can be limited with the `filterFrom` and `filterTo`\n    /// arguments (specifying a smaller range makes the operation\n    /// cheaper).\n    update(added = none, filter = null, filterFrom = 0, filterTo = this.length) {\n        let maxLen = added.reduce((l, d) => Math.max(l, d.to), this.length);\n        // Make sure `added` is sorted\n        if (added.length)\n            for (let i = 1, prev = added[0]; i < added.length; i++) {\n                let next = added[i];\n                if (byPos(prev, next) > 0) {\n                    added = added.slice().sort(byPos);\n                    break;\n                }\n                prev = next;\n            }\n        return this.updateInner(added, filter, filterFrom, filterTo, 0, maxLen);\n    }\n    /// @internal\n    updateInner(added, filter, filterFrom, filterTo, offset, length) {\n        // The new local ranges. Null means no changes were made yet\n        let local = filterRanges(this.local, filter, filterFrom, filterTo, offset);\n        // The new array of child sets, if changed\n        let children = null;\n        let size = 0;\n        let decI = 0, pos = offset;\n        // Iterate over the child sets, applying filters and pushing added\n        // ranges into them\n        for (let i = 0; i < this.children.length; i++) {\n            let child = this.children[i];\n            let endPos = pos + child.length, localRanges = null;\n            while (decI < added.length) {\n                let next = added[decI];\n                if (next.from >= endPos)\n                    break;\n                decI++;\n                if (next.to > endPos) {\n                    if (!local)\n                        local = this.local.slice();\n                    insertSorted(local, next.move(-offset));\n                }\n                else {\n                    (localRanges || (localRanges = [])).push(next);\n                }\n            }\n            let newChild = child;\n            if (localRanges || filter && filterFrom <= endPos && filterTo >= pos)\n                newChild = newChild.updateInner(localRanges || none, filter, filterFrom, filterTo, pos, newChild.length);\n            if (newChild != child)\n                (children || (children = this.children.slice(0, i))).push(newChild);\n            else if (children)\n                children.push(newChild);\n            size += newChild.size;\n            pos = endPos;\n        }\n        // If nothing was actually updated, return the existing object\n        if (!local && !children && decI == added.length)\n            return this;\n        // Compute final size\n        size += (local || this.local).length + added.length - decI;\n        // This is a small nodeâ€”turn it into a flat leaf\n        if (size <= BASE_NODE_SIZE)\n            return collapseSet(children || this.children, local || this.local.slice(), added, decI, offset, length);\n        let childSize = Math.max(BASE_NODE_SIZE, size >> BASE_NODE_SIZE_SHIFT);\n        if (decI < added.length) {\n            if (!children)\n                children = this.children.slice();\n            if (!local)\n                local = this.local.slice();\n            appendRanges(local, children, added, decI, offset, length, pos, childSize);\n        }\n        if (children) {\n            if (!local)\n                local = this.local.slice();\n            rebalanceChildren(local, children, childSize);\n        }\n        return new RangeSet(length, size, maybeNone(local || this.local), maybeNone(children || this.children));\n    }\n    /// Add empty size to the end of the set @internal\n    grow(length) {\n        return new RangeSet(this.length + length, this.size, this.local, this.children);\n    }\n    /// Collect all ranges in this set into the target array, offsetting\n    /// them by `offset` @internal\n    collect(target, offset) {\n        for (let range of this.local)\n            target.push(range.move(offset));\n        for (let child of this.children) {\n            child.collect(target, offset);\n            offset += child.length;\n        }\n    }\n    /// Map this range set through a set of changes, return the new set.\n    map(changes) {\n        if (changes.length == 0 || this == RangeSet.empty)\n            return this;\n        return this.mapInner(changes, 0, 0, changes.mapPos(this.length, 1)).set;\n    }\n    // Child boundaries are always mapped forward. This may cause ranges\n    // at the start of a set to end up sticking out before its new\n    // start, if they map backward. Such ranges are returned in\n    // `escaped`.\n    mapInner(changes, oldStart, newStart, newEnd) {\n        let newLocal = null;\n        let escaped = null;\n        let newLength = newEnd - newStart, newSize = 0;\n        for (let i = 0; i < this.local.length; i++) {\n            let range = this.local[i], mapped = range.map(changes, oldStart, newStart);\n            let escape = mapped != null && (mapped.from < 0 || mapped.to > newLength);\n            if (newLocal == null && (range != mapped || escape))\n                newLocal = this.local.slice(0, i);\n            if (escape)\n                (escaped || (escaped = [])).push(mapped);\n            else if (newLocal && mapped)\n                newLocal.push(mapped);\n        }\n        let newChildren = null;\n        for (let i = 0, oldPos = oldStart, newPos = newStart; i < this.children.length; i++) {\n            let child = this.children[i], newChild = child;\n            let oldChildEnd = oldPos + child.length;\n            let newChildEnd = changes.mapPos(oldPos + child.length, 1);\n            let touch = touchesChanges(oldPos, oldChildEnd, changes.changes);\n            if (touch == 0 /* Yes */) {\n                let inner = child.mapInner(changes, oldPos, newPos, newChildEnd);\n                newChild = inner.set;\n                if (inner.escaped)\n                    for (let range of inner.escaped) {\n                        range = range.move(newPos - newStart);\n                        if (range.from < 0 || range.to > newLength)\n                            insertSorted(escaped || (escaped = []), range);\n                        else\n                            insertSorted(newLocal || (newLocal = this.local.slice()), range);\n                    }\n            }\n            else if (touch == 2 /* Covered */) {\n                newChild = RangeSet.empty.grow(newChildEnd - newPos);\n            }\n            if (newChild != child) {\n                if (newChildren == null)\n                    newChildren = this.children.slice(0, i);\n                // If the node's content was completely deleted by mapping,\n                // drop the nodeâ€”which is complicated by the need to\n                // distribute its length to another child when it's not the\n                // last child\n                if (newChild.size == 0 && (newChild.length == 0 || newChildren.length || i == this.children.length)) {\n                    if (newChild.length > 0 && i > 0) {\n                        let last = newChildren.length - 1, lastChild = newChildren[last];\n                        newChildren[last] = new RangeSet(lastChild.length + newChild.length, lastChild.size, lastChild.local, lastChild.children);\n                    }\n                }\n                else {\n                    newChildren.push(newChild);\n                }\n            }\n            else if (newChildren) {\n                newChildren.push(newChild);\n            }\n            newSize += newChild.size;\n            oldPos = oldChildEnd;\n            newPos = newChildEnd;\n        }\n        let set = newLength == this.length && newChildren == null && newLocal == null\n            ? this\n            : new RangeSet(newLength, newSize + (newLocal || this.local).length, newLocal || this.local, newChildren || this.children);\n        return { set, escaped };\n    }\n    /// Iterate over the ranges that touch the region `from` to `to`,\n    /// calling `f` for each. There is no guarantee that the ranges will\n    /// be reported in any order.\n    between(from, to, f) {\n        this.betweenInner(from, to, f, 0);\n    }\n    /// @internal\n    betweenInner(from, to, f, offset) {\n        for (let loc of this.local) {\n            if (loc.from + offset <= to && loc.to + offset >= from)\n                f(loc.from + offset, loc.to + offset, loc.value);\n        }\n        for (let child of this.children) {\n            let end = offset + child.length;\n            if (offset <= to && end >= from)\n                child.betweenInner(from, to, f, offset);\n            offset = end;\n        }\n    }\n    /// Iterate over the ranges in the set that touch the area between\n    /// from and to, ordered by their start position and side.\n    iter(from = 0, to = this.length) {\n        const heap = [];\n        addIterToHeap(heap, [new IteratedSet(0, this)], from);\n        if (this.local.length)\n            addToHeap(heap, new LocalSet(0, this.local));\n        return {\n            next() {\n                for (;;) {\n                    if (heap.length == 0)\n                        return;\n                    const next = takeFromHeap(heap);\n                    const range = next.ranges[next.index++].move(next.offset);\n                    if (range.from > to)\n                        return;\n                    // Put the rest of the set back onto the heap\n                    if (next.index < next.ranges.length)\n                        addToHeap(heap, next);\n                    else if (next.next)\n                        addIterToHeap(heap, next.next, 0);\n                    if (range.to >= from)\n                        return range;\n                }\n            }\n        };\n    }\n    /// Iterate over two range sets at the same time, calling methods on\n    /// `comparator` to notify it of possible differences. `textDiff`\n    /// indicates how the underlying data changed between these ranges,\n    /// and is needed to synchronize the iteration.\n    compare(other, textDiff, comparator, oldLen) {\n        let oldPos = 0, newPos = 0;\n        for (let range of textDiff) {\n            if (range.fromB > newPos && (this != other || oldPos != newPos))\n                new RangeSetComparison(this, oldPos, other, newPos, range.fromB, comparator).run();\n            oldPos = range.toA;\n            newPos = range.toB;\n        }\n        if (oldPos < this.length || newPos < other.length || textDiff.length == 0)\n            new RangeSetComparison(this, oldPos, other, newPos, newPos + (oldLen - oldPos), comparator).run();\n    }\n    /// Iterate over a group of range sets at the same time, notifying\n    /// the iterator about the ranges covering every given piece of\n    /// content.\n    static iterateSpans(sets, from, to, iterator) {\n        let heap = [];\n        let pos = from, posSide = -FAR;\n        for (let set of sets)\n            if (set.size > 0) {\n                addIterToHeap(heap, [new IteratedSet(0, set)], pos);\n                if (set.local.length)\n                    addToHeap(heap, new LocalSet(0, set.local));\n            }\n        let active = [];\n        while (heap.length > 0) {\n            let next = takeFromHeap(heap);\n            if (next instanceof LocalSet) {\n                let range = next.ranges[next.index], rFrom = range.from + next.offset, rTo = range.to + next.offset;\n                if (rFrom > to)\n                    break;\n                // Put the rest of the set back onto the heap\n                if (++next.index < next.ranges.length)\n                    addToHeap(heap, next);\n                else if (next.next)\n                    addIterToHeap(heap, next.next, pos);\n                if ((rTo - pos || range.value.endSide - posSide) >= 0 && !iterator.ignore(rFrom, rTo, range.value)) {\n                    if (rFrom > pos) {\n                        iterator.span(pos, rFrom, active);\n                        pos = rFrom;\n                        posSide = range.value.startSide;\n                    }\n                    if (range.value.point) {\n                        iterator.point(pos, Math.min(rTo, to), range.value, rFrom < pos, rTo > to);\n                        pos = rTo;\n                        if (rTo > to)\n                            break;\n                        posSide = range.value.endSide;\n                    }\n                    else if (rTo > pos) {\n                        active.push(range.value);\n                        addToHeap(heap, new Range(rFrom, rTo, range.value));\n                    }\n                }\n            }\n            else { // A range that ends here\n                let range = next;\n                if (range.to > to)\n                    break;\n                if (range.to > pos) {\n                    iterator.span(pos, range.to, active);\n                    pos = range.to;\n                    posSide = range.value.endSide;\n                }\n                active.splice(active.indexOf(range.value), 1);\n            }\n        }\n        if (pos < to)\n            iterator.span(pos, to, active);\n    }\n    /// Create a range set for the given range or array of ranges.\n    static of(ranges) {\n        return RangeSet.empty.update(ranges instanceof Range ? [ranges] : ranges);\n    }\n}\n/// The empty set of ranges.\nRangeSet.empty = new RangeSet(0, 0, none, none);\n// Stack element for iterating over a range set\nclass IteratedSet {\n    constructor(offset, set) {\n        this.offset = offset;\n        this.set = set;\n        // Index == -1 means the set's locals have not been yielded yet.\n        // Otherwise this is an index in the set's child array.\n        this.index = 0;\n    }\n}\n// Cursor into a node-local set of ranges\nclass LocalSet {\n    constructor(offset, ranges, next = null) {\n        this.offset = offset;\n        this.ranges = ranges;\n        this.next = next;\n        this.index = 0;\n    }\n    // Used to make this conform to Heapable\n    get heapPos() { return this.ranges[this.index].from + this.offset; }\n    get heapSide() { return this.ranges[this.index].value.startSide; }\n}\n// Iterating over a range set is done using a stack that represents a\n// position into the range set's tree. There's an IteratedSet for each\n// active level, and iteration happens by calling this function to\n// move the next node onto the stack (which may involve popping off\n// nodes before it).\n//\n// Such a stack represenst the _structural_ part of the tree,\n// iterating over tree nodes. The individual ranges of each top node\n// must be accessed separately, after it has been moved onto the stack\n// (the new node is always at the top, or, if the end of the set has\n// been reached, the stack is empty).\n//\n// Nodes that fall entirely before `skipTo` are never added to the\n// stack, allowing efficient skipping of parts of the tree.\nfunction iterRangeSet(stack, skipTo = 0) {\n    for (;;) {\n        if (stack.length == 0)\n            break;\n        let top = stack[stack.length - 1];\n        if (top.index == top.set.children.length) {\n            stack.pop();\n        }\n        else {\n            let next = top.set.children[top.index], start = top.offset;\n            top.index++;\n            top.offset += next.length;\n            if (top.offset >= skipTo) {\n                stack.push(new IteratedSet(start, next));\n                break;\n            }\n        }\n    }\n}\n// Iterating over the actual ranges in a set (or multiple sets) is\n// done using a binary heap to efficiently get the ordering right. The\n// heap may contain both LocalSet instances (iterating over the ranges\n// in a set tree node) and actual Range objects. At any point, the one\n// with the lowest position (and side) is taken off next.\nfunction compareHeapable(a, b) {\n    return a.heapPos - b.heapPos || a.heapSide - b.heapSide;\n}\n// Advance the iteration over a range set (in `stack`) and add the\n// next node that has any local ranges to the heap as a `LocalSet`.\n// Links the stack to the `LocalSet` (in `.next`) if this node also\n// has child nodes, which will be used to schedule the next call to\n// `addIterToHeap` when the end of that `LocalSet` is reached.\nfunction addIterToHeap(heap, stack, skipTo = 0) {\n    for (;;) {\n        iterRangeSet(stack, skipTo);\n        if (stack.length == 0)\n            break;\n        let next = stack[stack.length - 1], local = next.set.local;\n        let leaf = next.set.children.length ? null : stack;\n        if (local.length)\n            addToHeap(heap, new LocalSet(next.offset, local, leaf));\n        if (leaf)\n            break;\n    }\n}\n// Classic binary heap implementation, using the conformance to\n// `Heapable` of the elements to compare them with `compareHeapable`,\n// keeping the element with the lowest position at its top.\nfunction addToHeap(heap, elt) {\n    let index = heap.push(elt) - 1;\n    while (index > 0) {\n        let parentIndex = index >> 1, parent = heap[parentIndex];\n        if (compareHeapable(elt, parent) >= 0)\n            break;\n        heap[index] = parent;\n        heap[parentIndex] = elt;\n        index = parentIndex;\n    }\n}\nfunction takeFromHeap(heap) {\n    let elt = heap[0], replacement = heap.pop();\n    if (heap.length == 0)\n        return elt;\n    heap[0] = replacement;\n    for (let index = 0;;) {\n        let childIndex = (index << 1) + 1;\n        if (childIndex >= heap.length)\n            break;\n        let child = heap[childIndex];\n        if (childIndex + 1 < heap.length && compareHeapable(child, heap[childIndex + 1]) >= 0) {\n            child = heap[childIndex + 1];\n            childIndex++;\n        }\n        if (compareHeapable(replacement, child) < 0)\n            break;\n        heap[childIndex] = replacement;\n        heap[index] = child;\n        index = childIndex;\n    }\n    return elt;\n}\nfunction byPos(a, b) {\n    return a.from - b.from || a.value.startSide - b.value.startSide;\n}\nfunction insertSorted(target, range) {\n    let i = target.length;\n    while (i > 0 && byPos(target[i - 1], range) >= 0)\n        i--;\n    target.splice(i, 0, range);\n}\nfunction filterRanges(ranges, filter, filterFrom, filterTo, offset) {\n    if (!filter)\n        return null;\n    let copy = null;\n    for (let i = 0; i < ranges.length; i++) {\n        let range = ranges[i], from = range.from + offset, to = range.to + offset;\n        if (filterFrom > to || filterTo < from || filter(from, to, range.value)) {\n            if (copy != null)\n                copy.push(range);\n        }\n        else {\n            if (copy == null)\n                copy = ranges.slice(0, i);\n        }\n    }\n    return copy;\n}\nfunction collapseSet(children, local, add, start, offset, length) {\n    let mustSort = local.length > 0 && add.length > 0, off = 0;\n    for (let child of children) {\n        child.collect(local, -off);\n        off += child.length;\n    }\n    for (let added of add)\n        local.push(added.move(-offset));\n    if (mustSort)\n        local.sort(byPos);\n    return new RangeSet(length, local.length, local, none);\n}\nfunction appendRanges(local, children, ranges, start, offset, length, pos, childSize) {\n    // Group added ranges after the current children into new\n    // children (will usually only happen when initially creating a\n    // node or adding stuff to the top-level node)\n    for (let i = start; i < ranges.length;) {\n        let add = [];\n        let end = Math.min(i + childSize, ranges.length);\n        let endPos = end == ranges.length ? offset + length : ranges[end].from;\n        for (; i < end; i++) {\n            let range = ranges[i];\n            if (range.to > endPos)\n                insertSorted(local, range.move(-offset));\n            else\n                add.push(range);\n        }\n        // Move locals that fit in this new child from `local` to `add`\n        for (let i = 0; i < local.length; i++) {\n            let range = local[i];\n            if (range.from >= pos && range.to <= endPos) {\n                local.splice(i--, 1);\n                insertSorted(add, range.move(offset));\n            }\n        }\n        if (add.length) {\n            if (add.length == ranges.length)\n                children.push(new RangeSet(endPos - pos, add.length, add.map(r => r.move(-pos)), none));\n            else\n                children.push(RangeSet.empty.updateInner(add, null, 0, 0, pos, endPos - pos));\n            pos = endPos;\n        }\n    }\n}\n// FIXME try to clean this up\nfunction rebalanceChildren(local, children, childSize) {\n    for (let i = 0, off = 0; i < children.length;) {\n        let child = children[i], next;\n        if (child.size == 0 && (i > 0 || children.length == 1)) {\n            // Drop empty node\n            children.splice(i--, 1);\n            if (i >= 0)\n                children[i] = children[i].grow(child.length);\n        }\n        else if (child.size > (childSize << 1) && child.local.length < (child.length >> 1)) {\n            // Unwrap an overly big node\n            for (let range of child.local)\n                insertSorted(local, range.move(off));\n            children.splice(i, 1, ...child.children);\n        }\n        else if (child.children.length == 0 && i < children.length - 1 &&\n            (next = children[i + 1]).size + child.size <= BASE_NODE_SIZE &&\n            next.children.length == 0) {\n            // Join two small leaf nodes\n            children.splice(i, 2, new RangeSet(child.length + next.length, child.size + next.size, child.local.concat(next.local.map(d => d.move(child.length))), none));\n        }\n        else {\n            // Join a number of nodes into a wrapper node\n            let joinTo = i + 1, size = child.size, length = child.length;\n            if (child.size < (childSize >> 1)) {\n                for (; joinTo < children.length; joinTo++) {\n                    let next = children[joinTo], totalSize = size + next.size;\n                    if (totalSize > childSize)\n                        break;\n                    size = totalSize;\n                    length += next.length;\n                }\n            }\n            if (joinTo > i + 1) {\n                let joined = new RangeSet(length, size, none, children.slice(i, joinTo));\n                let joinedLocals = [];\n                for (let j = 0; j < local.length; j++) {\n                    let range = local[j];\n                    if (range.from >= off && range.to <= off + length) {\n                        local.splice(j--, 1);\n                        joinedLocals.push(range.move(-off));\n                    }\n                }\n                if (joinedLocals.length)\n                    joined = joined.update(joinedLocals.sort(byPos));\n                children.splice(i, joinTo - i, joined);\n                i++;\n                off += length;\n            }\n            else {\n                i++;\n                off += child.length;\n            }\n        }\n    }\n}\nconst SIDE_A = 1, SIDE_B = 2, FAR = 1e9;\nclass ComparisonSide {\n    constructor(stack) {\n        this.stack = stack;\n        this.heap = [];\n        this.active = [];\n        this.activeTo = [];\n        this.tip = null;\n        // A currently active point range, if any\n        this.point = null;\n        // The end of the current point range\n        this.pointTo = -FAR;\n    }\n    forward(start, next) {\n        let newTip = false;\n        if (next.set.local.length) {\n            let local = new LocalSet(next.offset, next.set.local);\n            addToHeap(this.heap, local);\n            if (!next.set.children.length) {\n                this.tip = local;\n                newTip = true;\n            }\n        }\n        iterRangeSet(this.stack, start);\n        return newTip;\n    }\n    findActive(to, value) {\n        for (let i = 0; i < this.active.length; i++)\n            if (this.activeTo[i] == to && (this.active[i] == value || this.active[i].eq(value)))\n                return i;\n        return -1;\n    }\n    clearPoint() {\n        this.pointTo = -FAR;\n        this.point = null;\n    }\n    get nextPos() {\n        return this.pointTo > -FAR ? this.pointTo : this.heap.length ? this.heap[0].heapPos : FAR;\n    }\n    get nextSide() {\n        return this.pointTo > -FAR ? this.point.endSide : this.heap.length ? this.heap[0].heapSide : FAR;\n    }\n}\n// Manage the synchronous iteration over a part of two range sets,\n// skipping identical nodes and ranges and calling callbacks on a\n// comparator object when differences are found.\nclass RangeSetComparison {\n    constructor(a, startA, b, startB, endB, comparator) {\n        this.comparator = comparator;\n        this.a = new ComparisonSide([new IteratedSet(startB - startA, a)]);\n        this.b = new ComparisonSide([new IteratedSet(0, b)]);\n        this.pos = startB;\n        this.end = endB;\n        this.forwardIter(SIDE_A | SIDE_B);\n    }\n    // Move the iteration over the tree structure forward until all of\n    // the sides included in `side` (bitmask of `SIDE_A` and/or\n    // `SIDE_B`) have added new nodes to their heap, or there is nothing\n    // further to iterate over. This is basically used to ensure the\n    // heaps are stocked with nodes from the stacks that track the\n    // iteration.\n    forwardIter(side) {\n        for (; side > 0;) {\n            let nextA = this.a.stack.length ? this.a.stack[this.a.stack.length - 1] : null;\n            let nextB = this.b.stack.length ? this.b.stack[this.b.stack.length - 1] : null;\n            if (!nextA && (side & SIDE_A)) {\n                // If there's no next node for A, we're done there\n                side &= ~SIDE_A;\n            }\n            else if (!nextB && (side & SIDE_B)) {\n                // No next node for B\n                side &= ~SIDE_B;\n            }\n            else if (nextA && nextB && nextA.offset == nextB.offset && nextA.set == nextB.set) {\n                // Both next nodes are the sameâ€”skip them\n                iterRangeSet(this.a.stack, this.pos);\n                iterRangeSet(this.b.stack, this.pos);\n            }\n            else if (nextA && (!nextB || (nextA.offset < nextB.offset ||\n                nextA.offset == nextB.offset && (this.a.stack.length == 1 ||\n                    nextA.set.length >= nextB.set.length)))) {\n                // If there no next B, or it comes after the next A, or it\n                // sits at the same position and is smaller, move A forward.\n                if (this.a.forward(this.pos, nextA))\n                    side &= ~SIDE_A;\n            }\n            else {\n                // Otherwise move B forward\n                if (this.b.forward(this.pos, nextB))\n                    side &= ~SIDE_B;\n            }\n        }\n    }\n    // Driver of the comparison process. On each iteration, call\n    // `advance` with the side whose next event (start of end of a\n    // range) comes first, until we run out of events.\n    run() {\n        for (;;) {\n            let nextA = this.a.nextPos, nextB = this.b.nextPos;\n            if (nextA == FAR && nextB == FAR)\n                break;\n            let diff = nextA - nextB || this.a.nextSide - this.a.nextSide;\n            if (diff < 0)\n                this.advance(this.a, this.b);\n            else\n                this.advance(this.b, this.a);\n        }\n    }\n    advance(side, other) {\n        if (side.pointTo > -1) {\n            // The next thing that's happening is the end of this.point\n            let end = Math.min(this.end, side.pointTo);\n            if (!other.point || !side.point.eq(other.point))\n                this.comparator.comparePoint(this.pos, end, side.point, other.point);\n            this.pos = end;\n            if (end == this.end ||\n                other.pointTo == end && other.point.endSide == side.point.endSide)\n                other.clearPoint();\n            side.clearPoint();\n            return;\n        }\n        let next = takeFromHeap(side.heap);\n        if (next instanceof LocalSet) {\n            // If this is a local set, we're seeing a new range being\n            // opened.\n            let range = next.ranges[next.index++];\n            // The actual positions are offset relative to the node\n            let from = range.from + next.offset, to = range.to + next.offset;\n            if (from > this.end) {\n                // If we found a range past the end, we're done\n                side.heap.length = 0;\n                return;\n            }\n            else if (next.index < next.ranges.length) {\n                // If there's more ranges in this node, re-add it to the heap\n                addToHeap(side.heap, next);\n            }\n            else {\n                // Otherwise, move the iterator forward (making sure this side is advanced)\n                this.forwardIter(side == this.a ? SIDE_A : SIDE_B);\n            }\n            // Ignore ranges that fall entirely in a point on the other side\n            // or were skipped by a point on this side\n            // FIXME should maybe also drop ranges when to == this.pos but their side < the point's side?\n            if (to < this.pos || to < other.pointTo || to == other.pointTo && range.value.startSide < other.point.endSide)\n                return;\n            // Otherwise, if the other side isn't a point, advance\n            if (other.pointTo < 0)\n                this.advancePos(from);\n            if (range.value.point) {\n                side.point = range.value;\n                side.pointTo = to;\n            }\n            else {\n                to = Math.min(to, this.end);\n                // Add this to the set of active ranges\n                let found = other.findActive(to, range.value);\n                if (found > -1) {\n                    remove(other.active, found);\n                    remove(other.activeTo, found);\n                }\n                else {\n                    side.active.push(range.value);\n                    side.activeTo.push(to);\n                    addToHeap(side.heap, new Range(this.pos, to, range.value));\n                }\n            }\n        }\n        else {\n            // This is the end of a range, remove it from the active set if it's in there.\n            let range = next;\n            if (other.pointTo < 0)\n                this.advancePos(range.to);\n            let found = side.findActive(range.to, range.value);\n            if (found > -1) {\n                remove(side.active, found);\n                remove(side.activeTo, found);\n            }\n        }\n    }\n    advancePos(pos) {\n        if (pos > this.end)\n            pos = this.end;\n        if (pos <= this.pos)\n            return;\n        if (!sameSet(this.a.active, this.b.active))\n            this.comparator.compareRange(this.pos, pos, this.a.active, this.b.active);\n        this.pos = pos;\n    }\n}\nfunction sameSet(a, b) {\n    if (a.length != b.length)\n        return false;\n    outer: for (let i = 0; i < a.length; i++) {\n        for (let j = 0; j < b.length; j++)\n            if (a[i].eq(b[j]))\n                continue outer;\n        return false;\n    }\n    return true;\n}\nfunction remove(array, index) {\n    let last = array.pop();\n    if (index != array.length)\n        array[index] = last;\n}\nfunction touchesChanges(from, to, changes) {\n    let result = 1 /* No */;\n    for (let change of changes) {\n        if (change.to >= from && change.from <= to) {\n            if (change.from < from && change.to > to)\n                result = 2 /* Covered */;\n            else if (result == 1 /* No */)\n                result = 0 /* Yes */;\n        }\n        let diff = change.length - (change.to - change.from);\n        if (from > change.from)\n            from += diff;\n        if (to > change.to)\n            to += diff;\n    }\n    return result;\n}\n\n\n\n\n//# sourceURL=webpack:///./node_modules/@codemirror/next/rangeset/dist/index.es.js?");

/***/ }),

/***/ "./node_modules/@codemirror/next/state/dist/index.es.js":
/*!**************************************************************!*\
  !*** ./node_modules/@codemirror/next/state/dist/index.es.js ***!
  \**************************************************************/
/*! exports provided: Text, Annotation, Change, ChangeDesc, ChangeSet, ChangedRange, EditorSelection, EditorState, MapMode, SelectionRange, StateField, Transaction, languageData */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Annotation\", function() { return Annotation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Change\", function() { return Change; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ChangeDesc\", function() { return ChangeDesc; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ChangeSet\", function() { return ChangeSet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ChangedRange\", function() { return ChangedRange; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EditorSelection\", function() { return EditorSelection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EditorState\", function() { return EditorState; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MapMode\", function() { return MapMode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SelectionRange\", function() { return SelectionRange; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StateField\", function() { return StateField; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Transaction\", function() { return Transaction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"languageData\", function() { return languageData; });\n/* harmony import */ var _text__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../text */ \"./node_modules/@codemirror/next/text/dist/index.es.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Text\", function() { return _text__WEBPACK_IMPORTED_MODULE_0__[\"Text\"]; });\n\n/* harmony import */ var _extension__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../extension */ \"./node_modules/@codemirror/next/extension/dist/index.es.js\");\n/* harmony import */ var lezer_tree__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lezer-tree */ \"./node_modules/lezer-tree/dist/tree.js\");\n/* harmony import */ var lezer_tree__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lezer_tree__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\n\n/// A single selection range. When\n/// [`allowMultipleSelections`](#state.EditorState^allowMultipleSelections)\n/// is enabled, a [selection](#state.EditorSelection) may hold\n/// multiple ranges. By default, selections hold exactly one range.\nclass SelectionRange {\n    /// Create a range. `head` defaults to `anchor` when not given.\n    constructor(\n    /// The anchor of the rangeâ€”the side that doesn't move when you\n    /// extend it.\n    anchor, \n    /// The head of the range, which is moved when the range is\n    /// [extended](#state.SelectionRange.extend).\n    head = anchor) {\n        this.anchor = anchor;\n        this.head = head;\n    }\n    /// The lower side of the range.\n    get from() { return Math.min(this.anchor, this.head); }\n    /// The upper side of the range.\n    get to() { return Math.max(this.anchor, this.head); }\n    /// True when `anchor` and `head` are at the same position.\n    get empty() { return this.anchor == this.head; }\n    /// Map this range through a mapping.\n    map(mapping) {\n        let anchor = mapping.mapPos(this.anchor), head = mapping.mapPos(this.head);\n        if (anchor == this.anchor && head == this.head)\n            return this;\n        else\n            return new SelectionRange(anchor, head);\n    }\n    /// Extend this range to cover at least `from` to `to`.\n    extend(from, to = from) {\n        if (from <= this.anchor && to >= this.anchor)\n            return new SelectionRange(from, to);\n        let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;\n        return new SelectionRange(this.anchor, head);\n    }\n    /// Compare this range to another range.\n    eq(other) {\n        return this.anchor == other.anchor && this.head == other.head;\n    }\n    /// Return a JSON-serializable object representing the range.\n    toJSON() { return this; }\n    /// Convert a JSON representation of a range to a `SelectionRange`\n    /// instance.\n    static fromJSON(json) {\n        if (!json || typeof json.anchor != \"number\" || typeof json.head != \"number\")\n            throw new RangeError(\"Invalid JSON representation for SelectionRange\");\n        return new SelectionRange(json.anchor, json.head);\n    }\n    /// @internal FIXME export?\n    static groupAt(state, pos, bias = 1) {\n        // FIXME at some point, take language-specific identifier characters into account\n        let line = state.doc.lineAt(pos), linePos = pos - line.start;\n        if (line.length == 0)\n            return new SelectionRange(pos);\n        if (linePos == 0)\n            bias = 1;\n        else if (linePos == line.length)\n            bias = -1;\n        let read = linePos + (bias < 0 ? -1 : 0), type = Object(_text__WEBPACK_IMPORTED_MODULE_0__[\"charType\"])(line.slice(read, read + 1));\n        let from = pos, to = pos;\n        for (let lineFrom = linePos; lineFrom > 0 && Object(_text__WEBPACK_IMPORTED_MODULE_0__[\"charType\"])(line.slice(lineFrom - 1, lineFrom)) == type; lineFrom--)\n            from--;\n        for (let lineTo = linePos; lineTo < line.length && Object(_text__WEBPACK_IMPORTED_MODULE_0__[\"charType\"])(line.slice(lineTo, lineTo + 1)) == type; lineTo++)\n            to++;\n        return new SelectionRange(to, from);\n    }\n}\n/// An editor selection holds one or more selection ranges.\nclass EditorSelection {\n    /// @internal\n    constructor(\n    /// The ranges in the selection, sorted by position. Ranges cannot\n    /// overlap (but they may touch, if they aren't empty).\n    ranges, \n    /// The index of the _primary_ range in the selection (which is\n    /// usually the range that was added last).\n    primaryIndex = 0) {\n        this.ranges = ranges;\n        this.primaryIndex = primaryIndex;\n    }\n    /// Map a selection through a mapping. Mostly used to adjust the\n    /// selection position for changes.\n    map(mapping) {\n        return EditorSelection.create(this.ranges.map(r => r.map(mapping)), this.primaryIndex);\n    }\n    /// Compare this selection to another selection.\n    eq(other) {\n        if (this.ranges.length != other.ranges.length ||\n            this.primaryIndex != other.primaryIndex)\n            return false;\n        for (let i = 0; i < this.ranges.length; i++)\n            if (!this.ranges[i].eq(other.ranges[i]))\n                return false;\n        return true;\n    }\n    /// Get the primary selection range. Usually, you should make sure\n    /// your code applies to _all_ ranges, by using transaction methods\n    /// like [`forEachRange`](#state.transaction.forEachRange).\n    get primary() { return this.ranges[this.primaryIndex]; }\n    /// Make sure the selection only has one range. Returns a selection\n    /// holding only the primary range from this selection.\n    asSingle() {\n        return this.ranges.length == 1 ? this : new EditorSelection([this.primary]);\n    }\n    /// Extend this selection with an extra range.\n    addRange(range, primary = true) {\n        return EditorSelection.create([range].concat(this.ranges), primary ? 0 : this.primaryIndex + 1);\n    }\n    /// Replace a given range with another range, and then normalize the\n    /// selection to merge and sort ranges if necessary.\n    replaceRange(range, which = this.primaryIndex) {\n        let ranges = this.ranges.slice();\n        ranges[which] = range;\n        return EditorSelection.create(ranges, this.primaryIndex);\n    }\n    /// Convert this selection to an object that can be serialized to\n    /// JSON.\n    toJSON() {\n        return this.ranges.length == 1 ? this.ranges[0].toJSON() :\n            { ranges: this.ranges.map(r => r.toJSON()), primaryIndex: this.primaryIndex };\n    }\n    /// Create a selection from a JSON representation.\n    static fromJSON(json) {\n        if (json && Array.isArray(json.ranges)) {\n            if (typeof json.primaryIndex != \"number\" || json.primaryIndex >= json.ranges.length)\n                throw new RangeError(\"Invalid JSON representation for EditorSelection\");\n            return new EditorSelection(json.ranges.map((r) => SelectionRange.fromJSON(r)), json.primaryIndex);\n        }\n        return new EditorSelection([SelectionRange.fromJSON(json)]);\n    }\n    /// Create a selection holding a single range.\n    static single(anchor, head = anchor) {\n        return new EditorSelection([new SelectionRange(anchor, head)], 0);\n    }\n    /// Sort and merge the given set of ranges, creating a valid\n    /// selection.\n    static create(ranges, primaryIndex = 0) {\n        for (let pos = 0, i = 0; i < ranges.length; i++) {\n            let range = ranges[i];\n            if (range.empty ? range.from <= pos : range.from < pos)\n                return normalized(ranges.slice(), primaryIndex);\n            pos = range.to;\n        }\n        return new EditorSelection(ranges, primaryIndex);\n    }\n}\nfunction normalized(ranges, primaryIndex = 0) {\n    let primary = ranges[primaryIndex];\n    ranges.sort((a, b) => a.from - b.from);\n    primaryIndex = ranges.indexOf(primary);\n    for (let i = 1; i < ranges.length; i++) {\n        let range = ranges[i], prev = ranges[i - 1];\n        if (range.empty ? range.from <= prev.to : range.from < prev.to) {\n            let from = prev.from, to = Math.max(range.to, prev.to);\n            if (i <= primaryIndex)\n                primaryIndex--;\n            ranges.splice(--i, 2, range.anchor > range.head ? new SelectionRange(to, from) : new SelectionRange(from, to));\n        }\n    }\n    return new EditorSelection(ranges, primaryIndex);\n}\n\nconst extendState = new _extension__WEBPACK_IMPORTED_MODULE_1__[\"ExtensionGroup\"](state => state.values);\nconst stateField = extendState.behavior({ static: true });\nconst allowMultipleSelections = extendState.behavior({\n    combine: values => values.some(v => v),\n    static: true\n});\n/// Fields can store additional information in an editor state, and\n/// keep it in sync with the rest of the state.\nclass StateField {\n    /// Declare a field. The field instance is used as the\n    /// [key](#state.EditorState.field) when retrieving the field's\n    /// value from a state.\n    constructor(spec) {\n        /// @internal\n        this.id = extendState.storageID();\n        this.init = spec.init;\n        this.apply = spec.apply;\n        this.extension = stateField(this);\n    }\n}\n/// Annotations are tagged values that are used to add metadata to\n/// transactions in an extensible way.\nclass Annotation {\n    /// @internal\n    constructor(/** @internal */ type, \n    /** @internal */ value) {\n        this.type = type;\n        this.value = value;\n    }\n    /// Define a new type of annotation. Returns a function that you can\n    /// call with a content value to create an instance of this type.\n    static define() {\n        return function type(value) { return new Annotation(type, value); };\n    }\n}\n/// A node prop that can be stored on a grammar's top node to\n/// associate information with the language. Different extension might\n/// use different properties from this object (which they typically\n/// export as an interface).\nconst languageData = new lezer_tree__WEBPACK_IMPORTED_MODULE_2__[\"NodeProp\"]();\n\nconst empty = [];\n/// Distinguishes different ways in which positions can be mapped.\nvar MapMode;\n(function (MapMode) {\n    /// Map a position to a valid new position, even when its context\n    /// was deleted.\n    MapMode[MapMode[\"Simple\"] = 0] = \"Simple\";\n    /// Return a negative number if a deletion happens across the\n    /// position. This number will be `-(newPos + 1)`, where `newPos` is\n    /// the result you'd get with `MapMode.Simple`.\n    MapMode[MapMode[\"TrackDel\"] = 1] = \"TrackDel\";\n    /// Return a negative number if the character _before_ the position\n    /// is deleted. The result is encoded the same way as with\n    /// `MapMode.TrackDel`.\n    MapMode[MapMode[\"TrackBefore\"] = 2] = \"TrackBefore\";\n    /// Return a negative number if the character _after_ the position is\n    /// deleted.\n    MapMode[MapMode[\"TrackAfter\"] = 3] = \"TrackAfter\";\n})(MapMode || (MapMode = {}));\n/// A change description describes a document change. This is usually\n/// used as a superclass of [`Change`](#state.Change), but can be used\n/// to store change data without storing the replacement string\n/// content.\nclass ChangeDesc {\n    /// Create a description that replaces the text between positions\n    /// `from` and `to` with a new string of length `length`.\n    constructor(\n    /// The start position of the change.\n    from, \n    /// The end of the change (as a pre-change document position).\n    to, \n    /// The length of the replacing content.\n    length) {\n        this.from = from;\n        this.to = to;\n        this.length = length;\n    }\n    /// Get the change description of the inverse of this change.\n    get invertedDesc() { return new ChangeDesc(this.from, this.from + this.length, this.to - this.from); }\n    /// @internal\n    mapPos(pos, bias = -1, mode = MapMode.Simple) {\n        let { from, to, length } = this;\n        if (pos < from)\n            return pos;\n        if (pos > to)\n            return pos + (length - (to - from));\n        if (pos == to || pos == from) {\n            if (from < pos && mode == MapMode.TrackBefore || to > pos && mode == MapMode.TrackAfter)\n                return -pos - 1;\n            return (from == to ? bias <= 0 : pos == from) ? from : from + length;\n        }\n        pos = from + (bias <= 0 ? 0 : length);\n        return mode != MapMode.Simple ? -pos - 1 : pos;\n    }\n    /// Return a JSON-serializeable object representing this value.\n    toJSON() { return this; }\n    /// Create a change description from its JSON representation.\n    static fromJSON(json) {\n        if (!json || typeof json.from != \"number\" || typeof json.to != \"number\" || typeof json.length != \"number\")\n            throw new RangeError(\"Invalid JSON representation for ChangeDesc\");\n        return new ChangeDesc(json.from, json.to, json.length);\n    }\n}\n/// Change objects describe changes to the document.\nclass Change extends ChangeDesc {\n    /// Create a change that replaces `from` to `to` with `text`. The\n    /// text is given as an array of lines. When it doesn't span lines,\n    /// the array has a single element. When it does, a new element is\n    /// added for every line. It should never have zero elements.\n    constructor(from, to, \n    /// The replacement content.\n    text) {\n        super(from, to, textLength(text));\n        this.from = from;\n        this.to = to;\n        this.text = text;\n    }\n    /// Create the inverse of this change when applied to the given\n    /// document. `change.invert(doc).apply(change.apply(doc))` gets you\n    /// the same document as the original `doc`.\n    invert(doc) {\n        return new Change(this.from, this.from + this.length, doc.sliceLines(this.from, this.to));\n    }\n    /// Apply this change to the given content, returning an updated\n    /// version of the document.\n    apply(doc) {\n        return doc.replace(this.from, this.to, this.text);\n    }\n    /// Map this change through a mapping, producing a new change that\n    /// can be applied to a post-mapping document. May return null if\n    /// the mapping completely replaces the region this change would\n    /// apply to.\n    map(mapping) {\n        let from = mapping.mapPos(this.from, 1), to = mapping.mapPos(this.to, -1);\n        return from > to ? null : new Change(from, to, this.text);\n    }\n    /// A change description for this change.\n    get desc() { return new ChangeDesc(this.from, this.to, this.length); }\n    /// Produce a JSON-serializable object representing this change.\n    toJSON() {\n        return { from: this.from, to: this.to, text: this.text };\n    }\n    /// Read a change instance from its JSON representation.\n    static fromJSON(json) {\n        if (!json || typeof json.from != \"number\" || typeof json.to != \"number\" ||\n            !Array.isArray(json.text) || json.text.length == 0 || json.text.some((val) => typeof val != \"string\"))\n            throw new RangeError(\"Invalid JSON representation for Change\");\n        return new Change(json.from, json.to, json.text);\n    }\n}\nfunction textLength(text) {\n    let length = -1;\n    for (let line of text)\n        length += line.length + 1;\n    return length;\n}\n/// A change set holds a sequence of changes or change descriptions.\nclass ChangeSet {\n    /// @internal\n    constructor(\n    /// The changes in this set.\n    changes, \n    /// @internal\n    mirror = empty) {\n        this.changes = changes;\n        this.mirror = mirror;\n    }\n    /// The number of changes in the set.\n    get length() {\n        return this.changes.length;\n    }\n    /// Change sets can track which changes are inverses of each other,\n    /// to allow robust position mapping in situations where changes are\n    /// undone and then redone again. This queries which change is the\n    /// mirror image of a given change (by index).\n    getMirror(n) {\n        for (let i = 0; i < this.mirror.length; i++)\n            if (this.mirror[i] == n)\n                return this.mirror[i + (i % 2 ? -1 : 1)];\n        return null;\n    }\n    /// Append a change to this set, returning an extended set. `mirror`\n    /// may be the index of a change already in the set, which\n    /// [mirrors](#state.ChangeSet.getMirror) the new change.\n    append(change, mirror) {\n        return new ChangeSet(this.changes.concat(change), mirror != null ? this.mirror.concat(this.length, mirror) : this.mirror);\n    }\n    /// Append another change set to this one.\n    appendSet(changes) {\n        return changes.length == 0 ? this :\n            this.length == 0 ? changes :\n                new ChangeSet(this.changes.concat(changes.changes), this.mirror.concat(changes.mirror.map(i => i + this.length)));\n    }\n    /// @internal\n    mapPos(pos, bias = -1, mode = MapMode.Simple) {\n        return this.mapInner(pos, bias, mode, 0, this.length);\n    }\n    /// @internal\n    mapInner(pos, bias, mode, fromI, toI) {\n        let dir = toI < fromI ? -1 : 1;\n        let recoverables = null;\n        let hasMirrors = this.mirror.length > 0, rec, mirror, deleted = false;\n        for (let i = fromI - (dir < 0 ? 1 : 0), endI = toI - (dir < 0 ? 1 : 0); i != endI; i += dir) {\n            let { from, to, length } = this.changes[i];\n            if (dir < 0) {\n                let len = to - from;\n                to = from + length;\n                length = len;\n            }\n            if (pos < from)\n                continue;\n            if (pos > to) {\n                pos += length - (to - from);\n                continue;\n            }\n            // Change touches this position\n            if (recoverables && (rec = recoverables[i]) != null) { // There's a recovery for this change, and it applies\n                pos = from + rec;\n                continue;\n            }\n            if (hasMirrors && (mirror = this.getMirror(i)) != null &&\n                (dir > 0 ? mirror > i && mirror < toI : mirror < i && mirror >= toI)) { // A mirror exists\n                if (pos > from && pos < to) { // If this change deletes the position, skip forward to the mirror\n                    i = mirror;\n                    pos = this.changes[i].from + (pos - from);\n                    continue;\n                }\n                (recoverables || (recoverables = {}))[mirror] = pos - from;\n            }\n            if (pos > from && pos < to) {\n                if (mode != MapMode.Simple)\n                    deleted = true;\n                pos = bias <= 0 ? from : from + length;\n            }\n            else {\n                if (from < pos && mode == MapMode.TrackBefore || to > pos && mode == MapMode.TrackAfter)\n                    deleted = true;\n                pos = (from == to ? bias <= 0 : pos == from) ? from : from + length;\n            }\n        }\n        return deleted ? -pos - 1 : pos;\n    }\n    /// Get a partial [mapping](#state.Mapping) covering part of this\n    /// change set.\n    partialMapping(from, to = this.length) {\n        if (from == 0 && to == this.length)\n            return this;\n        return new PartialMapping(this, from, to);\n    }\n    /// Summarize this set of changes as a minimal sequence of changed\n    /// ranges, sored by position. For example, if you have changes\n    /// deleting between 1 and 4 and inserting a character at 1, the\n    /// result would be a single range saying 1 to 4 in the old doc was\n    /// replaced with range 1 to 2 in the new doc.\n    changedRanges() {\n        // FIXME cache this?\n        let set = [];\n        for (let i = 0; i < this.length; i++) {\n            let change = this.changes[i];\n            let fromA = change.from, toA = change.to, fromB = change.from, toB = change.from + change.length;\n            if (i < this.length - 1) {\n                let mapping = this.partialMapping(i + 1);\n                fromB = mapping.mapPos(fromB, 1);\n                toB = mapping.mapPos(toB, -1);\n            }\n            if (i > 0) {\n                let mapping = this.partialMapping(i, 0);\n                fromA = mapping.mapPos(fromA, 1);\n                toA = mapping.mapPos(toA, -1);\n            }\n            new ChangedRange(fromA, toA, fromB, toB).addToSet(set);\n        }\n        return set;\n    }\n    /// Convert a set of changes to a set of change descriptions.\n    get desc() {\n        if (this.changes.length == 0 || this.changes[0] instanceof ChangeDesc)\n            return this;\n        return new ChangeSet(this.changes.map(ch => ch.desc), this.mirror);\n    }\n    /// Create a JSON-serializable representation of this change set.\n    toJSON() {\n        let changes = this.changes.map(change => change.toJSON());\n        return this.mirror.length == 0 ? changes : { mirror: this.mirror, changes };\n    }\n    /// Read a change set from its JSON representation.\n    static fromJSON(ChangeType, json) {\n        let mirror, changes;\n        if (Array.isArray(json)) {\n            mirror = empty;\n            changes = json;\n        }\n        else if (!json || !Array.isArray(json.mirror) || !Array.isArray(json.changes)) {\n            throw new RangeError(\"Invalid JSON representation for ChangeSet\");\n        }\n        else {\n            ({ mirror, changes } = json);\n        }\n        return new ChangeSet(changes.map((ch) => ChangeType.fromJSON(ch)), mirror);\n    }\n}\n/// The empty change set.\nChangeSet.empty = new ChangeSet(empty);\nclass PartialMapping {\n    constructor(changes, from, to) {\n        this.changes = changes;\n        this.from = from;\n        this.to = to;\n    }\n    mapPos(pos, bias = -1, mode = MapMode.Simple) {\n        return this.changes.mapInner(pos, bias, mode, this.from, this.to);\n    }\n}\n/// A changed range represents a replacement as two absolute ranges,\n/// one pointing into the old document (the replaced content) and one\n/// pointing into the new document (the content that replaces it).\nclass ChangedRange {\n    // FIXME store unchanged ranges instead?\n    constructor(\n    /// The start of the replaced range in the old document.\n    fromA, \n    /// The end of the replaced range in the old document.\n    toA, \n    /// The start of the replacing range in the new document.\n    fromB, \n    /// The end of the replacing range in the new document.\n    toB) {\n        this.fromA = fromA;\n        this.toA = toA;\n        this.fromB = fromB;\n        this.toB = toB;\n    }\n    /// @internal\n    join(other) {\n        return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));\n    }\n    /// @internal\n    // FIXME used by view. Document?\n    addToSet(set) {\n        let i = set.length, me = this;\n        for (; i > 0; i--) {\n            let range = set[i - 1];\n            if (range.fromA > me.toA)\n                continue;\n            if (range.toA < me.fromA)\n                break;\n            me = me.join(range);\n            set.splice(i - 1, 1);\n        }\n        set.splice(i, 0, me);\n        return set;\n    }\n    /// The difference in document length created by this change\n    /// (positive when the document grew).\n    get lenDiff() { return (this.toB - this.fromB) - (this.toA - this.fromA); }\n    /// @internal\n    static mapPos(pos, bias, changes) {\n        let off = 0;\n        for (let range of changes) {\n            if (pos < range.fromA)\n                break;\n            if (pos <= range.toA) {\n                let side = range.toA == range.fromA ? bias : pos == range.fromA ? -1 : pos == range.toA ? 1 : bias;\n                return side < 0 ? range.fromB : range.toB;\n            }\n            off = range.toB - range.toA;\n        }\n        return pos + off;\n    }\n}\n\n/// Changes to the editor state are grouped into transactions.\n/// Usually, a user action creates a single transaction, which may\n/// contain zero or more document changes. Create a transaction by\n/// calling [`EditorState.t`](#state.EditorState.t).\n///\n/// Transactions are mutable, and usually built up piece by piece with\n/// updating methods and method chaining (most methods return the\n/// transaction itself). Once they are\n/// [applied](#state.Transaction.apply), they can't be updated\n/// anymore.\nclass Transaction {\n    /// @internal\n    constructor(\n    /// The state from which the transaction starts.\n    startState, time = Date.now()) {\n        this.startState = startState;\n        /// The document changes made by this transaction.\n        this.changes = ChangeSet.empty;\n        /// The document versions after each of the changes.\n        this.docs = [];\n        this.flags = 0;\n        this.state = null;\n        this.selection = startState.selection;\n        this._annotations = [Transaction.time(time)];\n        this.configuration = startState.configuration;\n    }\n    /// The document at the end of the transaction.\n    get doc() {\n        let last = this.docs.length - 1;\n        return last < 0 ? this.startState.doc : this.docs[last];\n    }\n    /// Add annotations to this transaction. Annotations can provide\n    /// additional information about the transaction.\n    annotate(...annotations) {\n        this.ensureOpen();\n        for (let ann of annotations)\n            this._annotations.push(ann);\n        return this;\n    }\n    /// Get the value of the given annotation type, if any.\n    annotation(type) {\n        for (let i = this._annotations.length - 1; i >= 0; i--)\n            if (this._annotations[i].type == type)\n                return this._annotations[i].value;\n        return undefined;\n    }\n    /// Get all values associated with the given annotation in this\n    /// transaction.\n    annotations(type) {\n        let found = none;\n        for (let ann of this._annotations) {\n            if (ann.type == type) {\n                if (found == none)\n                    found = [];\n                found.push(ann.value);\n            }\n        }\n        return found;\n    }\n    /// Add a change to this transaction. If `mirror` is given, it\n    /// should be the index (in `this.changes.changes`) at which the\n    /// mirror image of this change sits.\n    change(change, mirror) {\n        this.ensureOpen();\n        if (change.from == change.to && change.length == 0)\n            return this;\n        if (change.from < 0 || change.to < change.from || change.to > this.doc.length)\n            throw new RangeError(`Invalid change ${change.from} to ${change.to}`);\n        this.changes = this.changes.append(change, mirror);\n        this.docs.push(change.apply(this.doc));\n        this.selection = this.selection.map(change);\n        return this;\n    }\n    /// Indicates whether the transaction changed the document.\n    get docChanged() {\n        return this.changes.length > 0;\n    }\n    /// Add a change replacing the given document range with the given\n    /// content.\n    replace(from, to, text) {\n        return this.change(new Change(from, to, typeof text == \"string\" ? this.startState.splitLines(text) : text));\n    }\n    /// Replace all selection ranges with the given content.\n    replaceSelection(text) {\n        let content = typeof text == \"string\" ? this.startState.splitLines(text) : text;\n        return this.forEachRange(range => {\n            let change = new Change(range.from, range.to, content);\n            this.change(change);\n            return new SelectionRange(range.from + change.length);\n        });\n    }\n    /// Run the given function for each selection range. The method will\n    /// map the ranges to reflect deletions/insertions that happen\n    /// before them. At the end, set the new selection to the ranges\n    /// returned by the function (again, automatically mapped to for\n    /// changes that happened after them).\n    forEachRange(f) {\n        let sel = this.selection, start = this.changes.length, newRanges = [];\n        for (let range of sel.ranges) {\n            let before = this.changes.length;\n            let result = f(range.map(this.changes.partialMapping(start)), this);\n            if (this.changes.length > before) {\n                let mapping = this.changes.partialMapping(before);\n                for (let i = 0; i < newRanges.length; i++)\n                    newRanges[i] = newRanges[i].map(mapping);\n            }\n            newRanges.push(result);\n        }\n        return this.setSelection(EditorSelection.create(newRanges, sel.primaryIndex));\n    }\n    /// Update the selection.\n    setSelection(selection) {\n        this.ensureOpen();\n        this.selection = this.startState.behavior(allowMultipleSelections) ? selection : selection.asSingle();\n        this.flags |= 1 /* SelectionSet */;\n        return this;\n    }\n    /// Tells you whether this transaction explicitly sets a new\n    /// selection (as opposed to just mapping the selection through\n    /// changes).\n    get selectionSet() {\n        return (this.flags & 1 /* SelectionSet */) > 0;\n    }\n    /// Set a flag on this transaction that indicates that the editor\n    /// should scroll the selection into view after applying it.\n    scrollIntoView() {\n        this.ensureOpen();\n        this.flags |= 2 /* ScrollIntoView */;\n        return this;\n    }\n    /// Query whether the selection should be scrolled into view after\n    /// applying this transaction.\n    get scrolledIntoView() {\n        return (this.flags & 2 /* ScrollIntoView */) > 0;\n    }\n    /// Replace one or more [named\n    /// extensions](#extension.ExtensionGroup.defineName) with new\n    /// instances, creating a new configuration for the new state.\n    replaceExtensions(replace) {\n        this.ensureOpen();\n        this.configuration = this.configuration.replaceExtensions(replace);\n        this.flags |= 4 /* Reconfigure */;\n        return this;\n    }\n    /// Move to an entirely new state configuration.\n    reconfigure(extensions) {\n        this.ensureOpen();\n        this.configuration = extendState.resolve(extensions);\n        this.flags |= 4 /* Reconfigure */;\n        return this;\n    }\n    /// Indicates whether the transaction reconfigures the state.\n    get reconfigured() {\n        return (this.flags & 4 /* Reconfigure */) > 0;\n    }\n    ensureOpen() {\n        if (this.state)\n            throw new Error(\"Transactions may not be modified after being applied\");\n    }\n    /// Apply this transaction, computing a new editor state. May be\n    /// called multiple times (the result is cached). The transaction\n    /// cannot be further modified after this has been called.\n    apply() {\n        return this.state || (this.state = this.startState.applyTransaction(this));\n    }\n    /// Create a set of changes that undo the changes made by this\n    /// transaction.\n    invertedChanges() {\n        if (!this.changes.length)\n            return ChangeSet.empty;\n        let changes = [], set = this.changes;\n        for (let i = set.length - 1; i >= 0; i--)\n            changes.push(set.changes[i].invert(i == 0 ? this.startState.doc : this.docs[i - 1]));\n        return new ChangeSet(changes, set.mirror.length ? set.mirror.map(i => set.length - i - 1) : set.mirror);\n    }\n}\n/// Annotation used to store transaction timestamps.\nTransaction.time = Annotation.define();\n/// Annotation used to indicate that this transaction shouldn't\n/// clear the goal column, which is used during vertical cursor\n/// motion (so that moving over short lines doesn't reset the\n/// horizontal position to the end of the shortest line). Should\n/// generally only be set by commands that perform vertical motion.\nTransaction.preserveGoalColumn = Annotation.define();\n/// Annotation used to associate a transaction with a user interface\n/// event. The view will set this to...\n///\n///  - `\"paste\"` when pasting content\n///  - `\"cut\"` when cutting\n///  - `\"drop\"` when content is inserted via drag-and-drop\n///  - `\"keyboard\"` when moving the selection via the keyboard\n///  - `\"pointer\"` when moving the selection through the pointing device\nTransaction.userEvent = Annotation.define();\n/// Annotation indicating whether a transaction should be added to\n/// the undo history or not.\nTransaction.addToHistory = Annotation.define();\nconst none = [];\n\nconst DEFAULT_INDENT_UNIT = 2, DEFAULT_TABSIZE = 4, DEFAULT_SPLIT = /\\r\\n?|\\n/;\n/// The editor state class is a persistent (immutable) data structure.\n/// To update a state, you [create](#state.EditorState.t) and\n/// [apply](#state.Transaction.apply) a\n/// [transaction](#state.Transaction), which produces a _new_ state\n/// instance, without modifying the original object.\n///\n/// As such, _never_ mutate properties of a state directly. That'll\n/// just break things.\nclass EditorState {\n    /// @internal\n    constructor(\n    /// @internal\n    configuration, \n    /// @internal\n    values, \n    /// The current document.\n    doc, \n    /// The current selection.\n    selection) {\n        this.configuration = configuration;\n        this.values = values;\n        this.doc = doc;\n        this.selection = selection;\n        for (let range of selection.ranges)\n            if (range.to > doc.length)\n                throw new RangeError(\"Selection points outside of document\");\n    }\n    field(field, require = true) {\n        let value = this.values[field.id];\n        if (value === undefined && !Object.prototype.hasOwnProperty.call(this.values, field.id)) {\n            // FIXME document or avoid this\n            if (this.behavior(stateField).indexOf(field) > -1)\n                throw new RangeError(\"Field hasn't been initialized yet\");\n            if (require)\n                throw new RangeError(\"Field is not present in this state\");\n            return undefined;\n        }\n        return value;\n    }\n    /// @internal\n    applyTransaction(tr) {\n        let values = Object.create(null), configuration = tr.configuration;\n        let newState = new EditorState(configuration, values, tr.doc, tr.selection);\n        for (let field of configuration.getBehavior(stateField)) {\n            let exists = configuration == this.configuration || Object.prototype.hasOwnProperty.call(this.values, field.id);\n            values[field.id] = exists ? field.apply(tr, this.values[field.id], newState) : field.init(newState);\n        }\n        return newState;\n    }\n    /// Start a new transaction from this state. When not given, the\n    /// timestamp defaults to\n    /// [`Date.now()`](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/now).\n    t(timestamp) {\n        return new Transaction(this, timestamp);\n    }\n    /// Join an array of lines using the state's [line\n    /// separator](#state.EditorState^lineSeparator).\n    joinLines(text) { return text.join(this.behavior(EditorState.lineSeparator) || \"\\n\"); }\n    /// Split a string into lines using the state's [line\n    /// separator](#state.EditorState^lineSeparator).\n    splitLines(text) { return text.split(this.behavior(EditorState.lineSeparator) || DEFAULT_SPLIT); }\n    /// Get the value of a state [behavior](#extension.Behavior).\n    behavior(behavior) {\n        return this.configuration.getBehavior(behavior, this);\n    }\n    /// Convert this state to a JSON-serializable object.\n    toJSON() {\n        // FIXME plugin state serialization\n        return {\n            doc: this.joinLines(this.doc.sliceLines(0, this.doc.length)),\n            selection: this.selection.toJSON()\n        };\n    }\n    /// Deserialize a state from its JSON representation.\n    static fromJSON(json, config = {}) {\n        if (!json || typeof json.doc != \"string\")\n            throw new RangeError(\"Invalid JSON representation for EditorState\");\n        return EditorState.create({\n            doc: json.doc,\n            selection: EditorSelection.fromJSON(json.selection),\n            extensions: config.extensions\n        });\n    }\n    /// Create a new state. You'll usually only need this when\n    /// initializing an editorâ€”updated states are created by applying\n    /// transactions.\n    static create(config = {}) {\n        let configuration = extendState.resolve(config.extensions || []);\n        let values = Object.create(null);\n        let doc = config.doc instanceof _text__WEBPACK_IMPORTED_MODULE_0__[\"Text\"] ? config.doc\n            : _text__WEBPACK_IMPORTED_MODULE_0__[\"Text\"].of((config.doc || \"\").split(configuration.getBehavior(EditorState.lineSeparator) || DEFAULT_SPLIT));\n        let selection = config.selection || EditorSelection.single(0);\n        if (!configuration.getBehavior(EditorState.allowMultipleSelections))\n            selection = selection.asSingle();\n        let state = new EditorState(configuration, values, doc, selection);\n        for (let field of state.behavior(stateField)) {\n            let exists = values[field.id];\n            if (exists)\n                throw new Error(`Duplicate use of state field${(exists.constructor || Object) != Object && exists.constructor.name ? ` (${exists.constructor.name})` : ''}`);\n            values[field.id] = field.init(state);\n        }\n        return state;\n    }\n    /// The size (in columns) of a tab in the document, determined by\n    /// the [`tabSize`](#state.EditorState^tabSize) behavior.\n    get tabSize() { return this.behavior(EditorState.tabSize); }\n    /// The size of an indent unit in the document. Determined by the\n    /// [`indentUnit`](#state.EditorState^indentUnit) behavior.\n    get indentUnit() { return this.behavior(EditorState.indentUnit); }\n}\n/// The [extension group](#extension.ExtensionGroup) for editor\n/// states, mostly used to define state extensions and\n/// [set](#extension.ExtensionGroup.fallback) their precedence.\nEditorState.extend = extendState;\n/// A behavior that, when enabled, causes the editor to allow\n/// multiple ranges to be selected. You should probably not use this\n/// directly, but let a plugin like\n/// [multiple-selections](#multiple-selections) handle it (which\n/// also makes sure the selections are visible in the view).\nEditorState.allowMultipleSelections = allowMultipleSelections;\n/// Behavior that defines a way to query for automatic indentation\n/// depth at the start of a given line.\nEditorState.indentation = extendState.behavior();\n/// Configures the tab size to use in this state. The first\n/// (highest-precedence) value of the behavior is used.\nEditorState.tabSize = extendState.behavior({\n    combine: values => values.length ? values[0] : DEFAULT_TABSIZE\n});\n/// The line separator to use. By default, any of `\"\\n\"`, `\"\\r\\n\"`\n/// and `\"\\r\"` is treated as a separator when splitting lines, and\n/// lines are joined with `\"\\n\"`.\n///\n/// When you configure a value here, only that precise separator\n/// will be used, allowing you to round-trip documents through the\n/// editor without normalizing line separators.\nEditorState.lineSeparator = extendState.behavior({\n    combine: values => values.length ? values[0] : undefined,\n    static: true\n});\n/// Behavior for overriding the unit (in columns) by which\n/// indentation happens. When not set, this defaults to 2.\nEditorState.indentUnit = extendState.behavior({\n    combine: values => values.length ? values[0] : DEFAULT_INDENT_UNIT\n});\n/// Behavior that registers a parsing service for the state.\nEditorState.syntax = extendState.behavior();\n/// A behavior that registers a code folding service. When called\n/// with the extent of a line, it'll return a range object when a\n/// foldable that starts on that line (but continues beyond it) can\n/// be found.\nEditorState.foldable = extendState.behavior();\n\n\n\n\n//# sourceURL=webpack:///./node_modules/@codemirror/next/state/dist/index.es.js?");

/***/ }),

/***/ "./node_modules/@codemirror/next/syntax/dist/index.es.js":
/*!***************************************************************!*\
  !*** ./node_modules/@codemirror/next/syntax/dist/index.es.js ***!
  \***************************************************************/
/*! exports provided: IndentContext, LezerSyntax, closeNodeProp, continuedIndent, delimitedIndent, flatIndent, foldNodeProp, indentNodeProp, openNodeProp */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IndentContext\", function() { return IndentContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LezerSyntax\", function() { return LezerSyntax; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"closeNodeProp\", function() { return closeNodeProp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"continuedIndent\", function() { return continuedIndent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"delimitedIndent\", function() { return delimitedIndent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"flatIndent\", function() { return flatIndent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"foldNodeProp\", function() { return foldNodeProp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"indentNodeProp\", function() { return indentNodeProp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"openNodeProp\", function() { return openNodeProp; });\n/* harmony import */ var lezer_tree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lezer-tree */ \"./node_modules/lezer-tree/dist/tree.js\");\n/* harmony import */ var lezer_tree__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lezer_tree__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../state */ \"./node_modules/@codemirror/next/state/dist/index.es.js\");\n\n\n\n/// A syntax tree node prop used to associate indentation strategies\n/// with node types. Such a strategy is a function from an indentation\n/// context to a number. That number may be -1, to indicate that no\n/// definitive indentation can be determined, or a column number to\n/// which the given line should be indented.\nconst indentNodeProp = new lezer_tree__WEBPACK_IMPORTED_MODULE_0__[\"NodeProp\"]();\nfunction syntaxIndentation(syntax) {\n    return _state__WEBPACK_IMPORTED_MODULE_1__[\"EditorState\"].indentation((state, pos) => {\n        let tree = syntax.getPartialTree(state, pos, pos);\n        return computeIndentation(state, tree, pos);\n    });\n}\n// Compute the indentation for a given position from the syntax tree.\nfunction computeIndentation(state, ast, pos) {\n    let tree = ast.resolve(pos);\n    // Enter previous nodes that end in empty error terms, which means\n    // they were broken off by error recovery, so that indentation\n    // works even if the constructs haven't been finished.\n    for (let scan = tree, scanPos = pos;;) {\n        let last = scan.childBefore(scanPos);\n        if (!last)\n            break;\n        if (last.type.prop(lezer_tree__WEBPACK_IMPORTED_MODULE_0__[\"NodeProp\"].error) && last.start == last.end) {\n            tree = scan;\n            scanPos = last.start;\n        }\n        else {\n            scan = last;\n            scanPos = scan.end + 1;\n        }\n    }\n    for (; tree; tree = tree.parent) {\n        let strategy = indentStrategy(tree.type) || (tree.parent == null ? topIndent : null);\n        if (strategy)\n            return strategy(new IndentContext(state, pos, tree));\n    }\n    return -1;\n}\nfunction indentStrategy(type) {\n    let strategy = type.prop(indentNodeProp);\n    if (!strategy) {\n        let delim = type.prop(lezer_tree__WEBPACK_IMPORTED_MODULE_0__[\"NodeProp\"].delim);\n        if (delim)\n            return delimitedIndent({ closing: delim.split(\" \")[1] });\n    }\n    return strategy;\n}\nfunction topIndent() { return 0; }\n/// Objects of this type provide context information and helper\n/// methods to indentation functions.\nclass IndentContext {\n    /// @internal\n    constructor(\n    /// The editor state.\n    state, \n    /// The position at which indentation is being computed.\n    pos, \n    /// The syntax tree node for which the indentation strategy is\n    /// registered.\n    node) {\n        this.state = state;\n        this.pos = pos;\n        this.node = node;\n    }\n    /// The indent unit (number of spaces per indentation level).\n    get unit() { return this.state.indentUnit; }\n    /// Get the text directly after `this.pos`, either the entire line\n    /// or the next 50 characters, whichever is shorter.\n    get textAfter() {\n        return this.state.doc.slice(this.pos, Math.min(this.pos + 50, this.state.doc.lineAt(this.pos).end)).match(/^\\s*(.*)/)[1];\n    }\n    /// find the column position (taking tabs into account) of the given\n    /// position in the given string.\n    countColumn(line, pos) {\n        // FIXME use extending character information\n        if (pos < 0)\n            pos = line.length;\n        let tab = this.state.tabSize;\n        for (var i = 0, n = 0;;) {\n            let nextTab = line.indexOf(\"\\t\", i);\n            if (nextTab < 0 || nextTab >= pos)\n                return n + (pos - i);\n            n += nextTab - i;\n            n += tab - (n % tab);\n            i = nextTab + 1;\n        }\n    }\n    /// Find the indentation column of the given document line.\n    lineIndent(line) {\n        let text = line.slice(0, Math.min(50, line.length, this.node.start > line.start ? this.node.start - line.start : 1e8));\n        return this.countColumn(text, text.search(/\\S/));\n    }\n    /// Get the indentation at the reference line for `this.tree`, which\n    /// is the line on which it starts, unless there is a node that is\n    /// _not_ a parent of this node covering the start of that line. If\n    /// so, the line at the start of that node is tried, again skipping\n    /// on if it is covered by another such node.\n    get baseIndent() {\n        let line = this.state.doc.lineAt(this.node.start);\n        // Skip line starts that are covered by a sibling (or cousin, etc)\n        for (;;) {\n            let atBreak = this.node.resolve(line.start);\n            while (atBreak.parent && atBreak.parent.start == atBreak.start)\n                atBreak = atBreak.parent;\n            if (isParent(atBreak, this.node))\n                break;\n            line = this.state.doc.lineAt(atBreak.start);\n        }\n        return this.lineIndent(line);\n    }\n    /// Find the column for the given position.\n    column(pos) {\n        let line = this.state.doc.lineAt(pos);\n        return this.countColumn(line.slice(0, pos - line.start), pos - line.start);\n    }\n}\nfunction isParent(parent, of) {\n    for (let cur = of; cur; cur = cur.parent)\n        if (parent == cur)\n            return true;\n    return false;\n}\n// Check whether a delimited node is aligned (meaning there are\n// non-skipped nodes on the same line as the opening delimiter). And\n// if so, return the opening token.\nfunction bracketedAligned(context) {\n    let tree = context.node;\n    let openToken = tree.childAfter(tree.start);\n    if (!openToken)\n        return null;\n    let openLine = context.state.doc.lineAt(openToken.start);\n    for (let pos = openToken.end;;) {\n        let next = tree.childAfter(pos);\n        if (!next)\n            return null;\n        if (!next.type.prop(lezer_tree__WEBPACK_IMPORTED_MODULE_0__[\"NodeProp\"].skipped))\n            return next.start < openLine.end ? openToken : null;\n        pos = next.end;\n    }\n}\n/// An indentation strategy for delimited (usually bracketed) nodes.\n/// Will, by default, indent one unit more than the parent's base\n/// indent unless the line starts with a closing token. When `align`\n/// is true and there are non-skipped nodes on the node's opening\n/// line, the content of the node will be aligned with the end of the\n/// opening node, like this:\n///\n///     foo(bar,\n///         baz)\nfunction delimitedIndent({ closing, align = true, units = 1 }) {\n    return (context) => {\n        let closed = context.textAfter.slice(0, closing.length) == closing;\n        let aligned = align ? bracketedAligned(context) : null;\n        if (aligned)\n            return closed ? context.column(aligned.start) : context.column(aligned.end);\n        return context.baseIndent + (closed ? 0 : context.unit * units);\n    };\n}\n/// An indentation strategy that aligns a node content to its base\n/// indentation.\nconst flatIndent = (context) => context.baseIndent;\n/// Creates an indentation strategy that, by default, indents\n/// continued lines one unit more than the node's base indentation.\n/// You can provide `except` to prevent indentation of lines that\n/// match a pattern (for example `/^else\\b/` in `if`/`else`\n/// constructs), and you can change the amount of units used with the\n/// `units` option.\nfunction continuedIndent({ except, units = 1 } = {}) {\n    return (context) => {\n        let matchExcept = except && except.test(context.textAfter);\n        return context.baseIndent + (matchExcept ? 0 : units * context.unit);\n    };\n}\n\n/// This node prop is used to associate folding information with node\n/// types. Given a subtree, it should check whether that tree is\n/// foldable and return the range that can be collapsed when it is.\nconst foldNodeProp = new lezer_tree__WEBPACK_IMPORTED_MODULE_0__[\"NodeProp\"]();\nfunction syntaxFolding(syntax) {\n    return _state__WEBPACK_IMPORTED_MODULE_1__[\"EditorState\"].foldable((state, start, end) => {\n        let tree = syntax.getPartialTree(state, start, Math.min(state.doc.length, end + 100));\n        let inner = tree.resolve(end);\n        let found = null;\n        for (let cur = inner; cur; cur = cur.parent) {\n            if (cur.start < start || cur.end <= end)\n                continue;\n            let prop = cur.type.prop(foldNodeProp);\n            if (prop) {\n                let value = prop(cur);\n                if (value && value.to > end)\n                    found = value;\n            }\n        }\n        return found;\n    });\n}\n\n/// A [syntax provider](#state.Syntax) based on a\n/// [Lezer](https://lezer.codemirror.net) parser.\nclass LezerSyntax {\n    /// Create a syntax instance for the given parser. You'll usually\n    /// want to use the\n    /// [`withProps`](https://lezer.codemirror.net/docs/ref/#lezer.Parser.withProps)\n    /// method to register CodeMirror-specific syntax node props in the\n    /// parser, before passing it to this constructor.\n    constructor(parser) {\n        this.parser = parser;\n        this.field = new _state__WEBPACK_IMPORTED_MODULE_1__[\"StateField\"]({\n            init() { return new SyntaxState(lezer_tree__WEBPACK_IMPORTED_MODULE_0__[\"Tree\"].empty); },\n            apply(tr, value) { return value.apply(tr); }\n        });\n        this.extension = [_state__WEBPACK_IMPORTED_MODULE_1__[\"EditorState\"].syntax(this), this.field.extension, syntaxIndentation(this), syntaxFolding(this)];\n    }\n    tryGetTree(state, from, to) {\n        let field = state.field(this.field);\n        return field.updateTree(this.parser, state.doc, from, to, false) ? field.tree : null;\n    }\n    getTree(state, from, to) {\n        let field = state.field(this.field);\n        let rest = field.updateTree(this.parser, state.doc, from, to, true);\n        return { tree: field.tree, rest: rest === true ? null : rest };\n    }\n    getPartialTree(state, from, to) {\n        let field = state.field(this.field);\n        field.updateTree(this.parser, state.doc, from, to, false);\n        return field.tree;\n    }\n    get docNodeType() { return this.parser.group.types[1]; }\n    languageDataAt(state, pos) {\n        let type = this.parser.group.types[1];\n        if (this.parser.hasNested) {\n            let tree = this.getPartialTree(state, pos, pos);\n            let target = tree.resolve(pos);\n            while (target) {\n                if (target.type.prop(lezer_tree__WEBPACK_IMPORTED_MODULE_0__[\"NodeProp\"].top)) {\n                    type = target.type;\n                    break;\n                }\n                target = target.parent;\n            }\n        }\n        return (type.prop(_state__WEBPACK_IMPORTED_MODULE_1__[\"languageData\"]) || nothing);\n    }\n}\nconst nothing = {};\nclass DocStream {\n    constructor(doc, length = doc.length) {\n        this.doc = doc;\n        this.length = length;\n        this.cursorPos = 0;\n        this.string = \"\";\n        this.cursor = doc.iter();\n    }\n    get(pos) {\n        if (pos >= this.length)\n            return -1;\n        let stringStart = this.cursorPos - this.string.length;\n        if (pos < stringStart || pos >= this.cursorPos) {\n            if (pos < this.cursorPos) { // Reset the cursor if we have to go back\n                this.cursor = this.doc.iter();\n                this.cursorPos = 0;\n            }\n            this.string = this.cursor.next(pos - this.cursorPos).value;\n            this.cursorPos = pos + this.string.length;\n            stringStart = this.cursorPos - this.string.length;\n        }\n        return this.string.charCodeAt(pos - stringStart);\n    }\n    read(from, to) {\n        let stringStart = this.cursorPos - this.string.length;\n        if (from < stringStart || to >= this.cursorPos)\n            return this.doc.slice(from, to);\n        else\n            return this.string.slice(from - stringStart, to - stringStart);\n    }\n    clip(at) {\n        return new DocStream(this.doc, at);\n    }\n}\nclass RequestInfo {\n    constructor(upto) {\n        this.upto = upto;\n        this.promise = new Promise(r => this.resolve = r);\n        this.promise.canceled = false;\n    }\n}\nclass SyntaxState {\n    constructor(tree) {\n        this.tree = tree;\n        this.parsedTo = 0;\n        this.parse = null;\n        this.working = -1;\n        this.requests = [];\n    }\n    apply(tr) {\n        return tr.docChanged ? new SyntaxState(this.tree.applyChanges(tr.changes.changedRanges())) : this;\n    }\n    // FIXME implement clearing out parts of the tree when it is too big\n    updateTree(parser, doc, from, to, rest) {\n        if (to <= this.parsedTo)\n            return true;\n        if (!this.parse) {\n            this.parse = parser.startParse(new DocStream(doc), { cache: this.tree });\n            this.continueParse(to);\n        }\n        if (this.parsedTo >= to)\n            return true;\n        if (!rest)\n            return false;\n        this.scheduleWork();\n        let req = this.requests.find(r => r.upto == to && !r.promise.canceled);\n        if (!req)\n            this.requests.push(req = new RequestInfo(to));\n        return req.promise;\n    }\n    continueParse(to) {\n        let endTime = Date.now() + 100 /* Slice */;\n        for (let i = 0;; i++) {\n            let done = this.parse.advance();\n            if (done) {\n                this.parsedTo = 1e9;\n                this.parse = null;\n                this.tree = done;\n                return;\n            }\n            if (i == 1000) {\n                i = 0;\n                if (Date.now() > endTime)\n                    break;\n            }\n        }\n        this.parsedTo = this.parse.pos;\n        // FIXME somehow avoid rebuilding all the nodes that are already\n        // in this.tree when this happens repeatedly\n        this.tree = this.parse.forceFinish();\n        if (this.parsedTo >= to)\n            this.parse = null;\n    }\n    scheduleWork() {\n        if (this.working != -1)\n            return;\n        this.working = setTimeout(() => this.work(), 200 /* Pause */);\n    }\n    work() {\n        this.working = -1;\n        let to = this.requests.reduce((max, req) => req.promise.canceled ? max : Math.max(max, req.upto), 0);\n        if (to > this.parsedTo)\n            this.continueParse(to);\n        this.requests = this.requests.filter(req => {\n            if (!req.promise.canceled && req.upto > this.parsedTo)\n                return true;\n            if (!req.promise.canceled)\n                req.resolve(this.tree);\n            return false;\n        });\n        if (this.requests.length)\n            this.scheduleWork();\n    }\n}\n\nfunction mkMatchProp() { return new lezer_tree__WEBPACK_IMPORTED_MODULE_0__[\"NodeProp\"]({ deserialize(str) { return str.split(\" \"); } }); }\n/// A node prop that encodes information about which other nodes match\n/// this node as delimiters. Should hold a space-separated list of\n/// node names of the closing nodes that match this node.\nconst openNodeProp = mkMatchProp();\n/// Like `openNodeProp`, but for closing nodes. Should hold a\n/// space-separated list of opening node names that match this closing\n/// delimiter.\nconst closeNodeProp = mkMatchProp();\n\n\n\n\n//# sourceURL=webpack:///./node_modules/@codemirror/next/syntax/dist/index.es.js?");

/***/ }),

/***/ "./node_modules/@codemirror/next/text/dist/index.es.js":
/*!*************************************************************!*\
  !*** ./node_modules/@codemirror/next/text/dist/index.es.js ***!
  \*************************************************************/
/*! exports provided: CharType, Line, Text, charType, codePointAt, countColumn, findColumn, fromCodePoint, isExtendingChar, isWordChar, minPairCodePoint */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CharType\", function() { return CharType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Line\", function() { return Line; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Text\", function() { return Text; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"charType\", function() { return charType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"codePointAt\", function() { return codePointAt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"countColumn\", function() { return countColumn; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findColumn\", function() { return findColumn; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromCodePoint\", function() { return fromCodePoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isExtendingChar\", function() { return isExtendingChar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isWordChar\", function() { return isWordChar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"minPairCodePoint\", function() { return minPairCodePoint; });\nlet extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u180b-\\u180d\\u18a9\\u200c\\u200d]/;\ntry {\n    extendingChars = new RegExp(\"\\\\p{Grapheme_Extend}\", \"u\");\n}\ncatch (_) { }\n/// Test whether a given code unit (as in, the thing that `charCodeAt`\n/// returns) extends the character before it.\nfunction isExtendingChar(code) {\n    return code >= 768 && (code >= 0xdc00 && code < 0xe000 || extendingChars.test(String.fromCharCode(code)));\n}\nconst nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\nlet wordChar;\ntry {\n    wordChar = new RegExp(\"[\\\\p{Alphabetic}_]\", \"u\");\n}\ncatch (_) { }\n// FIXME this doesn't work for astral chars yet (need different calling convention)\nfunction isWordCharBasic(ch) {\n    if (wordChar)\n        return wordChar.test(ch);\n    return /\\w/.test(ch) || ch > \"\\x80\" &&\n        (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));\n}\n/// Test whether the given character is a word character.\nfunction isWordChar(ch, wordChars) {\n    if (!wordChars)\n        return isWordCharBasic(ch);\n    if (wordChars.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch))\n        return true;\n    return wordChars.test(ch);\n}\n/// This is used to group characters into three categoriesâ€”word\n/// characters, whitespace, and anything else. It is used, by default,\n/// to do things like selecting by word.\nvar CharType;\n(function (CharType) {\n    CharType[CharType[\"Word\"] = 0] = \"Word\";\n    CharType[CharType[\"Space\"] = 1] = \"Space\";\n    CharType[CharType[\"Other\"] = 2] = \"Other\";\n})(CharType || (CharType = {}));\n/// Determine the character type for a given character.\nfunction charType(ch, wordChars) {\n    // FIXME make this configurable in a better way\n    return /\\s/.test(ch) ? CharType.Space : isWordChar(ch, wordChars) ? CharType.Word : CharType.Other;\n}\n/// Find the code point at the given position in a string (as in the\n/// [`codePointAt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt)\n/// string method).\nfunction codePointAt(str, pos) {\n    let code0 = str.charCodeAt(pos);\n    if (code0 < 0xd800 || code0 > 0xdbff || pos + 1 == str.length)\n        return code0;\n    let code1 = str.charCodeAt(pos + 1);\n    if (code1 < 0xdc00 || code1 > 0xdfff)\n        return code0;\n    return ((code0 - 0xd800) << 10) + (code1 - 0xdc00) + 0x10000;\n}\n/// Given a Unicode codepoint, return the JavaScript string that\n/// respresents it (as in\n/// [`String.fromCodePoint`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint).\nfunction fromCodePoint(code) {\n    if (code <= 0xffff)\n        return String.fromCharCode(code);\n    code -= 0x10000;\n    return String.fromCharCode((code >> 10) + 0xd800, (code & 1023) + 0xdc00);\n}\n/// The first character that takes up two positions in a JavaScript\n/// string. It is often useful to compare with this after calling\n/// `codePointAt`, to figure out whether your character takes up 1 or\n/// 2 index positions.\nconst minPairCodePoint = 0x10000;\n\n/// Count the column position at the given offset into the string,\n/// taking extending characters and tab size into account.\nfunction countColumn(string, n, tabSize) {\n    for (let i = 0; i < string.length; i++) {\n        let code = string.charCodeAt(i);\n        if (code == 9)\n            n += tabSize - (n % tabSize);\n        else if (code < 768 || !isExtendingChar(code))\n            n++;\n    }\n    return n;\n}\n/// Find the offset that corresponds to the given column position in a\n/// string, taking extending characters and tab size into account.\nfunction findColumn(string, n, col, tabSize) {\n    for (let i = 0; i < string.length; i++) {\n        let code = string.charCodeAt(i);\n        if (isExtendingChar(code))\n            continue;\n        if (n >= col)\n            return { offset: i, leftOver: 0 };\n        n += code == 9 ? tabSize - (n % tabSize) : 1;\n    }\n    return { offset: string.length, leftOver: col - n };\n}\n\n/// The document tree type.\nclass Text {\n    /// @internal\n    constructor() { }\n    /// Get the line description around the given position.\n    lineAt(pos) {\n        if (pos < 0 || pos > this.length)\n            throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);\n        for (let i = 0; i < lineCache.length; i += 2) {\n            if (lineCache[i] != this)\n                continue;\n            let line = lineCache[i + 1];\n            if (line.start <= pos && line.end >= pos)\n                return line;\n        }\n        return cacheLine(this, this.lineInner(pos, false, 1, 0).finish(this));\n    }\n    /// Get the description for the given (1-based) line number.\n    line(n) {\n        if (n < 1 || n > this.lines)\n            throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);\n        for (let i = 0; i < lineCache.length; i += 2) {\n            if (lineCache[i] != this)\n                continue;\n            let line = lineCache[i + 1];\n            if (line.number == n)\n                return line;\n        }\n        return cacheLine(this, this.lineInner(n, true, 1, 0).finish(this));\n    }\n    /// Replace a range of the text with the given lines. `text` should\n    /// have a length of at least one.\n    replace(from, to, text) {\n        if (text.length == 0)\n            throw new RangeError(\"An inserted range must have at least one line\");\n        return this.replaceInner(from, to, text, textLength(text));\n    }\n    /// Retrieve the lines between the given points.\n    sliceLines(from, to = this.length) {\n        return this.sliceTo(from, to, [\"\"]);\n    }\n    /// Retrieve the text between the given points.\n    slice(from, to, lineSeparator = \"\\n\") {\n        return this.sliceLines(from, to).join(lineSeparator);\n    }\n    /// Test whether this text is equal to another instance.\n    eq(other) { return this == other || eqContent(this, other); }\n    /// Iterate over the text. When `dir` is `-1`, iteration happens\n    /// from end to start. This will return lines and the breaks between\n    /// them as separate strings, and for long lines, might split lines\n    /// themselves into multiple chunks as well.\n    iter(dir = 1) { return new RawTextCursor(this, dir); }\n    /// Iterate over a range of the text. When `from` > `to`, the\n    /// iterator will run in reverse.\n    iterRange(from, to = this.length) { return new PartialTextCursor(this, from, to); }\n    /// Iterate over lines in the text, starting at position (_not_ line\n    /// number) `from`. An iterator returned by this combines all text\n    /// on a line into a single string (which may be expensive for very\n    /// long lines), and skips line breaks (its\n    /// [`lineBreak`](#text.TextIterator.lineBreak) property is always\n    /// false).\n    iterLines(from = 0) { return new LineCursor(this, from); }\n    /// Flattens the document into a single string, using `\"\\n\"` as line\n    /// separator.\n    toString() { return this.slice(0, this.length); }\n    /// Create a `Text` instance for the given array of lines.\n    static of(text) {\n        if (text.length == 0)\n            throw new RangeError(\"A document must have at least one line\");\n        let length = textLength(text);\n        return length < 1024 /* MaxLeaf */ ? new TextLeaf(text, length) : TextNode.from(TextLeaf.split(text, []), length);\n    }\n}\nlet lineCache = [], lineCachePos = -2, lineCacheSize = 12;\nfunction cacheLine(text, line) {\n    lineCachePos = (lineCachePos + 2) % lineCacheSize;\n    lineCache[lineCachePos] = text;\n    lineCache[lineCachePos + 1] = line;\n    return line;\n}\n// Leaves store an array of strings. There are always line breaks\n// between these strings (though not between adjacent leaves). These\n// are limited in length, so that bigger documents are constructed as\n// a tree structure. Long lines will be broken into a number of\n// single-line leaves.\nclass TextLeaf extends Text {\n    constructor(text, length = textLength(text)) {\n        super();\n        this.text = text;\n        this.length = length;\n    }\n    get lines() { return this.text.length; }\n    get children() { return null; }\n    replaceInner(from, to, text, length) {\n        return Text.of(appendText(this.text, appendText(text, sliceText(this.text, 0, from)), to));\n    }\n    sliceTo(from, to = this.length, target) {\n        return appendText(this.text, target, from, to);\n    }\n    lineInner(target, isLine, line, offset) {\n        for (let i = 0;; i++) {\n            let string = this.text[i], end = offset + string.length;\n            if ((isLine ? line : end) >= target)\n                return new Line(offset, end, line, string);\n            offset = end + 1;\n            line++;\n        }\n    }\n    decomposeStart(to, target) {\n        target.push(new TextLeaf(sliceText(this.text, 0, to), to));\n    }\n    decomposeEnd(from, target) {\n        target.push(new TextLeaf(sliceText(this.text, from), this.length - from));\n    }\n    lastLineLength() { return this.text[this.text.length - 1].length; }\n    firstLineLength() { return this.text[0].length; }\n    static split(text, target) {\n        let part = [], length = -1;\n        for (let line of text) {\n            for (;;) {\n                let newLength = length + line.length + 1;\n                if (newLength < 512 /* BaseLeaf */) {\n                    length = newLength;\n                    part.push(line);\n                    break;\n                }\n                let cut = 512 /* BaseLeaf */ - length - 1, after = line.charCodeAt(cut);\n                if (after >= 0xdc00 && after < 0xe000)\n                    cut++;\n                part.push(line.slice(0, cut));\n                target.push(new TextLeaf(part, 512 /* BaseLeaf */));\n                line = line.slice(cut);\n                length = -1;\n                part = [];\n            }\n        }\n        if (length != -1)\n            target.push(new TextLeaf(part, length));\n        return target;\n    }\n}\n// Nodes provide the tree structure of the `Text` type. They store a\n// number of other nodes or leaves, taking care to balance itself on\n// changes.\nclass TextNode extends Text {\n    constructor(children, length) {\n        super();\n        this.children = children;\n        this.length = length;\n        this.lines = 1;\n        for (let child of children)\n            this.lines += child.lines - 1;\n    }\n    replaceInner(from, to, text, length) {\n        let lengthDiff = length - (to - from), newLength = this.length + lengthDiff;\n        if (newLength <= 512 /* BaseLeaf */)\n            return new TextLeaf(appendText(this.sliceLines(to), appendText(text, this.sliceTo(0, from, [\"\"]))), newLength);\n        let children;\n        for (let i = 0, pos = 0; i < this.children.length; i++) {\n            let child = this.children[i], end = pos + child.length;\n            if (from >= pos && to <= end &&\n                (lengthDiff > 0\n                    ? child.length + lengthDiff < Math.max(newLength >> (3 /* BranchShift */ - 1), 1024 /* MaxLeaf */)\n                    : child.length + lengthDiff > newLength >> (3 /* BranchShift */ + 1))) {\n                // Fast path: if the change only affects one child and the\n                // child's size remains in the acceptable range, only update\n                // that child\n                children = this.children.slice();\n                children[i] = child.replace(from - pos, to - pos, text);\n                return new TextNode(children, newLength);\n            }\n            else if (end >= from) {\n                // Otherwise, we must build up a new array of children\n                if (children == null)\n                    children = this.children.slice(0, i);\n                if (pos < from) {\n                    if (end == from)\n                        children.push(child);\n                    else\n                        child.decomposeStart(from - pos, children);\n                }\n                if (pos <= from && end >= from)\n                    TextLeaf.split(text, children);\n                if (pos >= to)\n                    children.push(child);\n                else if (end > to)\n                    child.decomposeEnd(to - pos, children);\n            }\n            pos = end;\n        }\n        return children ? TextNode.from(children, newLength) : this;\n    }\n    sliceTo(from, to, target) {\n        let pos = 0;\n        for (let child of this.children) {\n            let end = pos + child.length;\n            if (to > pos && from < end)\n                child.sliceTo(Math.max(0, from - pos), Math.min(child.length, to - pos), target);\n            pos = end;\n        }\n        return target;\n    }\n    lineInner(target, isLine, line, offset) {\n        for (let i = 0;; i++) {\n            let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;\n            if ((isLine ? endLine : end) >= target) {\n                let inner = child.lineInner(target, isLine, line, offset), add;\n                if (inner.start == offset && (add = this.lineLengthTo(i))) {\n                    inner.start -= add;\n                    inner.content = null;\n                }\n                if (inner.end == end && (add = this.lineLengthFrom(i + 1))) {\n                    inner.end += add;\n                    inner.content = null;\n                }\n                return inner;\n            }\n            offset = end;\n            line = endLine;\n        }\n    }\n    decomposeStart(to, target) {\n        for (let i = 0, pos = 0;; i++) {\n            let child = this.children[i], end = pos + child.length;\n            if (end <= to) {\n                target.push(child);\n            }\n            else {\n                if (pos < to)\n                    child.decomposeStart(to - pos, target);\n                break;\n            }\n            pos = end;\n        }\n    }\n    decomposeEnd(from, target) {\n        let pos = 0;\n        for (let child of this.children) {\n            let end = pos + child.length;\n            if (pos >= from)\n                target.push(child);\n            else if (end > from && pos < from)\n                child.decomposeEnd(from - pos, target);\n            pos = end;\n        }\n    }\n    lineLengthTo(to) {\n        let length = 0;\n        for (let i = to - 1; i >= 0; i--) {\n            let child = this.children[i];\n            if (child.lines > 1)\n                return length + child.lastLineLength();\n            length += child.length;\n        }\n        return length;\n    }\n    lastLineLength() { return this.lineLengthTo(this.children.length); }\n    lineLengthFrom(from) {\n        let length = 0;\n        for (let i = from; i < this.children.length; i++) {\n            let child = this.children[i];\n            if (child.lines > 1)\n                return length + child.firstLineLength();\n            length += child.length;\n        }\n        return length;\n    }\n    firstLineLength() { return this.lineLengthFrom(0); }\n    static from(children, length) {\n        if (length < 1024 /* MaxLeaf */) {\n            let text = [\"\"];\n            for (let child of children)\n                child.sliceTo(0, child.length, text);\n            return new TextLeaf(text, length);\n        }\n        let chunkLength = Math.max(512 /* BaseLeaf */, length >> 3 /* BranchShift */), maxLength = chunkLength << 1, minLength = chunkLength >> 1;\n        let chunked = [], currentLength = 0, currentChunk = [];\n        function add(child) {\n            let childLength = child.length, last;\n            if (childLength > maxLength && child instanceof TextNode) {\n                for (let node of child.children)\n                    add(node);\n            }\n            else if (childLength > minLength && (currentLength > minLength || currentLength == 0)) {\n                flush();\n                chunked.push(child);\n            }\n            else if (child instanceof TextLeaf && currentLength > 0 &&\n                (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf &&\n                child.length + last.length <= 512 /* BaseLeaf */) {\n                currentLength += childLength;\n                currentChunk[currentChunk.length - 1] = new TextLeaf(appendText(child.text, last.text.slice()), child.length + last.length);\n            }\n            else {\n                if (currentLength + childLength > chunkLength)\n                    flush();\n                currentLength += childLength;\n                currentChunk.push(child);\n            }\n        }\n        function flush() {\n            if (currentLength == 0)\n                return;\n            chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLength));\n            currentLength = 0;\n            currentChunk.length = 0;\n        }\n        for (let child of children)\n            add(child);\n        flush();\n        return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);\n    }\n}\nText.empty = Text.of([\"\"]);\nfunction textLength(text) {\n    let length = -1;\n    for (let line of text)\n        length += line.length + 1;\n    return length;\n}\nfunction appendText(text, target, from = 0, to = 1e9) {\n    for (let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++) {\n        let line = text[i], end = pos + line.length;\n        if (end >= from) {\n            if (end > to)\n                line = line.slice(0, to - pos);\n            if (pos < from)\n                line = line.slice(from - pos);\n            if (first) {\n                target[target.length - 1] += line;\n                first = false;\n            }\n            else\n                target.push(line);\n        }\n        pos = end + 1;\n    }\n    return target;\n}\nfunction sliceText(text, from, to) {\n    return appendText(text, [\"\"], from, to);\n}\nfunction eqContent(a, b) {\n    if (a.length != b.length || a.lines != b.lines)\n        return false;\n    let iterA = new RawTextCursor(a), iterB = new RawTextCursor(b);\n    for (let offA = 0, offB = 0;;) {\n        if (iterA.lineBreak != iterB.lineBreak || iterA.done != iterB.done) {\n            return false;\n        }\n        else if (iterA.done) {\n            return true;\n        }\n        else if (iterA.lineBreak) {\n            iterA.next();\n            iterB.next();\n            offA = offB = 0;\n        }\n        else {\n            let strA = iterA.value.slice(offA), strB = iterB.value.slice(offB);\n            if (strA.length == strB.length) {\n                if (strA != strB)\n                    return false;\n                iterA.next();\n                iterB.next();\n                offA = offB = 0;\n            }\n            else if (strA.length > strB.length) {\n                if (strA.slice(0, strB.length) != strB)\n                    return false;\n                offA += strB.length;\n                iterB.next();\n                offB = 0;\n            }\n            else {\n                if (strB.slice(0, strA.length) != strA)\n                    return false;\n                offB += strA.length;\n                iterA.next();\n                offA = 0;\n            }\n        }\n    }\n}\nclass RawTextCursor {\n    // @internal\n    constructor(text, dir = 1) {\n        this.dir = dir;\n        this.done = false;\n        this.lineBreak = false;\n        this.value = \"\";\n        this.nodes = [text];\n        this.offsets = [dir > 0 ? 0 : text instanceof TextLeaf ? text.text.length : text.children.length];\n    }\n    next(skip = 0) {\n        for (;;) {\n            let last = this.nodes.length - 1;\n            if (last < 0) {\n                this.done = true;\n                this.value = \"\";\n                this.lineBreak = false;\n                return this;\n            }\n            let top = this.nodes[last];\n            let offset = this.offsets[last];\n            if (top instanceof TextLeaf) {\n                // Internal offset with lineBreak == false means we have to\n                // count the line break at this position\n                if (offset != (this.dir > 0 ? 0 : top.text.length) && !this.lineBreak) {\n                    this.lineBreak = true;\n                    if (skip == 0) {\n                        this.value = \"\\n\";\n                        return this;\n                    }\n                    skip--;\n                    continue;\n                }\n                // Otherwise, move to the next string\n                let next = top.text[offset - (this.dir < 0 ? 1 : 0)];\n                this.offsets[last] = (offset += this.dir);\n                if (offset == (this.dir > 0 ? top.text.length : 0)) {\n                    this.nodes.pop();\n                    this.offsets.pop();\n                }\n                this.lineBreak = false;\n                if (next.length > skip) {\n                    this.value = skip == 0 ? next : this.dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);\n                    return this;\n                }\n                skip -= next.length;\n            }\n            else if (offset == (this.dir > 0 ? top.children.length : 0)) {\n                this.nodes.pop();\n                this.offsets.pop();\n            }\n            else {\n                let next = top.children[this.dir > 0 ? offset : offset - 1], len = next.length;\n                this.offsets[last] = offset + this.dir;\n                if (skip > len) {\n                    skip -= len;\n                }\n                else {\n                    this.nodes.push(next);\n                    this.offsets.push(this.dir > 0 ? 0 : next instanceof TextLeaf ? next.text.length : next.children.length);\n                }\n            }\n        }\n    }\n}\nclass PartialTextCursor {\n    constructor(text, start, end) {\n        this.value = \"\";\n        this.cursor = new RawTextCursor(text, start > end ? -1 : 1);\n        if (start > end) {\n            this.skip = text.length - start;\n            this.limit = start - end;\n        }\n        else {\n            this.skip = start;\n            this.limit = end - start;\n        }\n    }\n    next() {\n        if (this.limit <= 0) {\n            this.limit = -1;\n        }\n        else {\n            let { value, lineBreak } = this.cursor.next(this.skip);\n            this.skip = 0;\n            this.value = value;\n            let len = lineBreak ? 1 : value.length;\n            if (len > this.limit)\n                this.value = this.cursor.dir > 0 ? value.slice(0, this.limit) : value.slice(len - this.limit);\n            this.limit -= this.value.length;\n        }\n        return this;\n    }\n    get lineBreak() { return this.cursor.lineBreak; }\n    get done() { return this.limit < 0; }\n}\nclass LineCursor {\n    constructor(text, from = 0) {\n        this.value = \"\";\n        this.done = false;\n        this.cursor = text.iter();\n        this.skip = from;\n    }\n    next() {\n        if (this.cursor.done) {\n            this.done = true;\n            this.value = \"\";\n            return this;\n        }\n        for (this.value = \"\";;) {\n            let { value, lineBreak, done } = this.cursor.next(this.skip);\n            this.skip = 0;\n            if (done || lineBreak)\n                return this;\n            this.value += value;\n        }\n    }\n    get lineBreak() { return false; }\n}\n// FIXME rename start/end to from/to for consistency with other types?\n/// This type describes a line in the document. It is created\n/// on-demand when lines are [queried](#text.Text.lineAt).\nclass Line {\n    /// @internal\n    constructor(\n    /// The position of the start of the line.\n    start, \n    /// The position at the end of the line (_before_ the line break,\n    /// if this isn't the last line).\n    end, \n    /// This line's line number (1-based).\n    number, \n    /// @internal\n    content) {\n        this.start = start;\n        this.end = end;\n        this.number = number;\n        this.content = content;\n    }\n    /// The length of the line (not including any line break after it).\n    get length() { return this.end - this.start; }\n    /// Retrieve a part of the content of this line. This is a method,\n    /// rather than, say, a string property, to avoid concatenating long\n    /// lines whenever they are accessed. Try to write your code, if it\n    /// is going to be doing a lot of line-reading, to read only the\n    /// parts it needs.\n    slice(from = 0, to = this.length) {\n        if (typeof this.content == \"string\")\n            return to == from + 1 ? this.content.charAt(from) : this.content.slice(from, to);\n        if (from == to)\n            return \"\";\n        let result = this.content.slice(from, to);\n        if (from == 0 && to == this.length)\n            this.content = result;\n        return result;\n    }\n    /// @internal\n    finish(text) {\n        if (this.content == null)\n            this.content = new LineContent(text, this.start);\n        return this;\n    }\n}\nclass LineContent {\n    constructor(doc, start) {\n        this.doc = doc;\n        this.start = start;\n        this.cursor = null;\n        this.strings = null;\n    }\n    // FIXME quadratic complexity (somewhat) when iterating long lines in small pieces\n    slice(from, to) {\n        if (!this.cursor) {\n            this.cursor = this.doc.iter();\n            this.strings = [this.cursor.next(this.start).value];\n        }\n        for (let result = \"\", pos = 0, i = 0;; i++) {\n            if (i == this.strings.length)\n                this.strings.push(this.cursor.next().value);\n            let string = this.strings[i], end = pos + string.length;\n            if (end <= from)\n                continue;\n            result += string.slice(Math.max(0, from - pos), Math.min(string.length, to - pos));\n            if (end >= to)\n                return result;\n            pos += string.length;\n        }\n    }\n}\n\n\n\n\n//# sourceURL=webpack:///./node_modules/@codemirror/next/text/dist/index.es.js?");

/***/ }),

/***/ "./node_modules/@codemirror/next/view/dist/index.es.js":
/*!*************************************************************!*\
  !*** ./node_modules/@codemirror/next/view/dist/index.es.js ***!
  \*************************************************************/
/*! exports provided: Range, BlockInfo, BlockType, Decoration, EditorView, ViewPlugin, ViewUpdate, WidgetType, __test */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BlockInfo\", function() { return BlockInfo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BlockType\", function() { return BlockType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Decoration\", function() { return Decoration; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EditorView\", function() { return EditorView; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ViewPlugin\", function() { return ViewPlugin; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ViewUpdate\", function() { return ViewUpdate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WidgetType\", function() { return WidgetType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__test\", function() { return __test; });\n/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../state */ \"./node_modules/@codemirror/next/state/dist/index.es.js\");\n/* harmony import */ var style_mod__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! style-mod */ \"./node_modules/style-mod/src/style-mod.js\");\n/* harmony import */ var _rangeset__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../rangeset */ \"./node_modules/@codemirror/next/rangeset/dist/index.es.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Range\", function() { return _rangeset__WEBPACK_IMPORTED_MODULE_2__[\"Range\"]; });\n\n/* harmony import */ var _text__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../text */ \"./node_modules/@codemirror/next/text/dist/index.es.js\");\n/* harmony import */ var _extension__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../extension */ \"./node_modules/@codemirror/next/extension/dist/index.es.js\");\n\n\n\n\n\n\n\nlet [nav, doc] = typeof navigator != \"undefined\"\n    ? [navigator, document]\n    : [{ userAgent: \"\", vendor: \"\", platform: \"\" }, { documentElement: { style: {} } }];\nconst ie_edge = /Edge\\/(\\d+)/.exec(nav.userAgent);\nconst ie_upto10 = /MSIE \\d/.test(nav.userAgent);\nconst ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(nav.userAgent);\nconst ie = !!(ie_upto10 || ie_11up || ie_edge);\nconst gecko = !ie && /gecko\\/(\\d+)/i.test(nav.userAgent);\nconst chrome = !ie && /Chrome\\/(\\d+)/.exec(nav.userAgent);\nconst webkit = !ie && 'WebkitAppearance' in doc.documentElement.style;\nvar browser = {\n    mac: /Mac/.test(nav.platform),\n    ie,\n    ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,\n    gecko,\n    gecko_version: gecko ? +(/Firefox\\/(\\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,\n    chrome: !!chrome,\n    chrome_version: chrome ? +chrome[1] : 0,\n    ios: !ie && /AppleWebKit/.test(nav.userAgent) && /Mobile\\/\\w+/.test(nav.userAgent),\n    android: /Android\\b/.test(nav.userAgent),\n    webkit,\n    safari: /Apple Computer/.test(nav.vendor),\n    webkit_version: webkit ? +(/\\bAppleWebKit\\/(\\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,\n    tabSize: doc.documentElement.style.tabSize != null ? \"tab-size\" : \"-moz-tab-size\"\n};\n\n// Work around Chrome issue https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n// (isCollapsed inappropriately returns true in shadow dom)\nfunction selectionCollapsed(domSel) {\n    let collapsed = domSel.isCollapsed;\n    if (collapsed && browser.chrome && domSel.rangeCount && !domSel.getRangeAt(0).collapsed)\n        collapsed = false;\n    return collapsed;\n}\nfunction hasSelection(dom, selection) {\n    if (!selection.anchorNode)\n        return false;\n    try {\n        // Firefox will raise 'permission denied' errors when accessing\n        // properties of `sel.anchorNode` when it's in a generated CSS\n        // element.\n        return dom.contains(selection.anchorNode.nodeType == 3 ? selection.anchorNode.parentNode : selection.anchorNode);\n    }\n    catch (_) {\n        return false;\n    }\n}\nfunction clientRectsFor(dom) {\n    if (dom.nodeType == 3) {\n        let range = document.createRange();\n        range.setEnd(dom, dom.nodeValue.length);\n        range.setStart(dom, 0);\n        return range.getClientRects();\n    }\n    else if (dom.nodeType == 1) {\n        return dom.getClientRects();\n    }\n    else {\n        return [];\n    }\n}\n// Scans forward and backward through DOM positions equivalent to the\n// given one to see if the two are in the same place (i.e. after a\n// text node vs at the end of that text node)\nfunction isEquivalentPosition(node, off, targetNode, targetOff) {\n    return targetNode ? (scanFor(node, off, targetNode, targetOff, -1) ||\n        scanFor(node, off, targetNode, targetOff, 1)) : false;\n}\nfunction domIndex(node) {\n    for (var index = 0;; index++) {\n        node = node.previousSibling;\n        if (!node)\n            return index;\n    }\n}\nfunction scanFor(node, off, targetNode, targetOff, dir) {\n    for (;;) {\n        if (node == targetNode && off == targetOff)\n            return true;\n        if (off == (dir < 0 ? 0 : maxOffset(node))) {\n            if (node.nodeName == \"DIV\")\n                return false;\n            let parent = node.parentNode;\n            if (!parent || parent.nodeType != 1)\n                return false;\n            off = domIndex(node) + (dir < 0 ? 0 : 1);\n            node = parent;\n        }\n        else if (node.nodeType == 1) {\n            node = node.childNodes[off + (dir < 0 ? -1 : 0)];\n            off = dir < 0 ? maxOffset(node) : 0;\n        }\n        else {\n            return false;\n        }\n    }\n}\nfunction maxOffset(node) {\n    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\nfunction windowRect(win) {\n    return { left: 0, right: win.innerWidth,\n        top: 0, bottom: win.innerHeight };\n}\nfunction scrollRectIntoView(dom, rect) {\n    let scrollMargin = 5;\n    let doc = dom.ownerDocument, win = doc.defaultView;\n    for (let cur = dom.parentNode; cur;) {\n        if (cur.nodeType == 1) { // Element\n            let bounding, top = cur == document.body;\n            if (top) {\n                bounding = windowRect(win);\n            }\n            else {\n                if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {\n                    cur = cur.parentNode;\n                    continue;\n                }\n                let rect = cur.getBoundingClientRect();\n                bounding = { left: rect.left, right: rect.left + cur.clientWidth,\n                    top: rect.top, bottom: rect.top + cur.clientHeight };\n            }\n            let moveX = 0, moveY = 0;\n            if (rect.top < bounding.top)\n                moveY = -(bounding.top - rect.top + scrollMargin);\n            else if (rect.bottom > bounding.bottom)\n                moveY = rect.bottom - bounding.bottom + scrollMargin;\n            if (rect.left < bounding.left)\n                moveX = -(bounding.left - rect.left + scrollMargin);\n            else if (rect.right > bounding.right)\n                moveX = rect.right - bounding.right + scrollMargin;\n            if (moveX || moveY) {\n                if (top) {\n                    win.scrollBy(moveX, moveY);\n                }\n                else {\n                    if (moveY) {\n                        let start = cur.scrollTop;\n                        cur.scrollTop += moveY;\n                        moveY = cur.scrollTop - start;\n                    }\n                    if (moveX) {\n                        let start = cur.scrollLeft;\n                        cur.scrollLeft += moveX;\n                        moveX = cur.scrollLeft - start;\n                    }\n                    rect = { left: rect.left - moveX, top: rect.top - moveY,\n                        right: rect.right - moveX, bottom: rect.bottom - moveY };\n                }\n            }\n            if (top)\n                break;\n            cur = cur.parentNode;\n        }\n        else if (cur.nodeType == 11) { // A shadow root\n            cur = cur.host;\n        }\n        else {\n            break;\n        }\n    }\n}\nclass DOMSelection {\n    constructor() {\n        this.anchorNode = null;\n        this.anchorOffset = 0;\n        this.focusNode = null;\n        this.focusOffset = 0;\n    }\n    eq(domSel) {\n        return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset &&\n            this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;\n    }\n    set(domSel) {\n        this.anchorNode = domSel.anchorNode;\n        this.anchorOffset = domSel.anchorOffset;\n        this.focusNode = domSel.focusNode;\n        this.focusOffset = domSel.focusOffset;\n    }\n}\n\nclass DOMPos {\n    constructor(node, offset, precise = true) {\n        this.node = node;\n        this.offset = offset;\n        this.precise = precise;\n    }\n    static before(dom, precise) { return new DOMPos(dom.parentNode, domIndex(dom), precise); }\n    static after(dom, precise) { return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise); }\n}\nconst none = [];\nclass ContentView {\n    constructor() {\n        this.parent = null;\n        this.dom = null;\n        this.dirty = 2 /* Node */;\n    }\n    get editorView() {\n        if (!this.parent)\n            throw new Error(\"Accessing view in orphan content view\");\n        return this.parent.editorView;\n    }\n    get overrideDOMText() { return null; }\n    get posAtStart() {\n        return this.parent ? this.parent.posBefore(this) : 0;\n    }\n    get posAtEnd() {\n        return this.posAtStart + this.length;\n    }\n    posBefore(view) {\n        let pos = this.posAtStart;\n        for (let child of this.children) {\n            if (child == view)\n                return pos;\n            pos += child.length + child.breakAfter;\n        }\n        throw new RangeError(\"Invalid child in posBefore\");\n    }\n    posAfter(view) {\n        return this.posBefore(view) + view.length;\n    }\n    coordsAt(pos) { return null; }\n    sync() {\n        if (this.dirty & 2 /* Node */) {\n            let parent = this.dom, pos = parent.firstChild;\n            for (let child of this.children) {\n                if (child.dirty) {\n                    if (pos && !child.dom && !pos.cmView) {\n                        let prev = pos.previousSibling;\n                        if (child.reuseDOM(pos))\n                            pos = prev ? prev.nextSibling : parent.firstChild;\n                    }\n                    child.sync();\n                    child.dirty = 0 /* Not */;\n                }\n                pos = syncNodeInto(parent, pos, child.dom);\n            }\n            while (pos)\n                pos = rm(pos);\n        }\n        else if (this.dirty & 1 /* Child */) {\n            for (let child of this.children)\n                if (child.dirty) {\n                    child.sync();\n                    child.dirty = 0 /* Not */;\n                }\n        }\n    }\n    reuseDOM(dom) { return false; }\n    localPosFromDOM(node, offset) {\n        let after;\n        if (node == this.dom) {\n            after = this.dom.childNodes[offset];\n        }\n        else {\n            let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;\n            for (;;) {\n                let parent = node.parentNode;\n                if (parent == this.dom)\n                    break;\n                if (bias == 0 && parent.firstChild != parent.lastChild) {\n                    if (node == parent.firstChild)\n                        bias = -1;\n                    else\n                        bias = 1;\n                }\n                node = parent;\n            }\n            if (bias < 0)\n                after = node;\n            else\n                after = node.nextSibling;\n        }\n        if (after == this.dom.firstChild)\n            return 0;\n        while (after && !after.cmView)\n            after = after.nextSibling;\n        if (!after)\n            return this.length;\n        for (let i = 0, pos = 0;; i++) {\n            let child = this.children[i];\n            if (child.dom == after)\n                return pos;\n            pos += child.length + child.breakAfter;\n        }\n    }\n    domBoundsAround(from, to, offset = 0) {\n        let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;\n        for (let i = 0, pos = offset; i < this.children.length; i++) {\n            let child = this.children[i], end = pos + child.length;\n            if (pos < from && end > to)\n                return child.domBoundsAround(from, to, pos);\n            if (end >= from && fromI == -1) {\n                fromI = i;\n                fromStart = pos;\n            }\n            if (end >= to && toI == -1) {\n                toI = i;\n                toEnd = end;\n                break;\n            }\n            pos = end + child.breakAfter;\n        }\n        return { from: fromStart, to: toEnd,\n            startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,\n            endDOM: toI < this.children.length - 1 ? this.children[toI + 1].dom : null };\n    }\n    // FIXME track precise dirty ranges, to avoid full DOM sync on every touched node?\n    markDirty(andParent = false) {\n        if (this.dirty & 2 /* Node */)\n            return;\n        this.dirty |= 2 /* Node */;\n        this.markParentsDirty(andParent);\n    }\n    markParentsDirty(childList) {\n        for (let parent = this.parent; parent; parent = parent.parent) {\n            if (childList)\n                parent.dirty |= 2 /* Node */;\n            if (parent.dirty & 1 /* Child */)\n                return;\n            parent.dirty |= 1 /* Child */;\n            childList = false;\n        }\n    }\n    setParent(parent) {\n        if (this.parent != parent) {\n            this.parent = parent;\n            if (this.dirty)\n                this.markParentsDirty(true);\n        }\n    }\n    setDOM(dom) {\n        this.dom = dom;\n        dom.cmView = this;\n    }\n    get rootView() {\n        for (let v = this;;) {\n            let parent = v.parent;\n            if (!parent)\n                return v;\n            v = parent;\n        }\n    }\n    replaceChildren(from, to, children = none) {\n        this.markDirty();\n        for (let i = from; i < to; i++)\n            this.children[i].parent = null;\n        this.children.splice(from, to - from, ...children);\n        for (let i = 0; i < children.length; i++)\n            children[i].setParent(this);\n    }\n    ignoreMutation(rec) { return false; }\n    ignoreEvent(event) { return false; }\n    childCursor(pos = this.length) {\n        return new ChildCursor(this.children, pos, this.children.length);\n    }\n    childPos(pos, bias = 1) {\n        return this.childCursor().findPos(pos, bias);\n    }\n    toString() {\n        let name = this.constructor.name.replace(\"View\", \"\");\n        return name + (this.children.length ? \"(\" + this.children.join() + \")\" :\n            this.length ? \"[\" + (name == \"Text\" ? this.text : this.length) + \"]\" : \"\") +\n            (this.breakAfter ? \"#\" : \"\");\n    }\n}\nContentView.prototype.breakAfter = 0;\n// Remove a DOM node and return its next sibling.\nfunction rm(dom) {\n    let next = dom.nextSibling;\n    dom.parentNode.removeChild(dom);\n    return next;\n}\nfunction syncNodeInto(parent, pos, dom) {\n    if (dom.parentNode == parent) {\n        while (pos != dom)\n            pos = rm(pos);\n        pos = dom.nextSibling;\n    }\n    else {\n        parent.insertBefore(dom, pos);\n    }\n    return pos;\n}\nclass ChildCursor {\n    constructor(children, pos, i) {\n        this.children = children;\n        this.pos = pos;\n        this.i = i;\n        this.off = 0;\n    }\n    findPos(pos, bias = 1) {\n        for (;;) {\n            if (pos > this.pos || pos == this.pos &&\n                (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {\n                this.off = pos - this.pos;\n                return this;\n            }\n            let next = this.children[--this.i];\n            this.pos -= next.length + next.breakAfter;\n        }\n    }\n}\n\nfunction combineAttrs(source, target) {\n    for (let name in source) {\n        if (name == \"class\" && target.class)\n            target.class += \" \" + source.class;\n        else if (name == \"style\" && target.style)\n            target.style += \";\" + source.style;\n        else\n            target[name] = source[name];\n    }\n    return target;\n}\nfunction attrsEq(a, b) {\n    if (a == b)\n        return true;\n    if (!a || !b)\n        return false;\n    let keysA = Object.keys(a), keysB = Object.keys(b);\n    if (keysA.length != keysB.length)\n        return false;\n    for (let key of keysA) {\n        if (keysB.indexOf(key) == -1 || a[key] !== b[key])\n            return false;\n    }\n    return true;\n}\nfunction updateAttrs(dom, prev, attrs) {\n    if (prev)\n        for (let name in prev)\n            if (!(attrs && name in attrs))\n                dom.removeAttribute(name);\n    if (attrs)\n        for (let name in attrs)\n            if (!(prev && prev[name] == attrs[name]))\n                dom.setAttribute(name, attrs[name]);\n}\n\nconst none$1 = [];\nclass InlineView extends ContentView {\n    match(other) { return false; }\n    get children() { return none$1; }\n    getSide() { return 0; }\n}\nconst MAX_JOIN_LEN = 256;\nclass TextView extends InlineView {\n    constructor(text, tagName, clss, attrs) {\n        super();\n        this.text = text;\n        this.tagName = tagName;\n        this.attrs = attrs;\n        this.textDOM = null;\n        this.class = clss;\n    }\n    get length() { return this.text.length; }\n    createDOM(textDOM) {\n        let tagName = this.tagName || (this.attrs || this.class ? \"span\" : null);\n        this.textDOM = textDOM || document.createTextNode(this.text);\n        if (tagName) {\n            let dom = document.createElement(tagName);\n            dom.appendChild(this.textDOM);\n            if (this.class)\n                dom.className = this.class;\n            if (this.attrs)\n                for (let name in this.attrs)\n                    dom.setAttribute(name, this.attrs[name]);\n            this.setDOM(dom);\n        }\n        else {\n            this.setDOM(this.textDOM);\n        }\n    }\n    sync() {\n        if (!this.dom)\n            this.createDOM();\n        if (this.textDOM.nodeValue != this.text) {\n            this.textDOM.nodeValue = this.text;\n            let dom = this.dom;\n            if (this.textDOM != dom && (this.dom.firstChild != this.textDOM || dom.lastChild != this.textDOM)) {\n                while (dom.firstChild)\n                    dom.removeChild(dom.firstChild);\n                dom.appendChild(this.textDOM);\n            }\n        }\n    }\n    reuseDOM(dom) {\n        if (dom.nodeType != 3)\n            return false;\n        this.createDOM(dom);\n        return true;\n    }\n    merge(from, to = this.length, source = null) {\n        if (source &&\n            (!(source instanceof TextView) ||\n                source.tagName != this.tagName || source.class != this.class ||\n                !attrsEq(source.attrs, this.attrs) || this.length - (to - from) + source.length > MAX_JOIN_LEN))\n            return false;\n        this.text = this.text.slice(0, from) + (source ? source.text : \"\") + this.text.slice(to);\n        this.markDirty();\n        return true;\n    }\n    slice(from, to = this.length) {\n        return new TextView(this.text.slice(from, to), this.tagName, this.class, this.attrs);\n    }\n    localPosFromDOM(node, offset) {\n        return node == this.textDOM ? offset : offset ? this.text.length : 0;\n    }\n    domAtPos(pos) { return new DOMPos(this.textDOM, pos); }\n    domBoundsAround(from, to, offset) {\n        return { from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };\n    }\n    coordsAt(pos) {\n        return textCoords(this.textDOM, pos);\n    }\n}\nfunction textCoords(text, pos) {\n    let range = document.createRange();\n    if (browser.chrome || browser.gecko) {\n        // These browsers reliably return valid rectangles for empty ranges\n        range.setEnd(text, pos);\n        range.setStart(text, pos);\n        return range.getBoundingClientRect();\n    }\n    else {\n        // Otherwise, get the rectangle around a character and take one side\n        let extend = pos == 0 ? 1 : -1;\n        range.setEnd(text, pos + (extend > 0 ? 1 : 0));\n        range.setStart(text, pos - (extend < 0 ? 1 : 0));\n        let rect = range.getBoundingClientRect();\n        let x = extend < 0 ? rect.right : rect.left;\n        return { left: x, right: x, top: rect.top, bottom: rect.bottom };\n    }\n}\n// Also used for collapsed ranges that don't have a placeholder widget!\nclass WidgetView extends InlineView {\n    constructor(widget, length, side, open) {\n        super();\n        this.widget = widget;\n        this.length = length;\n        this.side = side;\n        this.open = open;\n    }\n    static create(widget, length, side, open = 0) {\n        return new (widget.customView || WidgetView)(widget, length, side, open);\n    }\n    slice(from, to = this.length) { return WidgetView.create(this.widget, to - from, this.side); }\n    sync() {\n        if (!this.dom || !this.widget.updateDOM(this.dom)) {\n            this.setDOM(this.widget.toDOM(this.editorView));\n            this.dom.contentEditable = \"false\";\n        }\n    }\n    getSide() { return this.side; }\n    merge(from, to = this.length, source = null) {\n        if (source) {\n            if (!(source instanceof WidgetView) || !source.open ||\n                from > 0 && !(source.open & 1 /* Start */) ||\n                to < this.length && !(source.open & 2 /* End */))\n                return false;\n            if (!this.widget.compare(source.widget))\n                throw new Error(\"Trying to merge incompatible widgets\");\n        }\n        this.length = from + (source ? source.length : 0) + (this.length - to);\n        return true;\n    }\n    match(other) {\n        if (other.length == this.length && other instanceof WidgetView && other.side == this.side) {\n            if (this.widget.constructor == other.widget.constructor) {\n                if (!this.widget.eq(other.widget.value))\n                    this.markDirty(true);\n                this.widget = other.widget;\n                return true;\n            }\n        }\n        return false;\n    }\n    ignoreMutation() { return true; }\n    ignoreEvent(event) { return this.widget.ignoreEvent(event); }\n    get overrideDOMText() {\n        if (this.length == 0)\n            return [\"\"];\n        let top = this;\n        while (top.parent)\n            top = top.parent;\n        let state = top.state, text = state && state.doc, start = this.posAtStart;\n        return text ? text.sliceLines(start, start + this.length) : [\"\"];\n    }\n    domAtPos(pos) {\n        return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);\n    }\n    domBoundsAround() { return null; }\n    coordsAt(pos) {\n        let rects = this.dom.getClientRects();\n        for (let i = pos > 0 ? rects.length - 1 : 0;; i += (pos > 0 ? -1 : 1)) {\n            let rect = rects[i];\n            if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom)\n                return rects[i];\n        }\n        return null;\n    }\n}\nclass CompositionView extends WidgetView {\n    domAtPos(pos) { return new DOMPos(this.widget.value.text, pos); }\n    sync() { if (!this.dom)\n        this.setDOM(this.widget.toDOM(this.editorView)); }\n    ignoreMutation() { return false; }\n    get overrideDOMText() { return null; }\n    coordsAt(pos) { return textCoords(this.widget.value.text, pos); }\n}\n\n/// Widgets added to the content are described by subclasses of this\n/// class. This makes it possible to delay creating of the DOM\n/// structure for a widget until it is needed, and to avoid redrawing\n/// widgets even when the decorations that define them are recreated.\n/// `T` can be a type of value passed to instances of the widget type.\nclass WidgetType {\n    /// Create an instance of this widget type.\n    constructor(\n    /// @internal\n    value) {\n        this.value = value;\n    }\n    /// Compare this instance to another instance of the same class. By\n    /// default, it'll compare the instances' parameters with `===`.\n    eq(value) { return this.value === value; }\n    /// Update a DOM element created by a widget of the same type but\n    /// with a different value to reflect this widget. May return true\n    /// to indicate that it could update, false to indicate it couldn't\n    /// (in which case the widget will be redrawn). The default\n    /// implementation just returns false.\n    updateDOM(dom) { return false; }\n    /// @internal\n    compare(other) {\n        return this == other || this.constructor == other.constructor && this.eq(other.value);\n    }\n    /// The estimated height this widget will have, to be used when\n    /// estimating the height of content that hasn't been drawn. May\n    /// return -1 to indicate you don't know. The default implementation\n    /// returns -1.\n    get estimatedHeight() { return -1; }\n    /// Can be used to configure which kinds of events inside the widget\n    /// should be ignored by the editor. The default is to ignore all\n    /// events.\n    ignoreEvent(event) { return true; }\n    //// @internal\n    get customView() { return null; }\n}\nconst INLINE_BIG_SIDE = 1e8, BLOCK_BIG_SIDE = 2e8;\n/// The different types of blocks that can occur in an editor view.\nvar BlockType;\n(function (BlockType) {\n    /// A line of text.\n    BlockType[BlockType[\"Text\"] = 0] = \"Text\";\n    /// A block widget associated with the position after it.\n    BlockType[BlockType[\"WidgetBefore\"] = 1] = \"WidgetBefore\";\n    /// A block widget associated with the position before it.\n    BlockType[BlockType[\"WidgetAfter\"] = 2] = \"WidgetAfter\";\n    /// A block widget [replacing](#view.Decoration^replace) a range of content.\n    BlockType[BlockType[\"WidgetRange\"] = 3] = \"WidgetRange\";\n})(BlockType || (BlockType = {}));\n/// A decoration provides information on how to draw or style a piece\n/// of content. You'll usually use it wrapped in a\n/// [`Range`](#rangeset.Range), which adds a start and\n/// end position.\nclass Decoration extends _rangeset__WEBPACK_IMPORTED_MODULE_2__[\"RangeValue\"] {\n    /// @internal\n    constructor(\n    /// @internal\n    startSide, \n    /// @internal\n    endSide, \n    /// @internal\n    widget, \n    /// The config object used to create this decoration.\n    spec) {\n        super();\n        this.startSide = startSide;\n        this.endSide = endSide;\n        this.widget = widget;\n        this.spec = spec;\n    }\n    /// @internal\n    get point() { return false; }\n    /// @internal\n    get heightRelevant() { return false; }\n    /// Create a mark decoration, which influences the styling of the\n    /// text in its range.\n    static mark(from, to, spec) {\n        if (from >= to)\n            throw new RangeError(\"Mark decorations may not be empty\");\n        return new _rangeset__WEBPACK_IMPORTED_MODULE_2__[\"Range\"](from, to, new MarkDecoration(spec));\n    }\n    /// Create a widget decoration, which adds an element at the given\n    /// position.\n    static widget(pos, spec) {\n        let side = spec.side || 0;\n        if (spec.block)\n            side += (BLOCK_BIG_SIDE + 1) * (side > 0 ? 1 : -1);\n        return new _rangeset__WEBPACK_IMPORTED_MODULE_2__[\"Range\"](pos, pos, new PointDecoration(spec, side, side, !!spec.block, spec.widget));\n    }\n    /// Create a replace decoration which replaces the given range with\n    /// a widget, or simply hides it.\n    static replace(from, to, spec) {\n        let block = !!spec.block;\n        let { start, end } = getInclusive(spec);\n        let startSide = block ? -BLOCK_BIG_SIDE * (start ? 2 : 1) : INLINE_BIG_SIDE * (start ? -1 : 1);\n        let endSide = block ? BLOCK_BIG_SIDE * (end ? 2 : 1) : INLINE_BIG_SIDE * (end ? 1 : -1);\n        if (from > to || (from == to && startSide > 0 && endSide < 0))\n            throw new RangeError(\"Invalid range for replacement decoration\");\n        return new _rangeset__WEBPACK_IMPORTED_MODULE_2__[\"Range\"](from, Math.max(from, to), new PointDecoration(spec, startSide, endSide, block, spec.widget || null));\n    }\n    /// Create a line decoration, which can add DOM attributes to the\n    /// line starting at the given position.\n    static line(start, spec) {\n        return new _rangeset__WEBPACK_IMPORTED_MODULE_2__[\"Range\"](start, start, new LineDecoration(spec));\n    }\n    /// Build a [`DecorationSet`](#view.DecorationSet) from the given\n    /// decorated range or ranges.\n    static set(of) {\n        return _rangeset__WEBPACK_IMPORTED_MODULE_2__[\"RangeSet\"].of(of);\n    }\n    /// @internal\n    hasHeight() { return this.widget ? this.widget.estimatedHeight > -1 : false; }\n    /// @internal\n    mapSimple(mapping, from, to) {\n        let newFrom = mapping.mapPos(from, this.startSide, _state__WEBPACK_IMPORTED_MODULE_0__[\"MapMode\"].TrackDel);\n        if (from == to && this.startSide == this.endSide)\n            return newFrom < 0 ? null : new _rangeset__WEBPACK_IMPORTED_MODULE_2__[\"Range\"](newFrom, newFrom, this);\n        let newTo = mapping.mapPos(to, this.endSide, _state__WEBPACK_IMPORTED_MODULE_0__[\"MapMode\"].TrackDel);\n        if (newFrom < 0) {\n            if (newTo < 0)\n                return null;\n            newFrom = this.startSide >= 0 ? -(newFrom + 1) : mapping.mapPos(from, 1);\n        }\n        else if (newTo < 0) {\n            newTo = this.endSide < 0 ? -(newTo + 1) : mapping.mapPos(to, -1);\n        }\n        return newFrom < newTo ? new _rangeset__WEBPACK_IMPORTED_MODULE_2__[\"Range\"](newFrom, newTo, this) : null;\n    }\n}\n/// The empty set of decorations.\nDecoration.none = _rangeset__WEBPACK_IMPORTED_MODULE_2__[\"RangeSet\"].empty;\nclass MarkDecoration extends Decoration {\n    constructor(spec) {\n        let { start, end } = getInclusive(spec);\n        super(INLINE_BIG_SIDE * (start ? -1 : 1), INLINE_BIG_SIDE * (end ? 1 : -1), null, spec);\n    }\n    map(mapping, from, to) {\n        return this.mapSimple(mapping, from, to);\n    }\n    eq(other) {\n        return this == other ||\n            other instanceof MarkDecoration &&\n                this.spec.tagName == other.spec.tagName &&\n                this.spec.class == other.spec.class &&\n                attrsEq(this.spec.attributes || null, other.spec.attributes || null);\n    }\n}\nclass LineDecoration extends Decoration {\n    constructor(spec) {\n        super(-INLINE_BIG_SIDE, -INLINE_BIG_SIDE, null, spec);\n    }\n    get point() { return true; }\n    map(mapping, pos) {\n        pos = mapping.mapPos(pos, -1, _state__WEBPACK_IMPORTED_MODULE_0__[\"MapMode\"].TrackBefore);\n        return pos < 0 ? null : new _rangeset__WEBPACK_IMPORTED_MODULE_2__[\"Range\"](pos, pos, this);\n    }\n    eq(other) {\n        return other instanceof LineDecoration && attrsEq(this.spec.attributes, other.spec.attributes);\n    }\n}\nclass PointDecoration extends Decoration {\n    constructor(spec, startSide, endSide, block, widget) {\n        super(startSide, endSide, widget, spec);\n        this.block = block;\n    }\n    get point() { return true; }\n    // Only relevant when this.block == true\n    get type() {\n        return this.startSide < this.endSide ? BlockType.WidgetRange : this.startSide < 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;\n    }\n    get heightRelevant() { return this.block || !!this.widget && this.widget.estimatedHeight >= 5; }\n    map(mapping, from, to) {\n        // FIXME make mapping behavior configurable?\n        if (this.block) {\n            let { type } = this;\n            let newFrom = type == BlockType.WidgetAfter ? mapping.mapPos(from, 1, _state__WEBPACK_IMPORTED_MODULE_0__[\"MapMode\"].TrackAfter) : mapping.mapPos(from, -1, _state__WEBPACK_IMPORTED_MODULE_0__[\"MapMode\"].TrackBefore);\n            let newTo = type == BlockType.WidgetRange ? mapping.mapPos(to, 1, _state__WEBPACK_IMPORTED_MODULE_0__[\"MapMode\"].TrackAfter) : newFrom;\n            return newFrom < 0 || newTo < 0 ? null : new _rangeset__WEBPACK_IMPORTED_MODULE_2__[\"Range\"](newFrom, newTo, this);\n        }\n        else {\n            return this.mapSimple(mapping, from, to);\n        }\n    }\n    eq(other) {\n        return other instanceof PointDecoration &&\n            widgetsEq(this.widget, other.widget) &&\n            this.block == other.block &&\n            this.startSide == other.startSide && this.endSide == other.endSide;\n    }\n}\nfunction getInclusive(spec) {\n    let { inclusiveStart: start, inclusiveEnd: end } = spec;\n    if (start == null)\n        start = spec.inclusive;\n    if (end == null)\n        end = spec.inclusive;\n    return { start: start || false, end: end || false };\n}\nfunction widgetsEq(a, b) {\n    return a == b || !!(a && b && a.compare(b));\n}\nconst MIN_RANGE_GAP = 4;\nfunction addRange(from, to, ranges) {\n    if (ranges[ranges.length - 1] + MIN_RANGE_GAP > from)\n        ranges[ranges.length - 1] = to;\n    else\n        ranges.push(from, to);\n}\nfunction joinRanges(a, b) {\n    if (a.length == 0)\n        return b;\n    if (b.length == 0)\n        return a;\n    let result = [];\n    for (let iA = 0, iB = 0;;) {\n        if (iA < a.length && (iB == b.length || a[iA] < b[iB]))\n            addRange(a[iA++], a[iA++], result);\n        else if (iB < b.length)\n            addRange(b[iB++], b[iB++], result);\n        else\n            break;\n    }\n    return result;\n}\nclass Changes {\n    constructor() {\n        this.content = [];\n        this.height = [];\n    }\n}\nclass DecorationComparator {\n    constructor() {\n        this.changes = new Changes;\n    }\n    compareRange(from, to, activeA, activeB) {\n        addRange(from, to, this.changes.content);\n    }\n    comparePoint(from, to, byA, byB) {\n        addRange(from, to, this.changes.content);\n        if (from < to || byA.heightRelevant || byB && byB.heightRelevant)\n            addRange(from, to, this.changes.height);\n    }\n}\nfunction findChangedRanges(a, b, diff, lengthA) {\n    let comp = new DecorationComparator();\n    a.compare(b, diff, comp, lengthA);\n    return comp.changes;\n}\n\nconst styles = new style_mod__WEBPACK_IMPORTED_MODULE_1__[\"StyleModule\"]({\n    wrapper: {\n        position: \"relative !important\",\n        boxSizing: \"border-box\",\n        \"&.codemirror-focused\": {\n            // FIXME it would be great if we could directly use the browser's\n            // default focus outline, but it appears we can't, so this tries to\n            // approximate that\n            outline_fallback: \"1px dotted #212121\",\n            outline: \"5px auto -webkit-focus-ring-color\"\n        },\n        display: \"flex !important\",\n        flexDirection: \"column\"\n    },\n    scroller: {\n        display: \"flex !important\",\n        alignItems: \"flex-start !important\",\n        fontFamily: \"monospace\",\n        lineHeight: 1.4,\n        height: \"100%\"\n    },\n    content: {\n        margin: 0,\n        flexGrow: 2,\n        minHeight: \"100%\",\n        display: \"block\",\n        whiteSpace: \"pre\",\n        boxSizing: \"border-box\",\n        padding: \"4px 0\",\n        outline: \"none\",\n        caretColor: \"black\",\n    },\n    line: {\n        display: \"block\",\n        padding: \"0 2px 0 4px\"\n    }\n}, { priority: 0 });\n\nclass LineView extends ContentView {\n    constructor() {\n        super(...arguments);\n        this.children = [];\n        this.length = 0;\n        this.prevAttrs = undefined;\n        this.attrs = null;\n        this.breakAfter = 0;\n    }\n    // Consumes source\n    merge(from, to, source, takeDeco) {\n        if (source) {\n            if (!(source instanceof LineView))\n                return false;\n            if (!this.dom)\n                source.transferDOM(this); // Reuse source.dom when appropriate\n        }\n        if (takeDeco)\n            this.setDeco(source ? source.attrs : null);\n        let elts = source ? source.children : [];\n        let cur = this.childCursor();\n        let { i: toI, off: toOff } = cur.findPos(to, 1);\n        let { i: fromI, off: fromOff } = cur.findPos(from, -1);\n        let dLen = from - to;\n        for (let view of elts)\n            dLen += view.length;\n        this.length += dLen;\n        // Both from and to point into the same text view\n        if (fromI == toI && fromOff) {\n            let start = this.children[fromI];\n            // Maybe just update that view and be done\n            if (elts.length == 1 && start.merge(fromOff, toOff, elts[0]))\n                return true;\n            if (elts.length == 0) {\n                start.merge(fromOff, toOff, null);\n                return true;\n            }\n            // Otherwise split it, so that we don't have to worry about aliasing front/end afterwards\n            let after = start.slice(toOff);\n            if (after.merge(0, 0, elts[elts.length - 1]))\n                elts[elts.length - 1] = after;\n            else\n                elts.push(after);\n            toI++;\n            toOff = 0;\n        }\n        // Make sure start and end positions fall on node boundaries\n        // (fromOff/toOff are no longer used after this), and that if the\n        // start or end of the elts can be merged with adjacent nodes,\n        // this is done\n        if (toOff) {\n            let end = this.children[toI];\n            if (elts.length && end.merge(0, toOff, elts[elts.length - 1]))\n                elts.pop();\n            else\n                end.merge(0, toOff, null);\n        }\n        else if (toI < this.children.length && elts.length &&\n            this.children[toI].merge(0, 0, elts[elts.length - 1])) {\n            elts.pop();\n        }\n        if (fromOff) {\n            let start = this.children[fromI];\n            if (elts.length && start.merge(fromOff, undefined, elts[0]))\n                elts.shift();\n            else\n                start.merge(fromOff, undefined, null);\n            fromI++;\n        }\n        else if (fromI && elts.length && this.children[fromI - 1].merge(this.children[fromI - 1].length, undefined, elts[0])) {\n            elts.shift();\n        }\n        // Then try to merge any mergeable nodes at the start and end of\n        // the changed range\n        while (fromI < toI && elts.length && this.children[toI - 1].match(elts[elts.length - 1])) {\n            elts.pop();\n            toI--;\n        }\n        while (fromI < toI && elts.length && this.children[fromI].match(elts[0])) {\n            elts.shift();\n            fromI++;\n        }\n        // And if anything remains, splice the child array to insert the new elts\n        if (elts.length || fromI != toI)\n            this.replaceChildren(fromI, toI, elts);\n        return true;\n    }\n    split(at) {\n        let end = new LineView;\n        end.breakAfter = this.breakAfter;\n        if (this.length == 0)\n            return end;\n        let { i, off } = this.childPos(at);\n        if (off) {\n            end.append(this.children[i].slice(off));\n            this.children[i].merge(off, undefined, null);\n            i++;\n        }\n        for (let j = i; j < this.children.length; j++)\n            end.append(this.children[j]);\n        while (i > 0 && this.children[i - 1].length == 0) {\n            this.children[i - 1].parent = null;\n            i--;\n        }\n        this.children.length = i;\n        this.markDirty();\n        this.length = at;\n        return end;\n    }\n    transferDOM(other) {\n        if (!this.dom)\n            return;\n        other.setDOM(this.dom);\n        other.prevAttrs = this.prevAttrs === undefined ? this.attrs : this.prevAttrs;\n        this.prevAttrs = undefined;\n        this.dom = null;\n    }\n    setDeco(attrs) {\n        if (!attrsEq(this.attrs, attrs)) {\n            if (this.dom) {\n                this.prevAttrs = this.attrs;\n                this.markDirty();\n            }\n            this.attrs = attrs;\n        }\n    }\n    // Only called when building a line view in ContentBuilder\n    append(child) {\n        this.children.push(child);\n        child.setParent(this);\n        this.length += child.length;\n    }\n    // Only called when building a line view in ContentBuilder\n    addLineDeco(deco) {\n        let attrs = deco.spec.attributes;\n        if (attrs)\n            this.attrs = combineAttrs(attrs, this.attrs || {});\n    }\n    domAtPos(pos) {\n        let i = 0;\n        for (let off = 0; i < this.children.length; i++) {\n            let child = this.children[i], end = off + child.length;\n            if (end == off && child.getSide() <= 0)\n                continue;\n            if (pos > off && pos < end && child.dom.parentNode == this.dom)\n                return child.domAtPos(pos - off);\n            if (pos <= off)\n                break;\n            off = end;\n        }\n        for (; i > 0; i--) {\n            let before = this.children[i - 1].dom;\n            if (before.parentNode == this.dom)\n                return DOMPos.after(before);\n        }\n        return new DOMPos(this.dom, 0);\n    }\n    // FIXME might need another hack to work around Firefox's behavior\n    // of not actually displaying the cursor even though it's there in\n    // the DOM\n    sync() {\n        if (!this.dom) {\n            this.setDOM(document.createElement(\"div\"));\n            this.dom.className = \"codemirror-line \" + styles.line;\n            this.prevAttrs = this.attrs ? null : undefined;\n        }\n        if (this.prevAttrs !== undefined) {\n            updateAttrs(this.dom, this.prevAttrs, this.attrs);\n            this.dom.classList.add(\"codemirror-line\");\n            this.dom.classList.add(styles.line);\n            this.prevAttrs = undefined;\n        }\n        super.sync();\n        let last = this.dom.lastChild;\n        if (!last || (last.nodeName != \"BR\" && !(last.cmView instanceof TextView))) {\n            let hack = document.createElement(\"BR\");\n            hack.cmIgnore = true;\n            this.dom.appendChild(hack);\n        }\n    }\n    measureTextSize() {\n        if (this.children.length == 0 || this.length > 20)\n            return null;\n        let totalWidth = 0;\n        for (let child of this.children) {\n            if (!(child instanceof TextView))\n                return null;\n            let rects = clientRectsFor(child.dom);\n            if (rects.length != 1)\n                return null;\n            totalWidth += rects[0].width;\n        }\n        return { lineHeight: this.dom.getBoundingClientRect().height,\n            charWidth: totalWidth / this.length };\n    }\n    coordsAt(pos) {\n        for (let off = 0, i = 0; i < this.children.length; i++) {\n            let child = this.children[i], end = off + child.length;\n            if (end >= pos)\n                return child.coordsAt(pos - off);\n            off = end;\n        }\n        return this.dom.lastChild.getBoundingClientRect();\n    }\n    match(other) { return false; }\n    get type() { return BlockType.Text; }\n}\nconst none$2 = [];\nclass BlockWidgetView extends ContentView {\n    constructor(widget, length, type, \n    // This is set by the builder and used to distinguish between\n    // adjacent widgets and parts of the same widget when calling\n    // `merge`. It's kind of silly that it's an instance variable, but\n    // it's hard to route there otherwise.\n    open = 0) {\n        super();\n        this.widget = widget;\n        this.length = length;\n        this.type = type;\n        this.open = open;\n        this.breakAfter = 0;\n    }\n    merge(from, to, source) {\n        if (!(source instanceof BlockWidgetView) || !source.open ||\n            from > 0 && !(source.open & 1 /* Start */) ||\n            to < this.length && !(source.open & 2 /* End */))\n            return false;\n        if (!this.widget.compare(source.widget))\n            throw new Error(\"Trying to merge an open widget with an incompatible node\");\n        this.length = from + source.length + (this.length - to);\n        return true;\n    }\n    domAtPos(pos) {\n        return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);\n    }\n    split(at) {\n        let len = this.length - at;\n        this.length = at;\n        return new BlockWidgetView(this.widget, len, this.type);\n    }\n    get children() { return none$2; }\n    sync() {\n        if (!this.dom || !this.widget.updateDOM(this.dom)) {\n            this.setDOM(this.widget.toDOM(this.editorView));\n            this.dom.contentEditable = \"false\";\n        }\n    }\n    get overrideDOMText() {\n        return this.parent ? this.parent.state.doc.sliceLines(this.posAtStart, this.posAtEnd) : [\"\"];\n    }\n    domBoundsAround() { return null; }\n    match(other) {\n        if (other instanceof BlockWidgetView && other.type == this.type &&\n            other.widget.constructor == this.widget.constructor) {\n            if (!other.widget.eq(this.widget.value))\n                this.markDirty(true);\n            this.widget = other.widget;\n            this.length = other.length;\n            this.breakAfter = other.breakAfter;\n            return true;\n        }\n        return false;\n    }\n}\n\nclass ContentBuilder {\n    constructor(doc, pos, end) {\n        this.doc = doc;\n        this.pos = pos;\n        this.end = end;\n        this.content = [];\n        this.curLine = null;\n        this.breakAtStart = 0;\n        this.text = \"\";\n        this.textOff = 0;\n        this.cursor = doc.iter();\n        this.skip = pos;\n    }\n    posCovered() {\n        if (this.content.length == 0)\n            return !this.breakAtStart && this.doc.lineAt(this.pos).start != this.pos;\n        let last = this.content[this.content.length - 1];\n        return !last.breakAfter && !(last instanceof BlockWidgetView && last.type == BlockType.WidgetBefore);\n    }\n    getLine() {\n        if (!this.curLine)\n            this.content.push(this.curLine = new LineView);\n        return this.curLine;\n    }\n    addWidget(view) {\n        this.curLine = null;\n        this.content.push(view);\n    }\n    finish() {\n        if (!this.posCovered())\n            this.getLine();\n    }\n    buildText(length, tagName, clss, attrs, ranges) {\n        while (length > 0) {\n            if (this.textOff == this.text.length) {\n                let { value, lineBreak, done } = this.cursor.next(this.skip);\n                this.skip = 0;\n                if (done)\n                    throw new Error(\"Ran out of text content when drawing inline views\");\n                if (lineBreak) {\n                    if (!this.posCovered())\n                        this.getLine();\n                    if (this.content.length)\n                        this.content[this.content.length - 1].breakAfter = 1;\n                    else\n                        this.breakAtStart = 1;\n                    this.curLine = null;\n                    length--;\n                    continue;\n                }\n                else {\n                    this.text = value;\n                    this.textOff = 0;\n                }\n            }\n            let take = Math.min(this.text.length - this.textOff, length);\n            this.getLine().append(new TextView(this.text.slice(this.textOff, this.textOff + take), tagName, clss, attrs));\n            length -= take;\n            this.textOff += take;\n        }\n    }\n    span(from, to, active) {\n        let tagName = null, clss = null;\n        let attrs = null;\n        for (let { spec } of active) {\n            if (spec.tagName)\n                tagName = spec.tagName;\n            if (spec.class)\n                clss = clss ? clss + \" \" + spec.class : spec.class;\n            if (spec.attributes)\n                for (let name in spec.attributes) {\n                    let value = spec.attributes[name];\n                    if (value == null)\n                        continue;\n                    if (name == \"class\") {\n                        clss = clss ? clss + \" \" + value : value;\n                    }\n                    else {\n                        if (!attrs)\n                            attrs = {};\n                        if (name == \"style\" && attrs.style)\n                            value = attrs.style + \";\" + value;\n                        attrs[name] = value;\n                    }\n                }\n        }\n        this.buildText(to - from, tagName, clss, attrs, active);\n        this.pos = to;\n    }\n    point(from, to, deco, openStart, openEnd) {\n        let open = (openStart ? 1 /* Start */ : 0) | (openEnd ? 2 /* End */ : 0);\n        let len = to - from;\n        if (deco instanceof PointDecoration) {\n            if (deco.block) {\n                let { type } = deco;\n                if (type == BlockType.WidgetAfter && !this.posCovered())\n                    this.getLine();\n                this.addWidget(new BlockWidgetView(deco.widget || new NullWidget(\"div\"), len, type, open));\n            }\n            else {\n                this.getLine().append(WidgetView.create(deco.widget || new NullWidget(\"span\"), len, deco.startSide, open));\n            }\n        }\n        else if (this.doc.lineAt(this.pos).start == this.pos) { // Line decoration\n            this.getLine().addLineDeco(deco);\n        }\n        if (len) {\n            // Advance the iterator past the replaced content\n            if (this.textOff + len <= this.text.length) {\n                this.textOff += len;\n            }\n            else {\n                this.skip += len - (this.text.length - this.textOff);\n                this.text = \"\";\n                this.textOff = 0;\n            }\n            this.pos = to;\n        }\n    }\n    ignore() { return false; }\n    static build(text, from, to, decorations) {\n        let builder = new ContentBuilder(text, from, to);\n        _rangeset__WEBPACK_IMPORTED_MODULE_2__[\"RangeSet\"].iterateSpans(decorations, from, to, builder);\n        builder.finish();\n        return builder;\n    }\n}\nclass NullWidget extends WidgetType {\n    toDOM() { return document.createElement(this.value); }\n    updateDOM(elt) { return elt.nodeName.toLowerCase() == this.value; }\n}\n\nconst wrappingWhiteSpace = [\"pre-wrap\", \"normal\", \"pre-line\"];\nclass HeightOracle {\n    constructor() {\n        this.doc = _text__WEBPACK_IMPORTED_MODULE_3__[\"Text\"].empty;\n        this.lineWrapping = false;\n        this.heightSamples = {};\n        this.lineHeight = 14;\n        this.charWidth = 7;\n        this.lineLength = 30;\n        // Used to track, during updateHeight, if any actual heights changed\n        this.heightChanged = false;\n    }\n    heightForGap(from, to) {\n        let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;\n        if (this.lineWrapping)\n            lines += Math.ceil(((to - from) - (lines * this.lineLength * 0.5)) / this.lineLength);\n        return this.lineHeight * lines;\n    }\n    heightForLine(length) {\n        if (!this.lineWrapping)\n            return this.lineHeight;\n        let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));\n        return lines * this.lineHeight;\n    }\n    setDoc(doc) { this.doc = doc; return this; }\n    mustRefresh(lineHeights) {\n        let newHeight = false;\n        for (let i = 0; i < lineHeights.length; i++) {\n            let h = lineHeights[i];\n            if (h < 0) {\n                i++;\n            }\n            else if (!this.heightSamples[Math.floor(h * 10)]) { // Round to .1 pixels\n                newHeight = true;\n                this.heightSamples[Math.floor(h * 10)] = true;\n            }\n        }\n        return newHeight;\n    }\n    refresh(whiteSpace, lineHeight, charWidth, lineLength, knownHeights) {\n        let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;\n        let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;\n        this.lineWrapping = lineWrapping;\n        this.lineHeight = lineHeight;\n        this.charWidth = charWidth;\n        this.lineLength = lineLength;\n        if (changed) {\n            this.heightSamples = {};\n            for (let i = 0; i < knownHeights.length; i++) {\n                let h = knownHeights[i];\n                if (h < 0)\n                    i++;\n                else\n                    this.heightSamples[Math.floor(h * 10)] = true;\n            }\n        }\n        return changed;\n    }\n}\n// This object is used by `updateHeight` to make DOM measurements\n// arrive at the right nides. The `heights` array is a sequence of\n// block heights, starting from position `from`.\nclass MeasuredHeights {\n    constructor(from, heights) {\n        this.from = from;\n        this.heights = heights;\n        this.index = 0;\n    }\n    get more() { return this.index < this.heights.length; }\n}\n/// Record used to represent information about a block-level element\n/// in the editor view.\nclass BlockInfo {\n    /// @internal\n    constructor(\n    /// The start of the element in the document.\n    from, \n    /// The length of the element.\n    length, \n    /// The top position of the element.\n    top, \n    /// Its height.\n    height, \n    /// The type of element this is. When querying lines, this may be\n    /// an array of all the blocks that make up the line.\n    type) {\n        this.from = from;\n        this.length = length;\n        this.top = top;\n        this.height = height;\n        this.type = type;\n    }\n    /// The end of the element as a document position.\n    get to() { return this.from + this.length; }\n    /// The bottom position of the element.\n    get bottom() { return this.top + this.height; }\n    /// @internal\n    join(other) {\n        let detail = (Array.isArray(this.type) ? this.type : [this])\n            .concat(Array.isArray(other.type) ? other.type : [other]);\n        return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, detail);\n    }\n}\nvar QueryType;\n(function (QueryType) {\n    QueryType[QueryType[\"ByPos\"] = 0] = \"ByPos\";\n    QueryType[QueryType[\"ByHeight\"] = 1] = \"ByHeight\";\n    QueryType[QueryType[\"ByPosNoHeight\"] = 2] = \"ByPosNoHeight\";\n})(QueryType || (QueryType = {}));\nclass HeightMap {\n    constructor(length, // The number of characters covered\n    height, // Height of this part of the document\n    flags = 2 /* Outdated */) {\n        this.length = length;\n        this.height = height;\n        this.flags = flags;\n    }\n    get outdated() { return (this.flags & 2 /* Outdated */) > 0; }\n    set outdated(value) { this.flags = (value ? 2 /* Outdated */ : 0) | (this.flags & ~2 /* Outdated */); }\n    setHeight(oracle, height) {\n        if (this.height != height) {\n            this.height = height;\n            oracle.heightChanged = true;\n        }\n    }\n    // Base case is to replace a leaf node, which simply builds a tree\n    // from the new nodes and returns that (HeightMapBranch and\n    // HeightMapGap override this to actually use from/to)\n    replace(from, to, nodes) {\n        return HeightMap.of(nodes);\n    }\n    // Again, these are base cases, and are overridden for branch and gap nodes.\n    decomposeLeft(to, result) { result.push(this); }\n    decomposeRight(from, result) { result.push(this); }\n    applyChanges(decorations, oldDoc, oracle, changes) {\n        let me = this;\n        for (let i = changes.length - 1; i >= 0; i--) {\n            let { fromA, toA, fromB, toB } = changes[i];\n            let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);\n            let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oldDoc, 0, 0);\n            toB += end.to - toA;\n            toA = end.to;\n            while (i > 0 && start.from <= changes[i - 1].toA) {\n                fromA = changes[i - 1].fromA;\n                fromB = changes[i - 1].fromB;\n                i--;\n                if (fromA < start.from)\n                    start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);\n            }\n            fromB += start.from - fromA;\n            fromA = start.from;\n            let nodes = NodeBuilder.build(oracle, decorations, fromB, toB);\n            me = me.replace(fromA, toA, nodes);\n        }\n        return me.updateHeight(oracle, 0);\n    }\n    static empty() { return new HeightMapText(0, 0); }\n    // nodes uses null values to indicate the position of line breaks.\n    // There are never line breaks at the start or end of the array, or\n    // two line breaks next to each other, and the array isn't allowed\n    // to be empty (same restrictions as return value from the builder).\n    static of(nodes) {\n        if (nodes.length == 1)\n            return nodes[0];\n        let i = 0, j = nodes.length, before = 0, after = 0;\n        for (;;) {\n            if (i == j) {\n                if (before > after * 2) {\n                    let split = nodes[i - 1];\n                    if (split.break)\n                        nodes.splice(--i, 1, split.left, null, split.right);\n                    else\n                        nodes.splice(--i, 1, split.left, split.right);\n                    j += 1 + split.break;\n                    before -= split.size;\n                }\n                else if (after > before * 2) {\n                    let split = nodes[j];\n                    if (split.break)\n                        nodes.splice(j, 1, split.left, null, split.right);\n                    else\n                        nodes.splice(j, 1, split.left, split.right);\n                    j += 2 + split.break;\n                    after -= split.size;\n                }\n                else {\n                    break;\n                }\n            }\n            else if (before < after) {\n                let next = nodes[i++];\n                if (next)\n                    before += next.size;\n            }\n            else {\n                let next = nodes[--j];\n                if (next)\n                    after += next.size;\n            }\n        }\n        let brk = 0;\n        if (nodes[i - 1] == null) {\n            brk = 1;\n            i--;\n        }\n        else if (nodes[i] == null) {\n            brk = 1;\n            j++;\n        }\n        return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));\n    }\n}\nHeightMap.prototype.size = 1;\nclass HeightMapBlock extends HeightMap {\n    constructor(length, height, type) {\n        super(length, height);\n        this.type = type;\n    }\n    blockAt(height, doc, top, offset) {\n        return new BlockInfo(offset, this.length, top, this.height, this.type);\n    }\n    lineAt(value, type, doc, top, offset) {\n        return this.blockAt(0, doc, top, offset);\n    }\n    forEachLine(from, to, doc, top, offset, f) {\n        f(this.blockAt(0, doc, top, offset));\n    }\n    updateHeight(oracle, offset = 0, force = false, measured) {\n        if (measured && measured.from <= offset && measured.more)\n            this.setHeight(oracle, measured.heights[measured.index++]);\n        this.outdated = false;\n        return this;\n    }\n    toString() { return `block(${this.length})`; }\n}\nclass HeightMapText extends HeightMapBlock {\n    constructor(length, height) {\n        super(length, height, BlockType.Text);\n        this.collapsed = 0; // Amount of collapsed content in the line\n        this.widgetHeight = 0; // Maximum inline widget height\n    }\n    replace(from, to, nodes) {\n        if (nodes.length == 1 && nodes[0] instanceof HeightMapText && Math.abs(this.length - nodes[0].length) < 10) {\n            nodes[0].height = this.height;\n            return nodes[0];\n        }\n        else {\n            return HeightMap.of(nodes);\n        }\n    }\n    updateHeight(oracle, offset = 0, force = false, measured) {\n        if (measured && measured.from <= offset && measured.more)\n            this.setHeight(oracle, measured.heights[measured.index++]);\n        else if (force || this.outdated)\n            this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)));\n        this.outdated = false;\n        return this;\n    }\n    toString() {\n        return `line(${this.length}${this.collapsed ? -this.collapsed : \"\"}${this.widgetHeight ? \":\" + this.widgetHeight : \"\"})`;\n    }\n}\nclass HeightMapGap extends HeightMap {\n    constructor(length) { super(length, 0); }\n    lines(doc, offset) {\n        let firstLine = doc.lineAt(offset).number, lastLine = doc.lineAt(offset + this.length).number;\n        return { firstLine, lastLine, lineHeight: this.height / (lastLine - firstLine + 1) };\n    }\n    blockAt(height, doc, top, offset) {\n        let { firstLine, lastLine, lineHeight } = this.lines(doc, offset);\n        let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top) / lineHeight)));\n        let { start, length } = doc.line(firstLine + line);\n        return new BlockInfo(start, length, top + lineHeight * line, lineHeight, BlockType.Text);\n    }\n    lineAt(value, type, doc, top, offset) {\n        if (type == QueryType.ByHeight)\n            return this.blockAt(value, doc, top, offset);\n        if (type == QueryType.ByPosNoHeight) {\n            let { start, end } = doc.lineAt(value);\n            return new BlockInfo(start, end - start, 0, 0, BlockType.Text);\n        }\n        let { firstLine, lineHeight } = this.lines(doc, offset);\n        let { start, length, number } = doc.lineAt(value);\n        return new BlockInfo(start, length, top + lineHeight * (number - firstLine), lineHeight, BlockType.Text);\n    }\n    forEachLine(from, to, doc, top, offset, f) {\n        let { firstLine, lastLine, lineHeight } = this.lines(doc, offset);\n        for (let line = firstLine; line <= lastLine; line++) {\n            let { start, end } = doc.line(line);\n            if (start > to)\n                break;\n            if (end >= from)\n                f(new BlockInfo(start, end - start, top, top += lineHeight, BlockType.Text));\n        }\n    }\n    replace(from, to, nodes) {\n        let after = this.length - to;\n        if (after > 0) {\n            let last = nodes[nodes.length - 1];\n            if (last instanceof HeightMapGap)\n                nodes[nodes.length - 1] = new HeightMapGap(last.length + after);\n            else\n                nodes.push(null, new HeightMapGap(after - 1));\n        }\n        if (from > 0) {\n            let first = nodes[0];\n            if (first instanceof HeightMapGap)\n                nodes[0] = new HeightMapGap(from + first.length);\n            else\n                nodes.unshift(new HeightMapGap(from - 1), null);\n        }\n        return HeightMap.of(nodes);\n    }\n    decomposeLeft(to, result) {\n        result.push(to == this.length ? this : new HeightMapGap(to));\n    }\n    decomposeRight(from, result) {\n        result.push(from == 0 ? this : new HeightMapGap(this.length - from));\n    }\n    updateHeight(oracle, offset = 0, force = false, measured) {\n        let end = offset + this.length;\n        if (measured && measured.from <= offset + this.length && measured.more) {\n            // Fill in part of this gap with measured lines. We know there\n            // can't be widgets or collapsed ranges in those lines, because\n            // they would already have been added to the heightmap (gaps\n            // only contain plain text).\n            let nodes = [], pos = Math.max(offset, measured.from);\n            if (measured.from > offset)\n                nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));\n            while (pos <= end && measured.more) {\n                let len = oracle.doc.lineAt(pos).length;\n                if (nodes.length)\n                    nodes.push(null);\n                let line = new HeightMapText(len, measured.heights[measured.index++]);\n                line.outdated = false;\n                nodes.push(line);\n                pos += len + 1;\n            }\n            if (pos <= end)\n                nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));\n            oracle.heightChanged = true;\n            return HeightMap.of(nodes);\n        }\n        else if (force || this.outdated) {\n            this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));\n            this.outdated = false;\n        }\n        return this;\n    }\n    toString() { return `gap(${this.length})`; }\n}\nclass HeightMapBranch extends HeightMap {\n    constructor(left, brk, right) {\n        super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 /* Outdated */ : 0));\n        this.left = left;\n        this.right = right;\n        this.size = left.size + right.size;\n    }\n    get break() { return this.flags & 1 /* Break */; }\n    blockAt(height, doc, top, offset) {\n        let mid = top + this.left.height;\n        return height < mid || this.right.height == 0 ? this.left.blockAt(height, doc, top, offset)\n            : this.right.blockAt(height, doc, mid, offset + this.left.length + this.break);\n    }\n    lineAt(value, type, doc, top, offset) {\n        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;\n        let left = type == QueryType.ByHeight ? value < rightTop || this.right.height == 0 : value < rightOffset;\n        let base = left ? this.left.lineAt(value, type, doc, top, offset)\n            : this.right.lineAt(value, type, doc, rightTop, rightOffset);\n        if (this.break || (left ? base.to < rightOffset : base.from > rightOffset))\n            return base;\n        let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;\n        if (left)\n            return base.join(this.right.lineAt(rightOffset, subQuery, doc, rightTop, rightOffset));\n        else\n            return this.left.lineAt(rightOffset, subQuery, doc, top, offset).join(base);\n    }\n    forEachLine(from, to, doc, top, offset, f) {\n        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;\n        if (this.break) {\n            if (from < rightOffset)\n                this.left.forEachLine(from, to, doc, top, offset, f);\n            if (to >= rightOffset)\n                this.right.forEachLine(from, to, doc, rightTop, rightOffset, f);\n        }\n        else {\n            let mid = this.lineAt(rightOffset, QueryType.ByPos, doc, top, offset);\n            if (from < mid.from)\n                this.left.forEachLine(from, mid.from - 1, doc, top, offset, f);\n            if (mid.to >= from && mid.from <= to)\n                f(mid);\n            if (to > mid.to)\n                this.right.forEachLine(mid.to + 1, to, doc, rightTop, rightOffset, f);\n        }\n    }\n    replace(from, to, nodes) {\n        let rightStart = this.left.length + this.break;\n        if (to < rightStart)\n            return this.balanced(this.left.replace(from, to, nodes), this.right);\n        if (from > this.left.length)\n            return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));\n        let result = [];\n        if (from > 0)\n            this.decomposeLeft(from, result);\n        let left = result.length;\n        for (let node of nodes)\n            result.push(node);\n        if (from > 0)\n            mergeGaps(result, left - 1);\n        if (to < this.length) {\n            let right = result.length;\n            this.decomposeRight(to, result);\n            mergeGaps(result, right);\n        }\n        return HeightMap.of(result);\n    }\n    decomposeLeft(to, result) {\n        let left = this.left.length;\n        if (to <= left)\n            return this.left.decomposeLeft(to, result);\n        result.push(this.left);\n        if (this.break) {\n            left++;\n            if (to >= left)\n                result.push(null);\n        }\n        if (to > left)\n            this.right.decomposeLeft(to - left, result);\n    }\n    decomposeRight(from, result) {\n        let left = this.left.length, right = left + this.break;\n        if (from >= right)\n            return this.right.decomposeRight(from - right, result);\n        if (from < left)\n            this.left.decomposeRight(from, result);\n        if (this.break && from < right)\n            result.push(null);\n        result.push(this.right);\n    }\n    balanced(left, right) {\n        if (left.size > 2 * right.size || right.size > 2 * left.size)\n            return HeightMap.of(this.break ? [left, null, right] : [left, right]);\n        this.left = left;\n        this.right = right;\n        this.height = left.height + right.height;\n        this.outdated = left.outdated || right.outdated;\n        this.size = left.size + right.size;\n        this.length = left.length + this.break + right.length;\n        return this;\n    }\n    updateHeight(oracle, offset = 0, force = false, measured) {\n        let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;\n        if (measured && measured.from <= offset + left.length && measured.more)\n            rebalance = left = left.updateHeight(oracle, offset, force, measured);\n        else\n            left.updateHeight(oracle, offset, force);\n        if (measured && measured.from <= rightStart + right.length && measured.more)\n            rebalance = right = right.updateHeight(oracle, rightStart, force, measured);\n        else\n            right.updateHeight(oracle, rightStart, force);\n        if (rebalance)\n            return this.balanced(left, right);\n        this.height = this.left.height + this.right.height;\n        this.outdated = false;\n        return this;\n    }\n    toString() { return this.left + (this.break ? \" \" : \"-\") + this.right; }\n}\nfunction mergeGaps(nodes, around) {\n    let before, after;\n    if (nodes[around] == null &&\n        (before = nodes[around - 1]) instanceof HeightMapGap &&\n        (after = nodes[around + 1]) instanceof HeightMapGap)\n        nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));\n}\nconst relevantWidgetHeight = 5;\nclass NodeBuilder {\n    constructor(pos, oracle) {\n        this.pos = pos;\n        this.oracle = oracle;\n        this.nodes = [];\n        this.lineStart = -1;\n        this.lineEnd = -1;\n        this.covering = null;\n        this.writtenTo = pos;\n    }\n    get isCovered() {\n        return this.covering && this.nodes[this.nodes.length - 1] == this.covering;\n    }\n    span(from, to) {\n        if (this.lineStart > -1) {\n            let end = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];\n            if (last instanceof HeightMapText)\n                last.length += end - this.pos;\n            else if (end > this.pos || !this.isCovered)\n                this.nodes.push(new HeightMapText(end - this.pos, -1));\n            this.writtenTo = end;\n            if (to > end) {\n                this.nodes.push(null);\n                this.writtenTo++;\n                this.lineStart = -1;\n            }\n        }\n        this.pos = to;\n    }\n    point(from, to, deco) {\n        let height = deco.widget ? Math.max(0, deco.widget.estimatedHeight) : 0;\n        let len = to - from;\n        if (deco.block) {\n            this.addBlock(new HeightMapBlock(len, height, deco.type));\n        }\n        else if (len || height >= relevantWidgetHeight) {\n            this.addLineDeco(height, len);\n        }\n        if (this.lineEnd > -1 && this.lineEnd < this.pos)\n            this.lineEnd = this.oracle.doc.lineAt(this.pos).end;\n    }\n    enterLine() {\n        if (this.lineStart > -1)\n            return;\n        let { start, end } = this.oracle.doc.lineAt(this.pos);\n        this.lineStart = start;\n        this.lineEnd = end;\n        if (this.writtenTo < start) {\n            if (this.writtenTo < start - 1 || this.nodes[this.nodes.length - 1] == null)\n                this.nodes.push(new HeightMapGap(start - this.writtenTo - 1));\n            this.nodes.push(null);\n        }\n        if (this.pos > start)\n            this.nodes.push(new HeightMapText(this.pos - start, -1));\n        this.writtenTo = this.pos;\n    }\n    ensureLine() {\n        this.enterLine();\n        let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;\n        if (last instanceof HeightMapText)\n            return last;\n        let line = new HeightMapText(0, -1);\n        this.nodes.push(line);\n        return line;\n    }\n    addBlock(block) {\n        this.enterLine();\n        if (block.type == BlockType.WidgetAfter && !this.isCovered)\n            this.ensureLine();\n        this.nodes.push(block);\n        this.writtenTo = this.pos = this.pos + block.length;\n        if (block.type != BlockType.WidgetBefore)\n            this.covering = block;\n    }\n    addLineDeco(height, length) {\n        let line = this.ensureLine();\n        line.length += length;\n        line.collapsed += length;\n        line.widgetHeight = Math.max(line.widgetHeight, height);\n        this.writtenTo = this.pos = this.pos + length;\n    }\n    finish(from) {\n        let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];\n        if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered)\n            this.nodes.push(new HeightMapText(0, -1));\n        else if (this.writtenTo < this.pos || last == null)\n            this.nodes.push(new HeightMapGap(this.pos - this.writtenTo));\n        let pos = from;\n        for (let node of this.nodes) {\n            if (node instanceof HeightMapText)\n                node.updateHeight(this.oracle, pos);\n            pos += node ? node.length : 1;\n        }\n        return this.nodes;\n    }\n    ignore(from, to, value) { return from == to && !value.heightRelevant; }\n    // Always called with a region that on both sides either stretches\n    // to a line break or the end of the document.\n    // The returned array uses null to indicate line breaks, but never\n    // starts or ends in a line break, or has multiple line breaks next\n    // to each other.\n    static build(oracle, decorations, from, to) {\n        let builder = new NodeBuilder(from, oracle);\n        _rangeset__WEBPACK_IMPORTED_MODULE_2__[\"RangeSet\"].iterateSpans(decorations, from, to, builder);\n        return builder.finish(from);\n    }\n}\n\nfunction visiblePixelRange(dom, paddingTop) {\n    let rect = dom.getBoundingClientRect();\n    let top = Math.max(0, Math.min(innerHeight, rect.top)), bottom = Math.max(0, Math.min(innerHeight, rect.bottom));\n    for (let parent = dom.parentNode; parent;) { // (Cast to any because TypeScript is useless with Node types)\n        if (parent.nodeType == 1) {\n            if (parent.scrollHeight > parent.clientHeight) {\n                let parentRect = parent.getBoundingClientRect();\n                top = Math.min(parentRect.bottom, Math.max(parentRect.top, top));\n                bottom = Math.min(parentRect.bottom, Math.max(parentRect.top, bottom));\n            }\n            parent = parent.parentNode;\n        }\n        else if (parent.nodeType == 11) { // Shadow root\n            parent = parent.host;\n        }\n        else {\n            break;\n        }\n    }\n    return { top: top - (rect.top + paddingTop), bottom: bottom - (rect.top + paddingTop) };\n}\nconst VIEWPORT_MARGIN = 1000; // FIXME look into appropriate value of this through benchmarking etc\nconst MIN_COVER_MARGIN = 10; // coveredBy requires at least this many extra pixels to be covered\nconst MAX_COVER_MARGIN = VIEWPORT_MARGIN / 4;\nclass ViewportState {\n    constructor() {\n        // These are contentDOM-local coordinates\n        this.top = 0;\n        this.bottom = 0;\n    }\n    updateFromDOM(dom, paddingTop) {\n        let { top, bottom } = visiblePixelRange(dom, paddingTop);\n        let dTop = top - this.top, dBottom = bottom - this.bottom, bias = 0;\n        if (dTop > 0 && dBottom > 0)\n            bias = Math.max(dTop, dBottom);\n        else if (dTop < 0 && dBottom < 0)\n            bias = Math.min(dTop, dBottom);\n        this.top = top;\n        this.bottom = bottom;\n        return bias;\n    }\n    coverEverything() {\n        this.top = -1e9;\n        this.bottom = 1e9;\n    }\n    getViewport(doc, heightMap, bias, scrollTo) {\n        // This will divide VIEWPORT_MARGIN between the top and the\n        // bottom, depending on the bias (the change in viewport position\n        // since the last update). It'll hold a number between 0 and 1\n        let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / VIEWPORT_MARGIN / 2));\n        let viewport = new Viewport(heightMap.lineAt(this.top - marginTop * VIEWPORT_MARGIN, QueryType.ByHeight, doc, 0, 0).from, heightMap.lineAt(this.bottom + (1 - marginTop) * VIEWPORT_MARGIN, QueryType.ByHeight, doc, 0, 0).to);\n        // If scrollTo is > -1, make sure the viewport includes that position\n        if (scrollTo > -1) {\n            if (scrollTo < viewport.from) {\n                let { top } = heightMap.lineAt(scrollTo, QueryType.ByPos, doc, 0, 0);\n                viewport = new Viewport(heightMap.lineAt(top - VIEWPORT_MARGIN / 2, QueryType.ByHeight, doc, 0, 0).from, heightMap.lineAt(top + (this.bottom - this.top) + VIEWPORT_MARGIN / 2, QueryType.ByHeight, doc, 0, 0).to);\n            }\n            else if (scrollTo > viewport.to) {\n                let { bottom } = heightMap.lineAt(scrollTo, QueryType.ByPos, doc, 0, 0);\n                viewport = new Viewport(heightMap.lineAt(bottom - (this.bottom - this.top) - VIEWPORT_MARGIN / 2, QueryType.ByHeight, doc, 0, 0).from, heightMap.lineAt(bottom + VIEWPORT_MARGIN / 2, QueryType.ByHeight, doc, 0, 0).to);\n            }\n        }\n        return viewport;\n    }\n    coveredBy(doc, viewport, heightMap, bias = 0) {\n        let { top } = heightMap.lineAt(viewport.from, QueryType.ByPos, doc, 0, 0);\n        let { bottom } = heightMap.lineAt(viewport.to, QueryType.ByPos, doc, 0, 0);\n        return (viewport.from == 0 || top <= this.top - Math.max(MIN_COVER_MARGIN, Math.min(-bias, MAX_COVER_MARGIN))) &&\n            (viewport.to == doc.length || bottom >= this.bottom + Math.max(MIN_COVER_MARGIN, Math.min(bias, MAX_COVER_MARGIN)));\n    }\n}\n/// Indicates the range of the document that is in the visible\n/// viewport.\nclass Viewport {\n    constructor(from, to) {\n        this.from = from;\n        this.to = to;\n    }\n    clip(pos) { return Math.max(this.from, Math.min(this.to, pos)); }\n    eq(b) { return this.from == b.from && this.to == b.to; }\n}\n\nconst observeOptions = {\n    childList: true,\n    characterData: true,\n    subtree: true,\n    characterDataOldValue: true\n};\n// IE11 has very broken mutation observers, so we also listen to\n// DOMCharacterDataModified there\nconst useCharData = browser.ie && browser.ie_version <= 11;\nclass DOMObserver {\n    constructor(docView, onChange, onScrollChanged) {\n        this.docView = docView;\n        this.onChange = onChange;\n        this.onScrollChanged = onScrollChanged;\n        this.active = false;\n        this.ignoreSelection = new DOMSelection;\n        this.charDataQueue = [];\n        this.charDataTimeout = null;\n        this.scrollTargets = [];\n        this.intersection = null;\n        this.intersecting = false;\n        this.dom = docView.dom;\n        this.observer = new MutationObserver(mutations => this.flush(mutations));\n        if (useCharData)\n            this.onCharData = (event) => {\n                this.charDataQueue.push({ target: event.target,\n                    type: \"characterData\",\n                    oldValue: event.prevValue });\n                if (this.charDataTimeout == null)\n                    this.charDataTimeout = setTimeout(() => this.flush(), 20);\n            };\n        this.onSelectionChange = () => {\n            if (this.docView.root.activeElement == this.dom)\n                this.flush();\n        };\n        this.start();\n        this.onScroll = this.onScroll.bind(this);\n        window.addEventListener(\"scroll\", this.onScroll);\n        if (typeof IntersectionObserver == \"function\") {\n            this.intersection = new IntersectionObserver(entries => {\n                if (entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {\n                    this.intersecting = !this.intersecting;\n                    this.onScroll();\n                }\n            }, {});\n            this.intersection.observe(this.dom);\n        }\n        this.listenForScroll();\n    }\n    onScroll() {\n        if (this.intersecting) {\n            this.flush();\n            this.onScrollChanged();\n        }\n    }\n    listenForScroll() {\n        let i = 0, changed = null;\n        for (let dom = this.dom; dom;) {\n            if (dom.nodeType == 1) {\n                if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom)\n                    i++;\n                else if (!changed)\n                    changed = this.scrollTargets.slice(0, i);\n                if (changed)\n                    changed.push(dom);\n                dom = dom.parentNode;\n            }\n            else if (dom.nodeType == 11) { // Shadow root\n                dom = dom.host;\n            }\n            else {\n                break;\n            }\n        }\n        if (i < this.scrollTargets.length && !changed)\n            changed = this.scrollTargets.slice(0, i);\n        if (changed) {\n            for (let dom of this.scrollTargets)\n                dom.removeEventListener(\"scroll\", this.onScroll);\n            for (let dom of this.scrollTargets = changed)\n                dom.addEventListener(\"scroll\", this.onScroll);\n        }\n    }\n    ignore(f) {\n        if (!this.active)\n            return f();\n        try {\n            this.stop();\n            return f();\n        }\n        finally {\n            this.start();\n            this.clear();\n        }\n    }\n    start() {\n        if (this.active)\n            return;\n        this.observer.observe(this.dom, observeOptions);\n        // FIXME is this shadow-root safe?\n        this.dom.ownerDocument.addEventListener(\"selectionchange\", this.onSelectionChange);\n        if (useCharData)\n            this.dom.addEventListener(\"DOMCharacterDataModified\", this.onCharData);\n        this.active = true;\n    }\n    stop() {\n        if (!this.active)\n            return;\n        this.active = false;\n        this.observer.disconnect();\n        this.dom.ownerDocument.removeEventListener(\"selectionchange\", this.onSelectionChange);\n        if (useCharData)\n            this.dom.removeEventListener(\"DOMCharacterDataModified\", this.onCharData);\n    }\n    takeCharRecords() {\n        let result = this.charDataQueue;\n        if (result.length) {\n            this.charDataQueue = [];\n            clearTimeout(this.charDataTimeout);\n            this.charDataTimeout = null;\n        }\n        return result;\n    }\n    clearSelection() {\n        this.ignoreSelection.set(this.docView.root.getSelection());\n    }\n    // Throw away any pending changes\n    clear() {\n        this.observer.takeRecords();\n        this.takeCharRecords();\n        this.clearSelection();\n    }\n    // Apply pending changes, if any\n    flush(records = this.observer.takeRecords()) {\n        if (this.charDataQueue.length)\n            records = records.concat(this.takeCharRecords());\n        let selection = this.docView.root.getSelection();\n        let newSel = !this.ignoreSelection.eq(selection) && hasSelection(this.dom, selection);\n        if (records.length == 0 && !newSel)\n            return;\n        let from = -1, to = -1, typeOver = false;\n        for (let record of records) {\n            let range = this.readMutation(record);\n            if (!range)\n                continue;\n            if (range.typeOver)\n                typeOver = true;\n            if (from == -1) {\n                ({ from, to } = range);\n            }\n            else {\n                from = Math.min(range.from, from);\n                to = Math.max(range.to, to);\n            }\n        }\n        let apply = from > -1 || newSel;\n        if (!apply || !this.onChange(from, to, typeOver)) {\n            if (this.docView.dirty) {\n                this.ignore(() => this.docView.sync());\n                this.docView.dirty = 0 /* Not */;\n            }\n            this.docView.updateSelection();\n        }\n        this.clearSelection();\n    }\n    readMutation(rec) {\n        let cView = this.docView.nearest(rec.target);\n        if (!cView || cView.ignoreMutation(rec))\n            return null;\n        cView.markDirty();\n        if (rec.type == \"childList\") {\n            let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);\n            let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);\n            return { from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,\n                to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd, typeOver: false };\n        }\n        else { // \"characterData\"\n            return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };\n        }\n    }\n    destroy() {\n        this.stop();\n        if (this.intersection)\n            this.intersection.disconnect();\n        for (let dom of this.scrollTargets)\n            dom.removeEventListener(\"scroll\", this.onScroll);\n        window.removeEventListener(\"scroll\", this.onScroll);\n    }\n}\nfunction findChild(cView, dom, dir) {\n    while (dom) {\n        let curView = dom.cmView;\n        if (curView && curView.parent == cView)\n            return curView;\n        let parent = dom.parentNode;\n        dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;\n    }\n    return null;\n}\n\nconst none$3 = [];\nconst extendView = new _extension__WEBPACK_IMPORTED_MODULE_4__[\"ExtensionGroup\"](view => view.plugins);\nconst handleDOMEvents = extendView.behavior();\nconst clickAddsSelectionRange = extendView.behavior();\nconst dragMovesSelection = extendView.behavior();\n/// View plugins associate stateful values with a view. They can\n/// influence the way the content is drawn, and are notified of things\n/// that happen in the view. They can be combined with [dynamic\n/// behavior](#extension.ExtensionGroup.dynamic) to\n/// [add](#view.EditorView^decorations)\n/// [decorations](#view.Decoration) to the view. Objects of this type\n/// serve as keys to [access](#view.EditorView.plugin) the value of\n/// the plugin.\nclass ViewPlugin {\n    constructor(\n    /// @internal\n    create, \n    /// @internal\n    id, \n    /// @internal\n    behaviorExtensions) {\n        this.create = create;\n        this.id = id;\n        this.behaviorExtensions = behaviorExtensions;\n        this.extension = [viewPlugin(this), ...this.behaviorExtensions];\n    }\n    /// Declare a plugin. The `create` function will be called while\n    /// initializing or reconfiguring an editor view to create the\n    /// actual plugin instance.\n    static create(create) {\n        return new ViewPlugin(create, extendView.storageID(), []);\n    }\n    /// Declare a behavior as a function of this plugin. `read` maps\n    /// from the plugin value to the behavior's input type.\n    behavior(behavior, read) {\n        return new ViewPlugin(this.create, this.id, this.behaviorExtensions.concat(extendView.dynamic(behavior, view => read(view.plugin(this)))));\n    }\n    /// Declare that this plugin provides [decorations](#view.EditorView^decorations).\n    decorations(read) {\n        return this.behavior(decorations, read);\n    }\n    /// Create a view plugin extension that only computes decorations.\n    static decoration(spec) {\n        return ViewPlugin.create(view => new DecorationPlugin(view, spec)).decorations(p => p.decorations).extension;\n    }\n}\nconst editorAttributes = extendView.behavior({\n    combine: values => values.reduce((a, b) => combineAttrs(b, a), {})\n});\nconst contentAttributes = extendView.behavior({\n    combine: values => values.reduce((a, b) => combineAttrs(b, a), {})\n});\n// Registers view plugins.\nconst viewPlugin = extendView.behavior({ static: true });\n// Provide decorations\nconst decorations = extendView.behavior();\nclass DecorationPlugin {\n    constructor(view, spec) {\n        this.spec = spec;\n        this.decorations = spec.create(view);\n    }\n    update(update) {\n        this.decorations = this.spec.update(this.spec.map ? this.decorations.map(update.changes) : this.decorations, update);\n    }\n}\nconst styleModule = extendView.behavior();\nconst theme = extendView.behavior();\nconst phrases = extendView.behavior();\nconst scrollMargins = extendView.behavior({\n    combine(rects) {\n        let result = { left: 0, top: 0, right: 0, bottom: 0 };\n        for (let r of rects) {\n            result.left = Math.max(result.left, r.left || 0);\n            result.top = Math.max(result.top, r.top || 0);\n            result.right = Math.max(result.right, r.right || 0);\n            result.bottom = Math.max(result.bottom, r.bottom || 0);\n        }\n        return result;\n    }\n});\nconst focusChange = _state__WEBPACK_IMPORTED_MODULE_0__[\"Annotation\"].define();\nconst notified = _state__WEBPACK_IMPORTED_MODULE_0__[\"Annotation\"].define();\n/// View [plugins](#view.ViewPlugin) are given instances of this\n/// class, which describe what happened, whenever the view is updated.\nclass ViewUpdate {\n    /// @internal\n    constructor(\n    /// The editor view that the update is associated with.\n    view, \n    /// The transactions involved in the update. May be empty.\n    transactions = none$3, \n    /// @internal\n    _annotations = none$3) {\n        this.view = view;\n        this.transactions = transactions;\n        this._annotations = _annotations;\n        this.state = transactions.length ? transactions[transactions.length - 1].apply() : view.state;\n        this.changes = transactions.reduce((chs, tr) => chs.appendSet(tr.changes), _state__WEBPACK_IMPORTED_MODULE_0__[\"ChangeSet\"].empty);\n        this.prevState = view.state;\n        this.prevViewport = view._viewport;\n        this.prevThemes = view.behavior(theme);\n    }\n    /// The new viewport range.\n    get viewport() { return this.view._viewport; }\n    /// Tells you whether the viewport changed in this update.\n    get viewportChanged() {\n        return !this.prevViewport.eq(this.view._viewport);\n    }\n    /// Whether the document changed in this update.\n    get docChanged() {\n        return this.transactions.some(tr => tr.docChanged);\n    }\n    /// Tells you whether the set of active [theme\n    /// extensions](#view.EditorView^theme) changed, which may require\n    /// plugins to update [CSS class names](#view.EditorView.cssClass)\n    /// on their DOM elements.\n    get themeChanged() {\n        return this.prevThemes != this.view.behavior(theme);\n    }\n    /// Get the value of the given annotation, if it was passed directly\n    /// for the update or present in any of the transactions involved in\n    /// the update.\n    annotation(type) {\n        for (let ann of this._annotations)\n            if (ann.type == type)\n                return ann.value;\n        for (let i = this.transactions.length - 1; i >= 0; i--) {\n            let value = this.transactions[i].annotation(type);\n            if (value !== undefined)\n                return value;\n        }\n        return undefined;\n    }\n    /// Get the values of all instances of the given annotation type\n    /// present in the transactions or passed directly to\n    /// [`update`](#view.EditorView.update).\n    annotations(type) {\n        let result = none$3;\n        for (let tr of this.transactions) {\n            let ann = tr.annotations(type);\n            if (ann.length)\n                result = result.concat(ann);\n        }\n        for (let ann of this._annotations) {\n            if (ann.type == type)\n                result = result.concat([ann.value]);\n        }\n        return result;\n    }\n}\n\nconst none$4 = [];\nclass DocView extends ContentView {\n    constructor(view, onDOMChange) {\n        super();\n        this.view = view;\n        this.viewports = none$4;\n        this.compositionDeco = Decoration.none;\n        this.gapDeco = Decoration.none;\n        this.selectionDirty = null;\n        this.forceSelectionUpdate = false;\n        this.heightMap = HeightMap.empty();\n        this.heightOracle = new HeightOracle;\n        this.layoutCheckScheduled = -1;\n        // A document position that has to be scrolled into view at the next layout check\n        this.scrollIntoView = -1;\n        this.paddingTop = 0;\n        this.paddingBottom = 0;\n        // Track a minimum width for the editor. When measuring sizes in\n        // checkLayout, this is updated to point at the width of a given\n        // element and its extent in the document. When a change happens in\n        // that range, these are reset. That way, once we've seen a\n        // line/element of a given length, we keep the editor wide enough to\n        // fit at least that element, until it is changed, at which point we\n        // forget it again.\n        this.minWidth = 0;\n        this.minWidthFrom = 0;\n        this.minWidthTo = 0;\n        // Track whether the DOM selection was set in a lossy way, so that\n        // we don't mess it up when reading it back it\n        this.impreciseAnchor = null;\n        this.impreciseHead = null;\n        this.setDOM(view.contentDOM);\n        this.viewportState = new ViewportState;\n        this.observer = new DOMObserver(this, onDOMChange, () => this.checkLayout());\n    }\n    get length() { return this.state.doc.length; }\n    get state() { return this.view.state; }\n    get viewport() { return this.view._viewport; }\n    get root() { return this.view.root; }\n    get editorView() { return this.view; }\n    init(state, initialize) {\n        this.children = [new LineView];\n        this.children[0].setParent(this);\n        this.viewports = this.decorations = none$4;\n        this.minWidth = 0;\n        this.compositionDeco = Decoration.none;\n        let changedRanges = [new _state__WEBPACK_IMPORTED_MODULE_0__[\"ChangedRange\"](0, 0, 0, state.doc.length)];\n        this.heightMap = this.heightMap.applyChanges(none$4, _text__WEBPACK_IMPORTED_MODULE_3__[\"Text\"].empty, this.heightOracle.setDoc(state.doc), changedRanges);\n        this.computeUpdate(state, state.doc, null, initialize, none$4, 0, -1);\n        this.updateInner(changedRanges, 0);\n        this.scheduleLayoutCheck();\n    }\n    // Update the document view to a given state. scrollIntoView can be\n    // used as a hint to compute a new viewport that includes that\n    // position, if we know the editor is going to scroll that position\n    // into view.\n    update(update, scrollIntoView = -1) {\n        let prevDoc = this.state.doc;\n        let state = update ? update.state : this.state;\n        let changedRanges = update ? update.changes.changedRanges() : none$4;\n        if (this.minWidth > 0 && changedRanges.length) {\n            if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {\n                this.minWidth = 0;\n            }\n            else {\n                this.minWidthFrom = _state__WEBPACK_IMPORTED_MODULE_0__[\"ChangedRange\"].mapPos(this.minWidthFrom, 1, changedRanges);\n                this.minWidthTo = _state__WEBPACK_IMPORTED_MODULE_0__[\"ChangedRange\"].mapPos(this.minWidthTo, 1, changedRanges);\n            }\n        }\n        let contentChanges = this.computeUpdate(state, prevDoc, update, null, changedRanges, 0, scrollIntoView);\n        // When the DOM nodes around the selection are moved to another\n        // parent, Chrome sometimes reports a different selection through\n        // getSelection than the one that it actually shows to the user.\n        // This forces a selection update when lines are joined to work\n        // around that. Issue #54\n        if (browser.chrome && !this.compositionDeco.size && update && update.changes.changes.some(ch => ch.text.length > 1))\n            this.forceSelectionUpdate = true;\n        if (this.dirty == 0 /* Not */ && contentChanges.length == 0 &&\n            this.state.selection.primary.from >= this.viewport.from &&\n            this.state.selection.primary.to <= this.viewport.to &&\n            (!update || update._annotations.length == 0)) {\n            this.updateSelection();\n            if (scrollIntoView > -1)\n                this.scrollPosIntoView(scrollIntoView);\n            if (update)\n                this.scheduleLayoutCheck();\n        }\n        else {\n            this.updateInner(contentChanges, prevDoc.length);\n            this.cancelLayoutCheck();\n            if (scrollIntoView > -1)\n                this.scrollIntoView = scrollIntoView;\n            this.scheduleLayoutCheck();\n        }\n    }\n    scheduleLayoutCheck() {\n        this.layoutCheckScheduled = requestAnimationFrame(() => this.checkLayout());\n    }\n    // Used both by update and checkLayout do perform the actual DOM\n    // update\n    updateInner(changes, oldLength) {\n        let visible = this.viewport, viewports = [visible];\n        let { head, anchor } = this.state.selection.primary;\n        if (head < visible.from || head > visible.to) {\n            let { from, to } = this.lineAt(head, 0);\n            viewports.push(new Viewport(from, to));\n        }\n        if (!viewports.some(({ from, to }) => anchor >= from && anchor <= to)) {\n            let { from, to } = this.lineAt(anchor, 0);\n            viewports.push(new Viewport(from, to));\n        }\n        viewports.sort((a, b) => a.from - b.from);\n        this.updateChildren(changes, viewports, oldLength);\n        this.viewports = viewports;\n        this.observer.ignore(() => {\n            // Lock the height during redrawing, since Chrome sometimes\n            // messes with the scroll position during DOM mutation (though\n            // no relayout is triggered and I cannot imagine how it can\n            // recompute the scroll position without a layout)\n            this.dom.style.height = this.heightMap.height + \"px\";\n            this.dom.style.minWidth = this.minWidth + \"px\";\n            this.sync();\n            this.dirty = 0 /* Not */;\n            this.updateSelection();\n            this.dom.style.height = \"\";\n        });\n    }\n    updateChildren(changes, viewports, oldLength) {\n        let gapDeco = this.computeGapDeco(viewports, this.length);\n        let gapChanges = findChangedRanges(this.gapDeco, gapDeco, changes, oldLength);\n        this.gapDeco = gapDeco;\n        changes = extendWithRanges(changes, gapChanges.content);\n        let allDeco = [gapDeco].concat(this.decorations);\n        let cursor = this.childCursor(oldLength);\n        for (let i = changes.length - 1;; i--) {\n            let next = i >= 0 ? changes[i] : null;\n            if (!next)\n                break;\n            let { fromA, toA, fromB, toB } = next;\n            let { content, breakAtStart } = ContentBuilder.build(this.state.doc, fromB, toB, allDeco);\n            let { i: toI, off: toOff } = cursor.findPos(toA, 1);\n            let { i: fromI, off: fromOff } = cursor.findPos(fromA, -1);\n            this.replaceRange(fromI, fromOff, toI, toOff, content, breakAtStart);\n        }\n    }\n    replaceRange(fromI, fromOff, toI, toOff, content, breakAtStart) {\n        let before = this.children[fromI], last = content.length ? content[content.length - 1] : null;\n        let breakAtEnd = last ? last.breakAfter : breakAtStart;\n        // Change within a single line\n        if (fromI == toI && !breakAtStart && !breakAtEnd && content.length < 2 &&\n            before.merge(fromOff, toOff, content.length ? last : null, fromOff == 0))\n            return;\n        let after = this.children[toI];\n        // Make sure the end of the line after the update is preserved in `after`\n        if (toOff < after.length || after.children.length && after.children[after.children.length - 1].length == 0) {\n            // If we're splitting a line, separate part of the start line to\n            // avoid that being mangled when updating the start line.\n            if (fromI == toI) {\n                after = after.split(toOff);\n                toOff = 0;\n            }\n            // If the element after the replacement should be merged with\n            // the last replacing element, update `content`\n            if (!breakAtEnd && last && after.merge(0, toOff, last, true)) {\n                content[content.length - 1] = after;\n            }\n            else {\n                // Remove the start of the after element, if necessary, and\n                // add it to `content`.\n                if (toOff || after.children.length && after.children[0].length == 0)\n                    after.merge(0, toOff, null, false);\n                content.push(after);\n            }\n        }\n        else if (after.breakAfter) {\n            // The element at `toI` is entirely covered by this range.\n            // Preserve its line break, if any.\n            if (last)\n                last.breakAfter = 1;\n            else\n                breakAtStart = 1;\n        }\n        // Since we've handled the next element from the current elements\n        // now, make sure `toI` points after that.\n        toI++;\n        before.breakAfter = breakAtStart;\n        if (fromOff > 0) {\n            if (!breakAtStart && content.length && before.merge(fromOff, before.length, content[0], false)) {\n                before.breakAfter = content.shift().breakAfter;\n            }\n            else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {\n                before.merge(fromOff, before.length, null, false);\n            }\n            fromI++;\n        }\n        // Try to merge widgets on the boundaries of the replacement\n        while (fromI < toI && content.length) {\n            if (this.children[toI - 1].match(content[content.length - 1]))\n                toI--, content.pop();\n            else if (this.children[fromI].match(content[0]))\n                fromI++, content.shift();\n            else\n                break;\n        }\n        if (fromI < toI || content.length)\n            this.replaceChildren(fromI, toI, content);\n    }\n    // Sync the DOM selection to this.state.selection\n    updateSelection(takeFocus = false) {\n        this.clearSelectionDirty();\n        if (this.root.activeElement != this.dom) {\n            if (!takeFocus)\n                return;\n            if (browser.gecko)\n                this.dom.focus(); // Avoids strange exceptions when setting the selection\n        }\n        let primary = this.state.selection.primary;\n        // FIXME need to handle the case where the selection falls inside a block range\n        let anchor = this.domAtPos(primary.anchor);\n        let head = this.domAtPos(primary.head);\n        let domSel = this.root.getSelection();\n        // If the selection is already here, or in an equivalent position, don't touch it\n        if (this.forceSelectionUpdate ||\n            !isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) ||\n            !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) {\n            this.forceSelectionUpdate = false;\n            this.observer.ignore(() => {\n                // Selection.extend can be used to create an 'inverted' selection\n                // (one where the focus is before the anchor), but not all\n                // browsers support it yet.\n                if (domSel.extend) {\n                    domSel.collapse(anchor.node, anchor.offset);\n                    if (!primary.empty)\n                        domSel.extend(head.node, head.offset);\n                }\n                else {\n                    let range = document.createRange();\n                    if (primary.anchor > primary.head)\n                        [anchor, head] = [head, anchor];\n                    range.setEnd(head.node, head.offset);\n                    range.setStart(anchor.node, anchor.offset);\n                    domSel.removeAllRanges();\n                    domSel.addRange(range);\n                }\n            });\n        }\n        this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);\n        this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);\n    }\n    lineAt(pos, editorTop) {\n        if (editorTop == null)\n            editorTop = this.dom.getBoundingClientRect().top;\n        return this.heightMap.lineAt(pos, QueryType.ByPos, this.state.doc, editorTop + this.paddingTop, 0);\n    }\n    lineAtHeight(height, editorTop) {\n        if (editorTop == null)\n            editorTop = this.dom.getBoundingClientRect().top;\n        return this.heightMap.lineAt(height, QueryType.ByHeight, this.state.doc, editorTop + this.paddingTop, 0);\n    }\n    blockAtHeight(height, editorTop) {\n        if (editorTop == null)\n            editorTop = this.dom.getBoundingClientRect().top;\n        return this.heightMap.blockAt(height, this.state.doc, editorTop + this.paddingTop, 0);\n    }\n    forEachLine(from, to, f, editorTop) {\n        if (editorTop == null)\n            editorTop = this.dom.getBoundingClientRect().top;\n        return this.heightMap.forEachLine(from, to, this.state.doc, editorTop + this.paddingTop, 0, f);\n    }\n    // Compute the new viewport and set of decorations, while giving\n    // plugin views the opportunity to respond to state and viewport\n    // changes. Might require more than one iteration to become stable.\n    computeUpdate(state, oldDoc, update, initializing, contentChanges, viewportBias, scrollIntoView) {\n        let invalidHeightMap = contentChanges.length ? contentChanges : null, prevViewport = this.viewport || new Viewport(0, 0);\n        for (let i = 0;; i++) {\n            let viewport;\n            if (invalidHeightMap) {\n                // FIXME this is a terrible kludge (see #128) to get around\n                // the fact that plugins need a viewport to update, but the\n                // heightmap update needs the current decorations, which are\n                // produced by the plugins\n                let from = _state__WEBPACK_IMPORTED_MODULE_0__[\"ChangedRange\"].mapPos(prevViewport.from, -1, contentChanges);\n                viewport = new Viewport(from, Math.min(from + (prevViewport.to - prevViewport.from) + 1000, _state__WEBPACK_IMPORTED_MODULE_0__[\"ChangedRange\"].mapPos(prevViewport.to, 1, contentChanges)));\n            }\n            else {\n                viewport = this.viewportState.getViewport(state.doc, this.heightMap, viewportBias, scrollIntoView);\n            }\n            let viewportChange = prevViewport ? !viewport.eq(prevViewport) : true;\n            // When the viewport is stable and no more iterations are needed, return\n            if (!viewportChange && !invalidHeightMap && !update && !initializing)\n                return contentChanges;\n            // After 5 tries, give up\n            if (i == 5) {\n                console.warn(\"Viewport and decorations failed to converge\");\n                return contentChanges;\n            }\n            let prevState = this.state || state;\n            if (initializing)\n                initializing(viewport);\n            else\n                this.view.updateInner(update || new ViewUpdate(this.view), viewport);\n            prevViewport = viewport;\n            // For the composition decoration, use none on init, recompute\n            // when handling transactions, and use the previous value\n            // otherwise.\n            if (!this.view.inputState.composing)\n                this.compositionDeco = Decoration.none;\n            else if (update && update.transactions.length)\n                this.compositionDeco = computeCompositionDeco(this.view, contentChanges);\n            let decorations$1 = this.view.behavior(decorations).concat(this.compositionDeco);\n            // If the decorations are stable, stop.\n            if (!update && !initializing && sameArray(decorations$1, this.decorations))\n                return contentChanges;\n            // Compare the decorations (between document changes)\n            let { content, height } = decoChanges(update ? contentChanges : none$4, decorations$1, this.decorations, prevState.doc.length);\n            this.decorations = decorations$1;\n            // Update the heightmap with these changes. If this is the first\n            // iteration and the document changed, also include decorations\n            // for inserted ranges.\n            let heightChanges = extendWithRanges(invalidHeightMap || none$4, height);\n            this.heightMap = this.heightMap.applyChanges(decorations$1, oldDoc, this.heightOracle.setDoc(state.doc), heightChanges);\n            invalidHeightMap = null;\n            oldDoc = state.doc;\n            // Accumulate content changes so that they can be redrawn\n            contentChanges = extendWithRanges(contentChanges, content);\n            // Make sure only one iteration is marked as required / state changing\n            update = null;\n            initializing = null;\n        }\n    }\n    focus() {\n        this.updateSelection(true);\n    }\n    cancelLayoutCheck() {\n        if (this.layoutCheckScheduled > -1) {\n            cancelAnimationFrame(this.layoutCheckScheduled);\n            this.layoutCheckScheduled = -1;\n        }\n    }\n    checkLayout(forceFull = false) {\n        this.cancelLayoutCheck();\n        this.measureVerticalPadding();\n        let scrollIntoView = Math.min(this.scrollIntoView, this.state.doc.length);\n        this.scrollIntoView = -1;\n        let scrollBias = 0;\n        if (forceFull)\n            this.viewportState.coverEverything();\n        else\n            scrollBias = this.viewportState.updateFromDOM(this.dom, this.paddingTop);\n        if (this.viewportState.top >= this.viewportState.bottom)\n            return; // We're invisible!\n        this.view.updateState = 1 /* Measuring */;\n        let lineHeights = this.measureVisibleLineHeights(), refresh = false;\n        if (this.heightOracle.mustRefresh(lineHeights)) {\n            let { lineHeight, charWidth } = this.measureTextSize();\n            refresh = this.heightOracle.refresh(getComputedStyle(this.dom).whiteSpace, lineHeight, charWidth, (this.dom).clientWidth / charWidth, lineHeights);\n            if (refresh)\n                this.minWidth = 0;\n        }\n        if (scrollIntoView > -1)\n            this.scrollPosIntoView(scrollIntoView);\n        let toMeasure = [];\n        for (let plugin of this.view.behavior(viewPlugin)) {\n            let value = this.view.plugin(plugin);\n            if (value.measure && value.drawMeasured)\n                toMeasure.push(value);\n        }\n        let update = false, measure = toMeasure.map(plugin => plugin.measure());\n        for (let i = 0;; i++) {\n            this.heightOracle.heightChanged = false;\n            this.heightMap = this.heightMap.updateHeight(this.heightOracle, 0, refresh, new MeasuredHeights(this.viewport.from, lineHeights || this.measureVisibleLineHeights()));\n            let covered = this.viewportState.coveredBy(this.state.doc, this.viewport, this.heightMap, scrollBias);\n            if (covered && !this.heightOracle.heightChanged)\n                break;\n            if (i > 10) {\n                console.warn(\"Layout failed to converge\");\n                break;\n            }\n            this.view.updateState = 2 /* Updating */;\n            update = true;\n            let contentChanges = covered ? none$4 : this.computeUpdate(this.state, this.state.doc, null, null, none$4, scrollBias, -1);\n            this.updateInner(contentChanges, this.length);\n            lineHeights = null;\n            refresh = false;\n            scrollBias = 0;\n            this.view.updateState = 1 /* Measuring */;\n            this.viewportState.updateFromDOM(this.dom, this.paddingTop);\n            measure = toMeasure.map(plugin => plugin.measure());\n        }\n        this.view.updateState = 2 /* Updating */;\n        while (toMeasure.length) {\n            toMeasure = toMeasure.filter((plugin, i) => plugin.drawMeasured(measure[i]));\n            measure = toMeasure.map(plugin => plugin.measure());\n        }\n        if (update) {\n            this.observer.listenForScroll();\n            this.view.drawPlugins();\n        }\n        this.view.updateState = 0 /* Idle */;\n    }\n    scrollPosIntoView(pos) {\n        let rect = this.coordsAt(pos);\n        if (!rect)\n            return;\n        let margin = this.view.behavior(scrollMargins);\n        scrollRectIntoView(this.dom, { left: rect.left - margin.left, top: rect.top - margin.top,\n            right: rect.right + margin.right, bottom: rect.bottom + margin.bottom });\n    }\n    nearest(dom) {\n        for (let cur = dom; cur;) {\n            let domView = cur.cmView;\n            if (domView && domView.rootView == this)\n                return domView;\n            cur = cur.parentNode;\n        }\n        return null;\n    }\n    posFromDOM(node, offset) {\n        let view = this.nearest(node);\n        if (!view)\n            throw new RangeError(\"Trying to find position for a DOM position outside of the document\");\n        return view.localPosFromDOM(node, offset) + view.posAtStart;\n    }\n    domAtPos(pos) {\n        let { i, off } = this.childCursor().findPos(pos, -1);\n        for (; i < this.children.length - 1;) {\n            let child = this.children[i];\n            if (off < child.length || child instanceof LineView)\n                break;\n            i++;\n            off = 0;\n        }\n        return this.children[i].domAtPos(off);\n    }\n    coordsAt(pos) {\n        for (let off = this.length, i = this.children.length - 1;; i--) {\n            let child = this.children[i], start = off - child.breakAfter - child.length;\n            if (pos >= start && child.type != BlockType.WidgetAfter)\n                return child.coordsAt(pos - start);\n            off = start;\n        }\n    }\n    measureVisibleLineHeights() {\n        let result = [], { from, to } = this.viewport;\n        let minWidth = Math.max(this.dom.clientWidth, this.minWidth) + 1;\n        for (let pos = 0, i = 0; i < this.children.length; i++) {\n            let child = this.children[i], end = pos + child.length;\n            if (end > to)\n                break;\n            if (pos >= from) {\n                result.push(child.dom.getBoundingClientRect().height);\n                let width = child.dom.scrollWidth;\n                if (width > minWidth) {\n                    this.minWidth = minWidth = width;\n                    this.minWidthFrom = pos;\n                    this.minWidthTo = end;\n                }\n            }\n            pos = end + child.breakAfter;\n        }\n        return result;\n    }\n    measureVerticalPadding() {\n        let style = window.getComputedStyle(this.dom);\n        this.paddingTop = parseInt(style.paddingTop) || 0;\n        this.paddingBottom = parseInt(style.paddingBottom) || 0;\n    }\n    measureTextSize() {\n        for (let child of this.children) {\n            if (child instanceof LineView) {\n                let measure = child.measureTextSize();\n                if (measure)\n                    return measure;\n            }\n        }\n        // If no workable line exists, force a layout of a measurable element\n        let dummy = document.createElement(\"div\"), lineHeight, charWidth;\n        dummy.className = \"codemirror-line\";\n        dummy.textContent = \"abc def ghi jkl mno pqr stu\";\n        this.observer.ignore(() => {\n            this.dom.appendChild(dummy);\n            let rect = clientRectsFor(dummy.firstChild)[0];\n            lineHeight = dummy.getBoundingClientRect().height;\n            charWidth = rect ? rect.width / 27 : 7;\n            dummy.remove();\n        });\n        return { lineHeight, charWidth };\n    }\n    destroy() {\n        cancelAnimationFrame(this.layoutCheckScheduled);\n        this.observer.destroy();\n    }\n    clearSelectionDirty() {\n        if (this.selectionDirty != null) {\n            cancelAnimationFrame(this.selectionDirty);\n            this.selectionDirty = null;\n        }\n    }\n    setSelectionDirty() {\n        this.observer.clearSelection();\n        if (this.selectionDirty == null)\n            this.selectionDirty = requestAnimationFrame(() => this.updateSelection());\n    }\n    childCursor(pos = this.length) {\n        // Move back to start of last element when possible, so that\n        // `ChildCursor.findPos` doesn't have to deal with the edge case\n        // of being after the last element.\n        let i = this.children.length;\n        if (i)\n            pos -= this.children[--i].length;\n        return new ChildCursor(this.children, pos, i);\n    }\n    computeGapDeco(viewports, docLength) {\n        let deco = [];\n        for (let pos = 0, i = 0;; i++) {\n            let next = i == viewports.length ? null : viewports[i];\n            let end = next ? next.from - 1 : docLength;\n            if (end > pos) {\n                let height = this.lineAt(end, 0).bottom - this.lineAt(pos, 0).top;\n                deco.push(Decoration.replace(pos, end, { widget: new GapWidget(height), block: true, inclusive: true }));\n            }\n            if (!next)\n                break;\n            pos = next.to + 1;\n        }\n        return Decoration.set(deco);\n    }\n}\n// Browsers appear to reserve a fixed amount of bits for height\n// styles, and ignore or clip heights above that. For Chrome and\n// Firefox, this is in the 20 million range, so we try to stay below\n// that.\nconst MAX_NODE_HEIGHT = 1e7;\nclass GapWidget extends WidgetType {\n    toDOM() {\n        let elt = document.createElement(\"div\");\n        this.updateDOM(elt);\n        return elt;\n    }\n    updateDOM(elt) {\n        if (this.value < MAX_NODE_HEIGHT) {\n            while (elt.lastChild)\n                elt.lastChild.remove();\n            elt.style.height = this.value + \"px\";\n        }\n        else {\n            elt.style.height = \"\";\n            for (let remaining = this.value; remaining > 0; remaining -= MAX_NODE_HEIGHT) {\n                let fill = elt.appendChild(document.createElement(\"div\"));\n                fill.style.height = Math.min(remaining, MAX_NODE_HEIGHT) + \"px\";\n            }\n        }\n        return true;\n    }\n    get estimatedHeight() { return this.value; }\n}\nfunction decoChanges(diff, decorations, oldDecorations, oldLength) {\n    let contentRanges = [], heightRanges = [];\n    for (let i = decorations.length - 1; i >= 0; i--) {\n        let deco = decorations[i], oldDeco = i < oldDecorations.length ? oldDecorations[i] : Decoration.none;\n        if (deco.size == 0 && oldDeco.size == 0)\n            continue;\n        let newRanges = findChangedRanges(oldDeco, deco, diff, oldLength);\n        contentRanges = joinRanges(contentRanges, newRanges.content);\n        heightRanges = joinRanges(heightRanges, newRanges.height);\n    }\n    return { content: contentRanges, height: heightRanges };\n}\nfunction extendWithRanges(diff, ranges) {\n    if (ranges.length == 0)\n        return diff;\n    let result = [];\n    for (let dI = 0, rI = 0, posA = 0, posB = 0;; dI++) {\n        let next = dI == diff.length ? null : diff[dI], off = posA - posB;\n        let end = next ? next.fromB : 1e9;\n        while (rI < ranges.length && ranges[rI] < end) {\n            let from = ranges[rI], to = ranges[rI + 1];\n            let fromB = Math.max(posB, from), toB = Math.min(end, to);\n            if (fromB <= toB)\n                new _state__WEBPACK_IMPORTED_MODULE_0__[\"ChangedRange\"](fromB + off, toB + off, fromB, toB).addToSet(result);\n            if (to > end)\n                break;\n            else\n                rI += 2;\n        }\n        if (!next)\n            return result;\n        new _state__WEBPACK_IMPORTED_MODULE_0__[\"ChangedRange\"](next.fromA, next.toA, next.fromB, next.toB).addToSet(result);\n        posA = next.toA;\n        posB = next.toB;\n    }\n}\nfunction sameArray(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (a[i] !== b[i])\n            return false;\n    return true;\n}\nfunction computeCompositionDeco(view, changes) {\n    let sel = view.root.getSelection();\n    let textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset);\n    if (!textNode)\n        return Decoration.none;\n    let cView = view.docView.nearest(textNode);\n    let from, to, topNode = textNode;\n    if (cView instanceof InlineView) {\n        from = cView.posAtStart;\n        to = from + cView.length;\n        topNode = cView.dom;\n    }\n    else if (cView instanceof LineView) {\n        while (topNode.parentNode != cView.dom)\n            topNode = topNode.parentNode;\n        let prev = topNode.previousSibling;\n        while (prev && !prev.cmView)\n            prev = prev.previousSibling;\n        from = to = prev ? prev.cmView.posAtEnd : cView.posAtStart;\n    }\n    else {\n        return Decoration.none;\n    }\n    let newFrom = _state__WEBPACK_IMPORTED_MODULE_0__[\"ChangedRange\"].mapPos(from, 1, changes), newTo = Math.max(newFrom, _state__WEBPACK_IMPORTED_MODULE_0__[\"ChangedRange\"].mapPos(to, -1, changes));\n    let text = textNode.nodeValue, doc = view.state.doc;\n    if (newTo - newFrom < text.length) {\n        if (doc.slice(newFrom, Math.min(doc.length, newFrom + text.length)) == text)\n            newTo = newFrom + text.length;\n        else if (doc.slice(Math.max(0, newTo - text.length), newTo) == text)\n            newFrom = newTo - text.length;\n        else\n            return Decoration.none;\n    }\n    else if (doc.slice(newFrom, newTo) != text) {\n        return Decoration.none;\n    }\n    return Decoration.set(Decoration.replace(newFrom, newTo, {\n        widget: new CompositionWidget({ top: topNode, text: textNode })\n    }));\n}\nclass CompositionWidget extends WidgetType {\n    eq(value) { return this.value.top == value.top && this.value.text == value.text; }\n    toDOM() { return this.value.top; }\n    ignoreEvent() { return false; }\n    get customView() { return CompositionView; }\n}\nfunction nearbyTextNode(node, offset) {\n    for (;;) {\n        if (node.nodeType == 3)\n            return node;\n        if (node.nodeType == 1 && offset > 0) {\n            node = node.childNodes[offset - 1];\n            offset = maxOffset(node);\n        }\n        else if (node.nodeType == 1 && offset < node.childNodes.length) {\n            node = node.childNodes[offset];\n            offset = 0;\n        }\n        else {\n            return null;\n        }\n    }\n}\n\n// FIXME rename \"word\" to something more descriptive of what it actually does?\nfunction movePos(view, start, direction, granularity = \"character\", action) {\n    let sel = view.root.getSelection();\n    let context = LineContext.get(view, start);\n    let dir = direction == \"forward\" || direction == \"right\" ? 1 : -1;\n    // Can only query native behavior when Selection.modify is\n    // supported, the cursor is well inside the rendered viewport, and\n    // we're not doing by-line motion on Gecko (which will mess up goal\n    // column motion)\n    if (sel.modify && context && !context.nearViewportEnd(view) && view.hasFocus &&\n        granularity != \"word\" &&\n        !(granularity == \"line\" && (browser.gecko || view.state.selection.ranges.length > 1))) {\n        return view.docView.observer.ignore(() => {\n            let prepared = context.prepareForQuery(view, start);\n            let startDOM = view.docView.domAtPos(start);\n            let equiv = (!browser.chrome || prepared.lines.length == 0) &&\n                isEquivalentPosition(startDOM.node, startDOM.offset, sel.focusNode, sel.focusOffset) && false;\n            // Firefox skips an extra character ahead when extending across\n            // an uneditable element (but not when moving)\n            if (prepared.atWidget && browser.gecko && action == \"extend\")\n                action = \"move\";\n            if (action == \"move\" && !(equiv && sel.isCollapsed))\n                sel.collapse(startDOM.node, startDOM.offset);\n            else if (action == \"extend\" && !equiv)\n                sel.extend(startDOM.node, startDOM.offset);\n            sel.modify(action, direction, granularity);\n            view.docView.setSelectionDirty();\n            let result = view.docView.posFromDOM(sel.focusNode, sel.focusOffset);\n            context.undoQueryPreparation(view, prepared);\n            return result;\n        });\n    }\n    else if (granularity == \"character\") {\n        return moveCharacterSimple(start, dir, context, view.state.doc);\n    }\n    else if (granularity == \"lineboundary\") {\n        if (context)\n            return context.start + (dir < 0 ? 0 : context.line.length);\n        let line = view.state.doc.lineAt(start);\n        return dir < 0 ? line.start : line.end;\n    }\n    else if (granularity == \"line\") {\n        if (context && !context.nearViewportEnd(view, dir)) {\n            let startCoords = view.docView.coordsAt(start);\n            let goal = getGoalColumn(view, start, startCoords.left);\n            for (let startY = dir < 0 ? startCoords.top : startCoords.bottom, dist = 5; dist < 50; dist += 10) {\n                let pos = posAtCoords(view, { x: goal.column, y: startY + dist * dir }, dir);\n                if (pos < 0)\n                    break;\n                if (pos != start) {\n                    goal.pos = pos;\n                    return pos;\n                }\n            }\n        }\n        // Can't do a precise one based on DOM positions, fall back to per-column\n        return moveLineByColumn(view.state.doc, view.state.tabSize, start, dir);\n    }\n    else if (granularity == \"word\") {\n        return moveWord(view, start, direction);\n    }\n    else {\n        throw new RangeError(\"Invalid move granularity: \" + granularity);\n    }\n}\nfunction moveLineByColumn(doc, tabSize, pos, dir) {\n    let line = doc.lineAt(pos);\n    // FIXME also needs goal column?\n    let col = 0;\n    for (const iter = doc.iterRange(line.start, pos); !iter.next().done;)\n        col = Object(_text__WEBPACK_IMPORTED_MODULE_3__[\"countColumn\"])(iter.value, col, tabSize);\n    if (dir < 0 && line.start == 0)\n        return 0;\n    else if (dir > 0 && line.end == doc.length)\n        return line.end;\n    let otherLine = doc.line(line.number + dir);\n    let result = otherLine.start;\n    let seen = 0;\n    for (const iter = doc.iterRange(otherLine.start, otherLine.end); seen >= col && !iter.next().done;) {\n        const { offset, leftOver } = Object(_text__WEBPACK_IMPORTED_MODULE_3__[\"findColumn\"])(iter.value, seen, col, tabSize);\n        seen = col - leftOver;\n        result += offset;\n    }\n    return result;\n}\nfunction moveCharacterSimple(start, dir, context, doc) {\n    if (context == null) {\n        for (let pos = start;; pos += dir) {\n            if (dir < 0 && pos == 0 || dir > 0 && pos == doc.length)\n                return pos;\n            if (!Object(_text__WEBPACK_IMPORTED_MODULE_3__[\"isExtendingChar\"])((dir < 0 ? doc.slice(pos - 1, pos) : doc.slice(pos, pos + 1)).charCodeAt(0))) {\n                if (dir < 0)\n                    return pos - 1;\n                else if (pos != start)\n                    return pos;\n            }\n        }\n    }\n    for (let { i, off } = context.line.childPos(start - context.start), { children } = context.line, pos = start;;) {\n        if (off == (dir < 0 || i == children.length ? 0 : children[i].length)) {\n            i += dir;\n            if (i < 0 || i >= children.length) // End/start of line\n                return Math.max(0, Math.min(doc.length, pos + (start == pos ? dir : 0)));\n            off = dir < 0 ? children[i].length : 0;\n        }\n        let inline = children[i];\n        if (inline instanceof TextView) {\n            if (!Object(_text__WEBPACK_IMPORTED_MODULE_3__[\"isExtendingChar\"])(inline.text.charCodeAt(off - (dir < 0 ? 1 : 0)))) {\n                if (dir < 0)\n                    return pos - 1;\n                else if (pos != start)\n                    return pos;\n            }\n            off += dir;\n            pos += dir;\n        }\n        else if (inline.length > 0) {\n            return pos - off + (dir < 0 ? 0 : inline.length);\n        }\n    }\n}\nfunction moveWord(view, start, direction) {\n    let { doc } = view.state;\n    for (let pos = start, i = 0;; i++) {\n        let next = movePos(view, pos, direction, \"character\", \"move\");\n        if (next == pos)\n            return pos; // End of document\n        if (doc.sliceLines(Math.min(next, pos), Math.max(next, pos)).length > 1)\n            return next; // Crossed a line boundary\n        let group = _state__WEBPACK_IMPORTED_MODULE_0__[\"SelectionRange\"].groupAt(view.state, next, next > pos ? -1 : 1);\n        let away = pos < group.from && pos > group.to;\n        // If the group is away from its start position, we jumped over a\n        // bidi boundary, and should take the side closest (in index\n        // coordinates) to the start position\n        let start = away ? pos < group.head : group.from == pos ? false : group.to == pos ? true : next < pos;\n        pos = start ? group.from : group.to;\n        if (i > 0 || /\\S/.test(doc.slice(group.from, group.to)))\n            return pos;\n        next = Math.max(0, Math.min(doc.length, pos + (start ? -1 : 1)));\n    }\n}\nfunction getGoalColumn(view, pos, column) {\n    for (let goal of view.inputState.goalColumns)\n        if (goal.pos == pos)\n            return goal;\n    let goal = { pos: 0, column };\n    view.inputState.goalColumns.push(goal);\n    return goal;\n}\nclass LineContext {\n    constructor(line, start, index) {\n        this.line = line;\n        this.start = start;\n        this.index = index;\n    }\n    static get(view, pos) {\n        for (let i = 0, off = 0;; i++) {\n            let line = view.docView.children[i], end = off + line.length;\n            if (end >= pos) {\n                if (line instanceof LineView)\n                    return new LineContext(line, off, i);\n                if (line.length)\n                    return null;\n            }\n            off = end + 1;\n        }\n    }\n    nearViewportEnd(view, side = 0) {\n        for (let { from, to } of view.docView.viewports)\n            if (from > 0 && from == this.start && side <= 0 ||\n                to < view.state.doc.length && to == this.start + this.line.length && side >= 0)\n                return true;\n        return false;\n    }\n    // FIXME limit the amount of work in character motion in non-bidi\n    // context? or not worth it?\n    prepareForQuery(view, pos) {\n        let linesToSync = [], atWidget = false;\n        function maybeHide(view) {\n            if (!(view instanceof TextView))\n                atWidget = true;\n            if (view.length > 0)\n                return false;\n            view.dom.remove();\n            if (linesToSync.indexOf(view.parent) < 0)\n                linesToSync.push(view.parent);\n            return true;\n        }\n        let { i, off } = this.line.childPos(pos - this.start);\n        if (off == 0) {\n            for (let j = i; j < this.line.children.length; j++)\n                if (!maybeHide(this.line.children[j]))\n                    break;\n            for (let j = i; j > 0; j--)\n                if (!maybeHide(this.line.children[j - 1]))\n                    break;\n        }\n        function addForLine(line, omit = -1) {\n            if (line.children.length == 0)\n                return;\n            for (let i = 0, off = 0; i <= line.children.length; i++) {\n                let next = i == line.children.length ? null : line.children[i];\n                if ((!next || !(next instanceof TextView)) && off != omit &&\n                    (i == 0 || !(line.children[i - 1] instanceof TextView))) {\n                    line.dom.insertBefore(document.createTextNode(\"\\u200b\"), next ? next.dom : null);\n                    if (linesToSync.indexOf(line) < 0)\n                        linesToSync.push(line);\n                }\n                if (next)\n                    off += next.length;\n            }\n        }\n        if (this.index > 0)\n            addForLine(this.line.parent.children[this.index - 1]);\n        addForLine(this.line, pos - this.start);\n        if (this.index < this.line.parent.children.length - 1)\n            addForLine(this.line.parent.children[this.index + 1]);\n        return { lines: linesToSync, atWidget };\n    }\n    undoQueryPreparation(view, toSync) {\n        for (let line of toSync.lines) {\n            line.dirty = 2 /* Node */;\n            line.sync();\n            line.dirty = 0 /* Not */;\n        }\n    }\n}\n// Search the DOM for the {node, offset} position closest to the given\n// coordinates. Very inefficient and crude, but can usually be avoided\n// by calling caret(Position|Range)FromPoint instead.\n// FIXME holding arrow-up/down at the end of the viewport is a rather\n// common use case that will repeatedly trigger this code. Maybe\n// introduce some element of binary search after all?\nfunction getdx(x, rect) {\n    return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);\n}\nfunction getdy(y, rect) {\n    return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);\n}\nfunction yOverlap(a, b) {\n    return a.top < b.bottom - 1 && a.bottom > b.top + 1;\n}\nfunction upTop(rect, top) {\n    return top < rect.top ? { top, left: rect.left, right: rect.right, bottom: rect.bottom } : rect;\n}\nfunction upBot(rect, bottom) {\n    return bottom > rect.bottom ? { top: rect.top, left: rect.left, right: rect.right, bottom } : rect;\n}\nfunction domPosAtCoords(parent, x, y) {\n    let closest, closestRect, closestX, closestY;\n    let above, below, aboveRect, belowRect;\n    for (let child = parent.firstChild; child; child = child.nextSibling) {\n        let rects = clientRectsFor(child);\n        for (let i = 0; i < rects.length; i++) {\n            let rect = rects[i];\n            if (closestRect && yOverlap(closestRect, rect))\n                rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);\n            let dx = getdx(x, rect), dy = getdy(y, rect);\n            if (dx == 0 && dy == 0)\n                return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);\n            if (!closest || closestY > dy || closestY == dy && closestX > dx) {\n                closest = child;\n                closestRect = rect;\n                closestX = dx;\n                closestY = dy;\n            }\n            if (dx == 0) {\n                if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {\n                    above = child;\n                    aboveRect = rect;\n                }\n                else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {\n                    below = child;\n                    belowRect = rect;\n                }\n            }\n            else if (aboveRect && yOverlap(aboveRect, rect)) {\n                aboveRect = upBot(aboveRect, rect.bottom);\n            }\n            else if (belowRect && yOverlap(belowRect, rect)) {\n                belowRect = upTop(belowRect, rect.top);\n            }\n        }\n    }\n    if (aboveRect && aboveRect.bottom >= y) {\n        closest = above;\n        closestRect = aboveRect;\n    }\n    else if (belowRect && belowRect.top <= y) {\n        closest = below;\n        closestRect = belowRect;\n    }\n    if (!closest)\n        return { node: parent, offset: 0 };\n    let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));\n    if (closest.nodeType == 3)\n        return domPosInText(closest, clipX, y);\n    if (!closestX && closest.contentEditable == \"true\")\n        domPosAtCoords(closest, clipX, y);\n    let offset = Array.prototype.indexOf.call(parent.childNodes, closest) +\n        (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);\n    return { node: parent, offset };\n}\nfunction domPosInText(node, x, y) {\n    let len = node.nodeValue.length, range = document.createRange();\n    for (let i = 0; i < len; i++) {\n        range.setEnd(node, i + 1);\n        range.setStart(node, i);\n        let rects = range.getClientRects();\n        for (let j = 0; j < rects.length; j++) {\n            let rect = rects[j];\n            if (rect.top == rect.bottom)\n                continue;\n            if (rect.left - 1 <= x && rect.right + 1 >= x &&\n                rect.top - 1 <= y && rect.bottom + 1 >= y) {\n                let right = x >= (rect.left + rect.right) / 2, after = right;\n                if (browser.chrome || browser.gecko) {\n                    // Check for RTL on browsers that support getting client\n                    // rects for empty ranges.\n                    range.setEnd(node, i);\n                    let rectBefore = range.getBoundingClientRect();\n                    if (rectBefore.left == rect.right)\n                        after = !right;\n                }\n                return { node, offset: i + (after ? 1 : 0) };\n            }\n        }\n    }\n    return { node, offset: 0 };\n}\nfunction posAtCoords(view, { x, y }, bias = -1) {\n    let content = view.contentDOM.getBoundingClientRect(), block;\n    let halfLine = view.defaultLineHeight / 2;\n    for (let bounced = false;;) {\n        block = view.blockAtHeight(y, content.top);\n        if (block.top > y || block.bottom < y) {\n            bias = block.top > y ? -1 : 1;\n            y = Math.min(block.bottom - halfLine, Math.max(block.top + halfLine, y));\n            if (bounced)\n                return -1;\n            else\n                bounced = true;\n        }\n        if (block.type == BlockType.Text)\n            break;\n        y = bias > 0 ? block.bottom + halfLine : block.top - halfLine;\n    }\n    let lineStart = block.from;\n    // If this is outside of the rendered viewport, we can't determine a position\n    if (lineStart < view._viewport.from)\n        return view._viewport.from == 0 ? 0 : -1;\n    if (lineStart > view._viewport.to)\n        return view._viewport.to == view.state.doc.length ? view.state.doc.length : -1;\n    // Clip x to the viewport sides\n    x = Math.max(content.left + 1, Math.min(content.right - 1, x));\n    let root = view.root, element = root.elementFromPoint(x, y);\n    // There's visible editor content under the point, so we can try\n    // using caret(Position|Range)FromPoint as a shortcut\n    let node, offset = -1;\n    if (element && view.contentDOM.contains(element) && !(view.docView.nearest(element) instanceof WidgetView)) {\n        if (root.caretPositionFromPoint) {\n            let pos = root.caretPositionFromPoint(x, y);\n            if (pos)\n                ({ offsetNode: node, offset } = pos);\n        }\n        else if (root.caretRangeFromPoint) {\n            let range = root.caretRangeFromPoint(x, y);\n            if (range)\n                ({ startContainer: node, startOffset: offset } = range);\n        }\n    }\n    // No luck, do our own (potentially expensive) search\n    if (!node) {\n        let { line } = LineContext.get(view, lineStart);\n        ({ node, offset } = domPosAtCoords(line.dom, x, y));\n    }\n    return view.docView.posFromDOM(node, offset);\n}\n\n// This will also be where dragging info and such goes\nclass InputState {\n    constructor(view) {\n        this.lastKeyCode = 0;\n        this.lastKeyTime = 0;\n        this.lastSelectionOrigin = null;\n        this.lastSelectionTime = 0;\n        this.registeredEvents = [];\n        this.customHandlers = [];\n        this.composing = false;\n        this.goalColumns = [];\n        this.mouseSelection = null;\n        for (let type in handlers) {\n            let handler = handlers[type];\n            view.contentDOM.addEventListener(type, (event) => {\n                if (!eventBelongsToEditor(view, event))\n                    return;\n                if (this.runCustomHandlers(type, view, event))\n                    event.preventDefault();\n                else\n                    handler(view, event);\n            });\n            this.registeredEvents.push(type);\n        }\n        // Must always run, even if a custom handler handled the event\n        view.contentDOM.addEventListener(\"keydown\", (event) => {\n            view.inputState.lastKeyCode = event.keyCode;\n            view.inputState.lastKeyTime = Date.now();\n        });\n        if (view.root.activeElement == view.contentDOM)\n            view.dom.classList.add(\"codemirror-focused\");\n        this.ensureHandlers(view);\n    }\n    setSelectionOrigin(origin) {\n        this.lastSelectionOrigin = origin;\n        this.lastSelectionTime = Date.now();\n    }\n    ensureHandlers(view) {\n        let handlers = view.behavior(handleDOMEvents);\n        if (handlers == this.customHandlers ||\n            (handlers.length == this.customHandlers.length && handlers.every((h, i) => h == this.customHandlers[i])))\n            return;\n        this.customHandlers = handlers;\n        for (let set of handlers) {\n            for (let type in set)\n                if (this.registeredEvents.indexOf(type) < 0) {\n                    this.registeredEvents.push(type);\n                    view.contentDOM.addEventListener(type, (event) => {\n                        if (!eventBelongsToEditor(view, event))\n                            return;\n                        if (this.runCustomHandlers(type, view, event))\n                            event.preventDefault();\n                    });\n                }\n        }\n    }\n    runCustomHandlers(type, view, event) {\n        for (let handlers of this.customHandlers) {\n            let handler = handlers[type];\n            if (handler) {\n                try {\n                    if (handler(view, event) || event.defaultPrevented)\n                        return true;\n                }\n                catch (e) {\n                    console.error(e);\n                }\n            }\n        }\n        return false;\n    }\n    startMouseSelection(view, event, update) {\n        if (this.mouseSelection)\n            this.mouseSelection.destroy();\n        this.mouseSelection = new MouseSelection(this, view, event, update);\n    }\n    update(update) {\n        if (this.mouseSelection)\n            this.mouseSelection.map(update.changes);\n        this.lastKeyCode = this.lastSelectionTime = 0;\n    }\n    destroy() {\n        if (this.mouseSelection)\n            this.mouseSelection.destroy();\n    }\n}\nclass MouseSelection {\n    constructor(inputState, view, event, update) {\n        this.inputState = inputState;\n        this.view = view;\n        this.update = update;\n        let doc = view.contentDOM.ownerDocument;\n        doc.addEventListener(\"mousemove\", this.move = this.move.bind(this));\n        doc.addEventListener(\"mouseup\", this.up = this.up.bind(this));\n        this.extend = event.shiftKey;\n        this.multiple = view.state.behavior(_state__WEBPACK_IMPORTED_MODULE_0__[\"EditorState\"].allowMultipleSelections) && addsSelectionRange(view, event);\n        this.dragMove = dragMovesSelection$1(view, event);\n        this.startSelection = view.state.selection;\n        let { pos, bias } = this.queryPos(event);\n        this.startPos = this.curPos = pos;\n        this.startBias = this.curBias = bias;\n        this.dragging = isInPrimarySelection(view, this.startPos, event) ? null : false;\n        // When clicking outside of the selection, immediately apply the\n        // effect of starting the selection\n        if (this.dragging === false) {\n            event.preventDefault();\n            this.select();\n        }\n    }\n    queryPos(event) {\n        let pos = this.view.posAtCoords({ x: event.clientX, y: event.clientY });\n        let coords = this.view.coordsAtPos(pos);\n        let bias = !coords ? 1 :\n            coords.top > event.clientY ? -1 :\n                coords.bottom < event.clientY ? 1 :\n                    coords.left > event.clientX ? -1 : 1;\n        return { pos, bias };\n    }\n    move(event) {\n        if (event.buttons == 0)\n            return this.destroy();\n        if (this.dragging !== false)\n            return;\n        let { pos, bias } = this.queryPos(event);\n        if (pos == this.curPos && bias == this.curBias)\n            return;\n        this.curPos = pos;\n        this.curBias = bias;\n        this.select();\n    }\n    up(event) {\n        if (this.dragging == null)\n            this.select();\n        this.destroy();\n    }\n    destroy() {\n        let doc = this.view.contentDOM.ownerDocument;\n        doc.removeEventListener(\"mousemove\", this.move);\n        doc.removeEventListener(\"mouseup\", this.up);\n        this.inputState.mouseSelection = null;\n    }\n    select() {\n        let selection = this.update(this.view, this.startSelection, this.startPos, this.startBias, this.curPos, this.curBias, this.extend, this.multiple);\n        if (!selection.eq(this.view.state.selection))\n            this.view.dispatch(this.view.state.t().setSelection(selection)\n                .annotate(_state__WEBPACK_IMPORTED_MODULE_0__[\"Transaction\"].userEvent(\"pointer\")));\n    }\n    map(changes) {\n        if (changes.length) {\n            this.startSelection = this.startSelection.map(changes);\n            this.startPos = changes.mapPos(this.startPos);\n            this.curPos = changes.mapPos(this.curPos);\n        }\n        if (this.dragging)\n            this.dragging = this.dragging.map(changes);\n    }\n}\nfunction addsSelectionRange(view, event) {\n    let behavior = view.behavior(clickAddsSelectionRange);\n    return behavior.length ? behavior[0](event) : browser.mac ? event.metaKey : event.ctrlKey;\n}\nfunction dragMovesSelection$1(view, event) {\n    let behavior = view.behavior(dragMovesSelection);\n    return behavior.length ? behavior[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;\n}\nfunction isInPrimarySelection(view, pos, event) {\n    let { primary } = view.state.selection;\n    if (primary.empty)\n        return false;\n    if (pos < primary.from || pos > primary.to)\n        return false;\n    if (pos > primary.from && pos < primary.to)\n        return true;\n    // On boundary clicks, check whether the coordinates are inside the\n    // selection's client rectangles\n    let sel = view.root.getSelection();\n    if (sel.rangeCount == 0)\n        return true;\n    let rects = sel.getRangeAt(0).getClientRects();\n    for (let i = 0; i < rects.length; i++) {\n        let rect = rects[i];\n        if (rect.left <= event.clientX && rect.right >= event.clientX &&\n            rect.top <= event.clientY && rect.bottom >= event.clientY)\n            return true;\n    }\n    return false;\n}\nfunction eventBelongsToEditor(view, event) {\n    if (!event.bubbles)\n        return true;\n    if (event.defaultPrevented)\n        return false;\n    for (let node = event.target; node != view.contentDOM; node = node.parentNode)\n        if (!node || node.nodeType == 11 || (node.cmView && node.cmView.ignoreEvent(event)))\n            return false;\n    return true;\n}\nconst handlers = Object.create(null);\n// This is very crude, but unfortunately both these browsers _pretend_\n// that they have a clipboard APIâ€”all the objects and methods are\n// there, they just don't work, and they are hard to test.\nconst brokenClipboardAPI = (browser.ie && browser.ie_version < 15) ||\n    (browser.ios && browser.webkit_version < 604);\nfunction capturePaste(view) {\n    let doc = view.dom.ownerDocument;\n    let target = doc.body.appendChild(doc.createElement(\"textarea\"));\n    target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    target.focus();\n    setTimeout(() => {\n        view.focus();\n        doc.body.removeChild(target);\n        doPaste(view, target.value);\n    }, 50);\n}\nfunction doPaste(view, text) {\n    view.dispatch(view.state.t().replaceSelection(text)\n        .annotate(_state__WEBPACK_IMPORTED_MODULE_0__[\"Transaction\"].userEvent(\"paste\")).scrollIntoView());\n}\nfunction mustCapture(event) {\n    let mods = (event.ctrlKey ? 1 /* Ctrl */ : 0) | (event.metaKey ? 8 /* Meta */ : 0) |\n        (event.altKey ? 2 /* Alt */ : 0) | (event.shiftKey ? 4 /* Shift */ : 0);\n    let code = event.keyCode, macCtrl = browser.mac && mods == 1 /* Ctrl */;\n    return code == 8 || (macCtrl && code == 72) || // Backspace, Ctrl-h on Mac\n        code == 46 || (macCtrl && code == 68) || // Delete, Ctrl-d on Mac\n        code == 27 || // Esc\n        (mods == (browser.mac ? 8 /* Meta */ : 1 /* Ctrl */) && // Ctrl/Cmd-[biyz]\n            (code == 66 || code == 73 || code == 89 || code == 90));\n}\nhandlers.keydown = (view, event) => {\n    if (mustCapture(event))\n        event.preventDefault();\n    view.inputState.setSelectionOrigin(\"keyboard\");\n};\nhandlers.touchdown = handlers.touchmove = (view, event) => {\n    view.inputState.setSelectionOrigin(\"pointer\");\n};\nhandlers.mousedown = (view, event) => {\n    if (event.button == 0)\n        view.startMouseSelection(event, updateMouseSelection(event.detail));\n};\nfunction rangeForClick(view, pos, bias, type) {\n    if (type == 1) { // Single click\n        return new _state__WEBPACK_IMPORTED_MODULE_0__[\"SelectionRange\"](pos);\n    }\n    else if (type == 2) { // Double click\n        return _state__WEBPACK_IMPORTED_MODULE_0__[\"SelectionRange\"].groupAt(view.state, pos, bias);\n    }\n    else { // Triple click\n        let context = LineContext.get(view, pos);\n        if (context)\n            return new _state__WEBPACK_IMPORTED_MODULE_0__[\"SelectionRange\"](context.start + context.line.length, context.start);\n        let { start, end } = view.state.doc.lineAt(pos);\n        return new _state__WEBPACK_IMPORTED_MODULE_0__[\"SelectionRange\"](start, end);\n    }\n}\nfunction updateMouseSelection(type) {\n    return (view, startSelection, startPos, startBias, curPos, curBias, extend, multiple) => {\n        let range = rangeForClick(view, curPos, curBias, type);\n        if (startPos != curPos && !extend) {\n            let startRange = rangeForClick(view, startPos, startBias, type);\n            range = range.extend(Math.min(startRange.from, range.from), Math.max(startRange.to, range.to));\n        }\n        if (extend)\n            return startSelection.replaceRange(startSelection.primary.extend(range.from, range.to));\n        else if (multiple)\n            return startSelection.addRange(range);\n        else\n            return _state__WEBPACK_IMPORTED_MODULE_0__[\"EditorSelection\"].create([range]);\n    };\n}\nhandlers.dragstart = (view, event) => {\n    let { doc, selection: { primary } } = view.state;\n    let { mouseSelection } = view.inputState;\n    if (mouseSelection)\n        mouseSelection.dragging = primary;\n    if (event.dataTransfer) {\n        event.dataTransfer.setData(\"Text\", doc.slice(primary.from, primary.to));\n        event.dataTransfer.effectAllowed = \"copyMove\";\n    }\n};\nhandlers.drop = (view, event) => {\n    if (!event.dataTransfer)\n        return;\n    let dropPos = view.posAtCoords({ x: event.clientX, y: event.clientY });\n    let text = event.dataTransfer.getData(\"Text\");\n    if (dropPos < 0 || !text)\n        return;\n    event.preventDefault();\n    let tr = view.state.t();\n    let { mouseSelection } = view.inputState;\n    if (mouseSelection && mouseSelection.dragging && mouseSelection.dragMove) {\n        tr.replace(mouseSelection.dragging.from, mouseSelection.dragging.to, \"\");\n        dropPos = tr.changes.mapPos(dropPos);\n    }\n    let change = new _state__WEBPACK_IMPORTED_MODULE_0__[\"Change\"](dropPos, dropPos, view.state.splitLines(text));\n    tr.change(change)\n        .setSelection(_state__WEBPACK_IMPORTED_MODULE_0__[\"EditorSelection\"].single(dropPos, dropPos + change.length))\n        .annotate(_state__WEBPACK_IMPORTED_MODULE_0__[\"Transaction\"].userEvent(\"drop\"));\n    view.focus();\n    view.dispatch(tr);\n};\nhandlers.paste = (view, event) => {\n    view.docView.observer.flush();\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    let text = data && data.getData(\"text/plain\");\n    if (text) {\n        doPaste(view, text);\n        event.preventDefault();\n    }\n    else {\n        capturePaste(view);\n    }\n};\nfunction captureCopy(view, text) {\n    // The extra wrapper is somehow necessary on IE/Edge to prevent the\n    // content from being mangled when it is put onto the clipboard\n    let doc = view.dom.ownerDocument;\n    let target = doc.body.appendChild(doc.createElement(\"textarea\"));\n    target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    target.value = text;\n    target.focus();\n    target.selectionEnd = text.length;\n    target.selectionStart = 0;\n    setTimeout(() => {\n        doc.body.removeChild(target);\n        view.focus();\n    }, 50);\n}\nhandlers.copy = handlers.cut = (view, event) => {\n    let range = view.state.selection.primary;\n    if (range.empty)\n        return;\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    let text = view.state.joinLines(view.state.doc.sliceLines(range.from, range.to));\n    if (data) {\n        event.preventDefault();\n        data.clearData();\n        data.setData(\"text/plain\", text);\n    }\n    else {\n        captureCopy(view, text);\n    }\n    if (event.type == \"cut\") {\n        view.dispatch(view.state.t().replaceSelection([\"\"]).scrollIntoView().annotate(_state__WEBPACK_IMPORTED_MODULE_0__[\"Transaction\"].userEvent(\"cut\")));\n    }\n};\nhandlers.focus = view => {\n    view.update([], [focusChange(true)]);\n};\nhandlers.blur = view => {\n    view.update([], [focusChange(false)]);\n};\nhandlers.beforeprint = view => {\n    view.docView.checkLayout(true);\n};\n// Dummy annotation to force a display update in the absence of other triggers\nconst compositionEndAnnotation = _state__WEBPACK_IMPORTED_MODULE_0__[\"Annotation\"].define();\nfunction forceClearComposition(view) {\n    if (view.docView.compositionDeco.size)\n        view.update([], [compositionEndAnnotation(null)]);\n}\nhandlers.compositionstart = handlers.compositionupdate = view => {\n    if (!view.inputState.composing) {\n        if (view.docView.compositionDeco.size) {\n            view.docView.observer.flush();\n            forceClearComposition(view);\n        }\n        // FIXME possibly set a timeout to clear it again on Android\n        view.inputState.composing = true;\n    }\n};\nhandlers.compositionend = view => {\n    view.inputState.composing = false;\n    setTimeout(() => {\n        if (!view.inputState.composing)\n            forceClearComposition(view);\n    }, 50);\n};\n\nconst LINE_SEP = \"\\ufdda\"; // A Unicode 'non-character', used to denote newlines internally\nfunction applyDOMChange(view, start, end, typeOver) {\n    let change, newSel;\n    let sel = view.state.selection.primary, bounds;\n    if (start > -1 && (bounds = view.docView.domBoundsAround(start, end, 0))) {\n        let { from, to } = bounds;\n        let selPoints = view.docView.impreciseHead || view.docView.impreciseAnchor ? [] : selectionPoints(view.contentDOM, view.root);\n        let reader = new DOMReader(selPoints);\n        reader.readRange(bounds.startDOM, bounds.endDOM);\n        newSel = selectionFromPoints(selPoints, from);\n        let preferredPos = sel.from, preferredSide = null;\n        // Prefer anchoring to end when Backspace is pressed\n        if (view.inputState.lastKeyCode === 8 && view.inputState.lastKeyTime > Date.now() - 100) {\n            preferredPos = sel.to;\n            preferredSide = \"end\";\n        }\n        let diff = findDiff(view.state.doc.slice(from, to, LINE_SEP), reader.text, preferredPos - from, preferredSide);\n        if (diff)\n            change = new _state__WEBPACK_IMPORTED_MODULE_0__[\"Change\"](from + diff.from, from + diff.toA, reader.text.slice(diff.from, diff.toB).split(LINE_SEP));\n    }\n    else if (view.hasFocus) {\n        let domSel = view.root.getSelection();\n        let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;\n        let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset ? view.state.selection.primary.head\n            : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);\n        let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset ? view.state.selection.primary.anchor\n            : selectionCollapsed(domSel) ? head : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);\n        if (head != sel.head || anchor != sel.anchor)\n            newSel = _state__WEBPACK_IMPORTED_MODULE_0__[\"EditorSelection\"].single(anchor, head);\n    }\n    if (!change && !newSel)\n        return false;\n    // Heuristic to notice typing over a selected character\n    if (!change && typeOver && !sel.empty && newSel && newSel.primary.empty)\n        change = new _state__WEBPACK_IMPORTED_MODULE_0__[\"Change\"](sel.from, sel.to, view.state.doc.sliceLines(sel.from, sel.to));\n    if (change) {\n        let startState = view.state;\n        // Android browsers don't fire reasonable key events for enter,\n        // backspace, or delete. So this detects changes that look like\n        // they're caused by those keys, and reinterprets them as key\n        // events.\n        if (browser.android &&\n            ((change.from == sel.from && change.to == sel.to &&\n                change.length == 1 && change.text.length == 2 &&\n                dispatchKey(view, \"Enter\", 10)) ||\n                (change.from == sel.from - 1 && change.to == sel.to && change.length == 0 &&\n                    dispatchKey(view, \"Backspace\", 8)) ||\n                (change.from == sel.from && change.to == sel.to + 1 && change.length == 0 &&\n                    dispatchKey(view, \"Delete\", 46))))\n            return view.state != startState;\n        let tr = startState.t();\n        if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3) {\n            let before = sel.from < change.from ? startState.doc.slice(sel.from, change.from, LINE_SEP) : \"\";\n            let after = sel.to > change.to ? startState.doc.slice(change.to, sel.to, LINE_SEP) : \"\";\n            tr.replaceSelection((before + change.text.join(LINE_SEP) + after).split(LINE_SEP));\n        }\n        else {\n            tr.change(change);\n            if (newSel && !tr.selection.primary.eq(newSel.primary))\n                tr.setSelection(tr.selection.replaceRange(newSel.primary));\n        }\n        view.dispatch(tr.scrollIntoView());\n        return true;\n    }\n    else if (newSel && !newSel.primary.eq(sel)) {\n        let tr = view.state.t().setSelection(newSel);\n        if (view.inputState.lastSelectionTime > Date.now() - 50) {\n            if (view.inputState.lastSelectionOrigin == \"keyboard\")\n                tr.scrollIntoView();\n            else\n                tr.annotate(_state__WEBPACK_IMPORTED_MODULE_0__[\"Transaction\"].userEvent(view.inputState.lastSelectionOrigin));\n        }\n        view.dispatch(tr);\n        return true;\n    }\n    return false;\n}\nfunction findDiff(a, b, preferredPos, preferredSide) {\n    let minLen = Math.min(a.length, b.length);\n    let from = 0;\n    while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from))\n        from++;\n    if (from == minLen && a.length == b.length)\n        return null;\n    let toA = a.length, toB = b.length;\n    while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {\n        toA--;\n        toB--;\n    }\n    if (preferredSide == \"end\") {\n        let adjust = Math.max(0, from - Math.min(toA, toB));\n        preferredPos -= toA + adjust - from;\n    }\n    if (toA < from && a.length < b.length) {\n        let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;\n        from -= move;\n        toB = from + (toB - toA);\n        toA = from;\n    }\n    else if (toB < from) {\n        let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;\n        from -= move;\n        toA = from + (toA - toB);\n        toB = from;\n    }\n    return { from, toA, toB };\n}\nclass DOMReader {\n    constructor(points) {\n        this.points = points;\n        this.text = \"\";\n    }\n    readRange(start, end) {\n        if (!start)\n            return;\n        let parent = start.parentNode;\n        for (let cur = start;;) {\n            this.findPointBefore(parent, cur);\n            this.readNode(cur);\n            let next = cur.nextSibling;\n            if (next == end)\n                break;\n            let view = cur.cmView, nextView = next.cmView;\n            if ((view ? view.breakAfter : isBlockElement(cur)) ||\n                ((nextView ? nextView.breakAfter : isBlockElement(next)) && !(cur.nodeName == \"BR\" && !cur.cmIgnore)))\n                this.text += LINE_SEP;\n            cur = next;\n        }\n        this.findPointBefore(parent, end);\n    }\n    readNode(node) {\n        if (node.cmIgnore)\n            return;\n        let view = node.cmView;\n        let fromView = view && view.overrideDOMText;\n        let text;\n        if (fromView != null)\n            text = fromView.join(LINE_SEP);\n        else if (node.nodeType == 3)\n            text = node.nodeValue;\n        else if (node.nodeName == \"BR\")\n            text = node.nextSibling ? LINE_SEP : \"\";\n        else if (node.nodeType == 1)\n            this.readRange(node.firstChild, null);\n        if (text != null) {\n            this.findPointIn(node, text.length);\n            this.text += text;\n        }\n    }\n    findPointBefore(node, next) {\n        for (let point of this.points)\n            if (point.node == node && node.childNodes[point.offset] == next)\n                point.pos = this.text.length;\n    }\n    findPointIn(node, maxLen) {\n        for (let point of this.points)\n            if (point.node == node)\n                point.pos = this.text.length + Math.min(point.offset, maxLen);\n    }\n}\nfunction isBlockElement(node) {\n    return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\\d|SECTION|PRE)$/.test(node.nodeName);\n}\nclass DOMPoint {\n    constructor(node, offset) {\n        this.node = node;\n        this.offset = offset;\n        this.pos = -1;\n    }\n}\nfunction selectionPoints(dom, root) {\n    let result = [];\n    if (root.activeElement != dom)\n        return result;\n    let { anchorNode, anchorOffset, focusNode, focusOffset } = root.getSelection();\n    if (anchorNode) {\n        result.push(new DOMPoint(anchorNode, anchorOffset));\n        if (focusNode != anchorNode || focusOffset != anchorOffset)\n            result.push(new DOMPoint(focusNode, focusOffset));\n    }\n    return result;\n}\nfunction selectionFromPoints(points, base) {\n    if (points.length == 0)\n        return null;\n    let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;\n    return anchor > -1 && head > -1 ? _state__WEBPACK_IMPORTED_MODULE_0__[\"EditorSelection\"].single(anchor + base, head + base) : null;\n}\nfunction dispatchKey(view, name, code) {\n    let options = { key: name, code: name, keyCode: code, which: code, cancelable: true };\n    let down = new KeyboardEvent(\"keydown\", options);\n    view.contentDOM.dispatchEvent(down);\n    let up = new KeyboardEvent(\"keyup\", options);\n    view.contentDOM.dispatchEvent(up);\n    return down.defaultPrevented || up.defaultPrevented;\n}\n\n// The editor's update state machine looks something like this:\n//\n//     Idle â†’ Updating â‡† Idle (unchecked) â†’ Measuring â†’ Idle\n//                                         â†‘      â†“\n//                                         Updating (measure)\n//\n// The difference between 'Idle' and 'Idle (unchecked)' lies in\n// whether a layout check has been scheduled. A regular update through\n// the `update` method updates the DOM in a write-only fashion, and\n// relies on a check (scheduled with `requestAnimationFrame`) to make\n// sure everything is where it should be and the viewport covers the\n// visible code. That check continues to measure and then optionally\n// update until it reaches a coherent state.\n/// An editor view represents the editor's user interface. It holds\n/// the editable DOM surface, and possibly other elements such as the\n/// line number gutter. It handles events and dispatches state\n/// transactions for editing actions.\nclass EditorView {\n    /// Construct a new view. You'll usually want to put `view.dom` into\n    /// your document after creating a view, so that the user can see\n    /// it.\n    constructor(config = {}) {\n        /// @internal\n        this.plugins = Object.create(null);\n        this.editorAttrs = {};\n        this.contentAttrs = {};\n        this.themeCache = Object.create(null);\n        this.themeCacheFor = [];\n        /// @internal\n        this.updateState = 2 /* Updating */;\n        /// @internal\n        this.waiting = [];\n        this.contentDOM = document.createElement(\"div\");\n        this.scrollDOM = document.createElement(\"div\");\n        this.scrollDOM.appendChild(this.contentDOM);\n        this.dom = document.createElement(\"div\");\n        this.dom.appendChild(this.scrollDOM);\n        this.dispatch = config.dispatch || ((tr) => this.update([tr]));\n        this.root = (config.root || document);\n        this.docView = new DocView(this, (start, end, typeOver) => applyDOMChange(this, start, end, typeOver));\n        let state = config.state || _state__WEBPACK_IMPORTED_MODULE_0__[\"EditorState\"].create();\n        this.extensions = config.extensions || [];\n        this.configure(state.configuration.foreign);\n        this.inputState = new InputState(this);\n        this.docView.init(state, viewport => {\n            this._viewport = viewport;\n            this._state = state;\n            for (let plugin of this.behavior(viewPlugin)) {\n                let exists = this.plugins[plugin.id];\n                if (exists)\n                    throw new Error(`Duplicated view plugin${(exists.constructor || Object) != Object && exists.constructor.name ? ` (${exists.constructor.name})` : ''}`);\n                this.plugins[plugin.id] = plugin.create(this);\n            }\n        });\n        this.mountStyles();\n        this.updateAttrs();\n        this.updateState = 0 /* Idle */;\n        ensureGlobalHandler();\n    }\n    /// The current editor state.\n    get state() { return this._state; }\n    /// To be able to display large documents without consuming too much\n    /// memory or overloading the browser, CodeMirror only draws the\n    /// code that is visible, plus a margin around it, to the DOM. This\n    /// property tells you the extent of the current drawn viewport, in\n    /// document positions.\n    get viewport() { return this._viewport; }\n    /// Update the view for the given array of transactions. This will\n    /// update the visible document and selection to match the state\n    /// produced by the transactions, and notify view plugins of the\n    /// change.\n    update(transactions = [], annotations = []) {\n        if (this.updateState != 0 /* Idle */)\n            throw new Error(\"Calls to EditorView.update are not allowed while an update is in progress\");\n        this.updateState = 2 /* Updating */;\n        this.clearWaiting();\n        let state = this.state, prevForeign = state.configuration.foreign;\n        for (let tr of transactions) {\n            if (tr.startState != state)\n                throw new RangeError(\"Trying to update state with a transaction that doesn't start from the current state.\");\n            state = tr.apply();\n        }\n        let curForeign = state.configuration.foreign;\n        if (curForeign != prevForeign) {\n            this.configure(curForeign);\n            this.updatePlugins();\n        }\n        let update = transactions.length > 0 || annotations.length > 0 ? new ViewUpdate(this, transactions, annotations) : null;\n        if (state.doc != this.state.doc || transactions.some(tr => tr.selectionSet && !tr.annotation(_state__WEBPACK_IMPORTED_MODULE_0__[\"Transaction\"].preserveGoalColumn)))\n            this.inputState.goalColumns.length = 0;\n        this.docView.update(update, transactions.some(tr => tr.scrolledIntoView) ? state.selection.primary.head : -1);\n        if (update) {\n            this.inputState.ensureHandlers(this);\n            this.drawPlugins();\n            if (this.behavior(styleModule) != this.styleModules)\n                this.mountStyles();\n        }\n        this.updateAttrs();\n        this.updateState = 0 /* Idle */;\n    }\n    /// Wait for the given promise to resolve, and then run an update.\n    /// Or, if an update happens before that, set the promise's\n    /// `canceled` property to true and ignore it.\n    waitFor(promise) {\n        promise.then(() => {\n            if (!promise.canceled)\n                this.update([], [notified(true)]);\n        });\n        this.waiting.push(promise);\n    }\n    clearWaiting() {\n        for (let promise of this.waiting)\n            promise.canceled = true;\n        this.waiting.length = 0;\n    }\n    /// @internal\n    updateAttrs() {\n        let editorAttrs = this.behavior(editorAttributes), contentAttrs = this.behavior(contentAttributes);\n        updateAttrs(this.dom, this.editorAttrs, editorAttrs);\n        this.editorAttrs = editorAttrs;\n        updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);\n        this.contentAttrs = contentAttrs;\n        this.scrollDOM.className = this.cssClass(\"scroller\") + \" \" + styles.scroller;\n    }\n    configure(fromState) {\n        this.configuration = extendView.resolve([defaultAttrs].concat(this.extensions).concat(fromState));\n        if (this.configuration.foreign.length)\n            throw new Error(\"Non-view extensions found in view\");\n    }\n    updatePlugins() {\n        let old = this.plugins;\n        this.plugins = Object.create(null);\n        for (let plugin of this.behavior(viewPlugin))\n            this.plugins[plugin.id] = Object.prototype.hasOwnProperty.call(old, plugin.id) ? old[plugin.id] : plugin.create(this);\n    }\n    mountStyles() {\n        this.styleModules = this.behavior(styleModule);\n        style_mod__WEBPACK_IMPORTED_MODULE_1__[\"StyleModule\"].mount(this.root, this.styleModules.concat(styles).reverse());\n    }\n    /// @internal\n    drawPlugins() {\n        for (let plugin of this.behavior(viewPlugin)) {\n            let value = this.plugins[plugin.id];\n            if (value.draw) {\n                try {\n                    value.draw();\n                }\n                catch (e) {\n                    console.error(e);\n                }\n            }\n        }\n        this.updateAttrs();\n    }\n    /// Get an instance of the given plugin class, or `undefined` if\n    /// none exists in this view.\n    plugin(plugin) {\n        let result = this.plugins[plugin.id];\n        if (result === undefined && this.behavior(viewPlugin).indexOf(plugin) > -1)\n            throw new Error(\"Accessing a plugin from another plugin with higher precedence\");\n        return result;\n    }\n    /// Get the value of a view behavior.\n    behavior(behavior) {\n        return this.configuration.getBehavior(behavior, this);\n    }\n    /// @internal\n    updateInner(update, viewport) {\n        this._viewport = viewport;\n        this._state = update.state;\n        // FIXME separate plugins from behavior cache?\n        let oldPlugins = this.plugins;\n        this.plugins = Object.create(null);\n        for (let plugin of this.behavior(viewPlugin)) {\n            let value = this.plugins[plugin.id] = oldPlugins[plugin.id];\n            if (value.update) {\n                try {\n                    value.update(update);\n                }\n                catch (e) {\n                    console.error(e);\n                    this.plugins[plugin.id] = { update() { } };\n                }\n            }\n        }\n    }\n    /// Query the active themes for the CSS class names associated with\n    /// the given name. Names can be single words or words separated by\n    /// dot characters. In the latter case, the returned classes combine\n    /// those that match the full name and those that match some\n    /// prefixâ€”for example `cssClass(\"panel.search\")` will match both\n    /// the theme styles specified as `\"panel.search\"` and those with\n    /// just `\"panel\"`. More specific theme styles (with more dots) take\n    /// precedence.\n    cssClass(selector) {\n        let themes = this.behavior(theme);\n        if (themes != this.themeCacheFor) {\n            this.themeCache = Object.create(null);\n            this.themeCacheFor = themes;\n        }\n        else {\n            let known = this.themeCache[selector];\n            if (known != null)\n                return known;\n        }\n        let result = \"\";\n        for (let pos = 0;;) {\n            let dot = selector.indexOf(\".\", pos);\n            let cls = dot < 0 ? selector : selector.slice(0, dot);\n            result += (result ? \" \" : \"\") + \"codemirror-\" + (pos ? cls.replace(/\\./g, \"-\") : cls);\n            for (let theme of themes) {\n                let has = theme[cls];\n                if (has)\n                    result += \" \" + has;\n            }\n            if (dot < 0)\n                break;\n            pos = dot + 1;\n        }\n        return this.themeCache[selector] = result;\n    }\n    /// Look up a translation for the given phrase (via the\n    /// [`phrases`](#view.EditorView^phrases) behavior), or return the\n    /// original string if no translation is found.\n    phrase(phrase) {\n        for (let map of this.behavior(phrases)) {\n            if (Object.prototype.hasOwnProperty.call(map, phrase))\n                return map[phrase];\n        }\n        return phrase;\n    }\n    /// Find the DOM parent node and offset (child offset if `node` is\n    /// an element, character offset when it is a text node) at the\n    /// given document position.\n    domAtPos(pos) {\n        return this.docView.domAtPos(pos);\n    }\n    /// Find the document position at the given DOM node. Can be useful\n    /// for associating positions with DOM events. Will raise an error\n    /// when `node` isn't part of the editor content.\n    posAtDOM(node, offset = 0) {\n        return this.docView.posFromDOM(node, offset);\n    }\n    readingLayout() {\n        if (this.updateState == 2 /* Updating */)\n            throw new Error(\"Reading the editor layout isn't allowed during an update\");\n        if (this.updateState == 0 /* Idle */ && this.docView.layoutCheckScheduled > -1)\n            this.docView.checkLayout();\n    }\n    /// Make sure plugins get a chance to measure the DOM before the\n    /// next frame. Calling this is preferable to messing with the DOM\n    /// directly from, for example, an even handler, because it'll make\n    /// sure measuring and drawing done by other components is\n    /// synchronized, avoiding unnecessary DOM layout computations.\n    requireMeasure() {\n        this.docView.scheduleLayoutCheck();\n    }\n    /// Find the line or block widget at the given vertical position.\n    /// `editorTop`, if given, provides the vertical position of the top\n    /// of the editor. It defaults to the editor's screen position\n    /// (which will force a DOM layout).\n    blockAtHeight(height, editorTop) {\n        this.readingLayout();\n        return this.docView.blockAtHeight(height, editorTop);\n    }\n    /// Find information for the line at the given vertical position.\n    /// The resulting block info might hold another array of block info\n    /// structs in its `type` field if this line consists of more than\n    /// one block.\n    lineAtHeight(height, editorTop) {\n        this.readingLayout();\n        return this.docView.lineAtHeight(height, editorTop);\n    }\n    /// Find the height information for the given line.\n    lineAt(pos, editorTop) {\n        this.readingLayout();\n        return this.docView.lineAt(pos, editorTop);\n    }\n    /// Iterate over the height information of the lines in the\n    /// viewport.\n    viewportLines(f, editorTop) {\n        let { from, to } = this._viewport;\n        this.docView.forEachLine(from, to, f, editorTop);\n    }\n    /// The editor's total content height.\n    get contentHeight() {\n        return this.docView.heightMap.height + this.docView.paddingTop + this.docView.paddingBottom;\n    }\n    /// Compute cursor motion from the given position, in the given\n    /// direction, by the given unit. Since this might involve\n    /// temporarily mutating the DOM selection, you can pass the action\n    /// type this will be used for to, in case the editor selection is\n    /// set to the new position right away, avoid an extra DOM selection\n    /// change.\n    movePos(start, direction, granularity = \"character\", action = \"move\") {\n        return movePos(this, start, direction, granularity, action);\n    }\n    /// Get the document position at the given screen coordinates.\n    /// Returns -1 if no valid position could be found.\n    posAtCoords(coords) {\n        this.readingLayout();\n        return posAtCoords(this, coords);\n    }\n    /// Get the screen coordinates at the given document position.\n    coordsAtPos(pos) {\n        this.readingLayout();\n        return this.docView.coordsAt(pos);\n    }\n    /// The default width of a character in the editor. May not\n    /// accurately reflect the width of all characters.\n    get defaultCharacterWidth() { return this.docView.heightOracle.charWidth; }\n    /// The default height of a line in the editor.\n    get defaultLineHeight() { return this.docView.heightOracle.lineHeight; }\n    /// Start a custom mouse selection event.\n    startMouseSelection(event, update) {\n        this.focus();\n        this.inputState.startMouseSelection(this, event, update);\n    }\n    /// Check whether the editor has focus.\n    get hasFocus() {\n        return this.root.activeElement == this.contentDOM;\n    }\n    /// Put focus on the editor.\n    focus() {\n        this.docView.focus();\n    }\n    /// Clean up this editor view, removing its element from the\n    /// document, unregistering event handlers, and notifying\n    /// extensions. The view instance can no longer be used after\n    /// calling this.\n    destroy() {\n        for (let plugin of this.behavior(viewPlugin)) {\n            let value = this.plugins[plugin.id];\n            if (value.destroy) {\n                try {\n                    value.destroy();\n                }\n                catch (e) {\n                    console.error(e);\n                }\n            }\n        }\n        this.inputState.destroy();\n        this.dom.remove();\n        this.docView.destroy();\n    }\n    /// Behavior that provides CSS classes to add to elements identified\n    /// by the given string.\n    static theme(spec) {\n        for (let prop in spec) {\n            let specificity = prop.split(\".\").length - 1;\n            if (specificity > 0)\n                spec[prop].specificity = specificity;\n        }\n        let module = new style_mod__WEBPACK_IMPORTED_MODULE_1__[\"StyleModule\"](spec);\n        return [theme(module), styleModule(module)];\n    }\n}\n/// The view extension group, used to define new view extensions.\nEditorView.extend = extendView;\n/// Behavior to add a [style\n/// module](https://github.com/marijnh/style-mod#readme) to an editor\n/// view. The view will ensure that the module is registered in its\n/// [document root](#view.EditorConfig.root).\nEditorView.styleModule = styleModule;\n/// Behavior that can be used to add DOM event handlers. The value\n/// should be an object mapping event names to handler functions. The\n/// first such function to return true will be assumed to have handled\n/// that event, and no other handlers or built-in behavior will be\n/// activated for it.\nEditorView.handleDOMEvents = handleDOMEvents;\n/// Behavior used to configure whether a given selection drag event\n/// should move or copy the selection. The given predicate will be\n/// called with the `mousedown` event, and can return `true` when\n/// the drag should move the content.\nEditorView.dragMovesSelection = dragMovesSelection;\n/// Behavior used to configure whether a given selecting click adds\n/// a new range to the existing selection or replaces it entirely.\nEditorView.clickAddsSelectionRange = clickAddsSelectionRange;\n/// A behavior that determines which [decorations](#view.Decoration)\n/// are shown in the view.\nEditorView.decorations = decorations;\n/// Registers translation phrases. The\n/// [`phrase`](#view.EditorView.phrase) method will look through all\n/// objects registered with this behavior to find translations for\n/// its argument.\nEditorView.phrases = phrases;\n/// This behavior can be used to indicate that, when scrolling\n/// something into view, certain parts at the side of the editor\n/// should be scrolled past (for example because there is a gutter\n/// or panel blocking them from view).\nEditorView.scrollMargins = scrollMargins;\n/// Behavior that provides attributes for the editor's editable DOM\n/// element.\nEditorView.contentAttributes = contentAttributes;\n/// Behavior that provides editor DOM attributes for the editor's\n/// outer element.\nEditorView.editorAttributes = editorAttributes;\n/// An annotation that is used as a flag in view updates caused by\n/// changes to the view's focus state. Its value will be `true` when\n/// the view is being focused, `false` when it's losing focus.\nEditorView.focusChange = focusChange;\nconst defaultAttrs = [\n    extendView.dynamic(editorAttributes, view => ({\n        class: \"codemirror \" + styles.wrapper + (view.hasFocus ? \" codemirror-focused \" : \" \") + view.cssClass(\"wrap\")\n    })),\n    extendView.dynamic(contentAttributes, view => ({\n        spellcheck: \"false\",\n        contenteditable: \"true\",\n        class: styles.content + \" \" + view.cssClass(\"content\"),\n        style: `${browser.tabSize}: ${view.state.tabSize}`\n    }))\n];\nlet resizeDebounce = -1;\nfunction ensureGlobalHandler() {\n    window.addEventListener(\"resize\", () => {\n        if (resizeDebounce == -1)\n            resizeDebounce = setTimeout(handleResize, 50);\n    });\n}\nfunction handleResize() {\n    resizeDebounce = -1;\n    let found = document.querySelectorAll(\".codemirror-content\");\n    for (let i = 0; i < found.length; i++) {\n        let docView = found[i].cmView;\n        if (docView)\n            docView.editorView.update([], [notified(true)]); // FIXME remove need to pass an annotation?\n    }\n}\n\n/// @internal\nconst __test = { HeightMap, HeightOracle, MeasuredHeights, QueryType };\n\n\n\n\n//# sourceURL=webpack:///./node_modules/@codemirror/next/view/dist/index.es.js?");

/***/ }),

/***/ "./node_modules/lezer-tree/dist/tree.js":
/*!**********************************************!*\
  !*** ./node_modules/lezer-tree/dist/tree.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/// The default maximum length of a `TreeBuffer` node.\nexports.DefaultBufferLength = 1024;\nvar Iteration = /** @class */ (function () {\n    function Iteration(enter, leave) {\n        this.enter = enter;\n        this.leave = leave;\n        this.result = undefined;\n    }\n    Object.defineProperty(Iteration.prototype, \"done\", {\n        get: function () { return this.result !== undefined; },\n        enumerable: true,\n        configurable: true\n    });\n    Iteration.prototype.doEnter = function (type, start, end) {\n        var value = this.enter(type, start, end);\n        if (value === undefined)\n            return true;\n        if (value !== false)\n            this.result = value;\n        return false;\n    };\n    return Iteration;\n}());\nvar nextPropID = 0;\n/// Each [node type](#tree.NodeType) can have metadata associated with\n/// it in props. Instances of this class represent prop names.\nvar NodeProp = /** @class */ (function () {\n    /// Create a new node prop type. You can optionally pass a\n    /// `deserialize` function.\n    function NodeProp(_a) {\n        var deserialize = (_a === void 0 ? {} : _a).deserialize;\n        this.id = nextPropID++;\n        this.deserialize = deserialize || (function () {\n            throw new Error(\"This node type doesn't define a deserialize function\");\n        });\n    }\n    /// Create a string-valued node prop whose deserialize function is\n    /// the identity function.\n    NodeProp.string = function () { return new NodeProp({ deserialize: function (str) { return str; } }); };\n    /// Creates a boolean-valued node prop whose deserialize function\n    /// returns true for any input.\n    NodeProp.flag = function () { return new NodeProp({ deserialize: function () { return true; } }); };\n    /// Store a value for this prop in the given object. This can be\n    /// useful when building up a prop object to pass to the\n    /// [`NodeType`](#tree.NodeType) constructor. Returns its first\n    /// argument.\n    NodeProp.prototype.set = function (propObj, value) {\n        propObj[this.id] = value;\n        return propObj;\n    };\n    /// This is meant to be used with\n    /// [`NodeGroup.extend`](#tree.NodeGroup.extend) or\n    /// [`Parser.withProps`](#lezer.Parser.withProps) to compute prop\n    /// values for each node type in the group. Takes a [match\n    /// object](#tree.NodeType.match) or function that returns undefined\n    /// if the node type doesn't get this prop, and the prop's value if\n    /// it does.\n    NodeProp.prototype.add = function (match) {\n        return new NodePropSource(this, typeof match == \"function\" ? match : NodeType.match(match));\n    };\n    /// The special node type that the parser uses to represent parse\n    /// errors has this flag set. (You shouldn't use it for custom nodes\n    /// that represent erroneous content.)\n    NodeProp.error = NodeProp.flag();\n    /// Nodes that were produced by skipped expressions (such as\n    /// comments) have this prop set to true.\n    NodeProp.skipped = NodeProp.flag();\n    /// Prop that is used to describe a rule's delimiters. For example,\n    /// a parenthesized expression node would set this to the string `\"(\n    /// )\"` (the open and close strings separated by a space). This is\n    /// added by the parser generator's `@detectDelim` feature, but you\n    /// can also manually add them.\n    NodeProp.delim = NodeProp.string();\n    /// Indicates that this node indicates a top level document.\n    NodeProp.top = NodeProp.flag();\n    /// A prop that indicates whether a node represents a repeated\n    /// expression. Abstractions like [`Subtree`](#tree.Subtree) hide\n    /// such nodes, so you usually won't see them, but if you directly\n    /// rummage through a tree's children, you'll find repeat nodes that\n    /// wrap repeated content into balanced trees.\n    NodeProp.repeated = NodeProp.flag();\n    return NodeProp;\n}());\nexports.NodeProp = NodeProp;\n/// Type returned by [`NodeProp.add`](#tree.NodeProp.add). Describes\n/// the way a prop should be added to each node type in a node group.\nvar NodePropSource = /** @class */ (function () {\n    /// @internal\n    function NodePropSource(\n    /// @internal\n    prop, \n    /// @internal\n    f) {\n        this.prop = prop;\n        this.f = f;\n    }\n    return NodePropSource;\n}());\nexports.NodePropSource = NodePropSource;\n/// Each node in a syntax tree has a node type associated with it.\nvar NodeType = /** @class */ (function () {\n    /// @internal\n    function NodeType(\n    /// The name of the node type. Not necessarily unique, but if the\n    /// grammar was written properly, different node types with the\n    /// same name within a node group should play the same semantic\n    /// role.\n    name, \n    /// @internal\n    props, \n    /// The id of this node in its group. Corresponds to the term ids\n    /// used in the parser.\n    id) {\n        this.name = name;\n        this.props = props;\n        this.id = id;\n    }\n    /// Retrieves a node prop for this type. Will return `undefined` if\n    /// the prop isn't present on this node.\n    NodeType.prototype.prop = function (prop) { return this.props[prop.id]; };\n    /// Create a function from node types to arbitrary values by\n    /// specifying an object whose property names are node names. Often\n    /// useful with [`NodeProp.add`](#tree.NodeProp.add). You can put\n    /// multiple node names, separated by spaces, in a single property\n    /// name to map multiple node names to a single value.\n    NodeType.match = function (map) {\n        var direct = Object.create(null);\n        for (var prop in map)\n            for (var _i = 0, _a = prop.split(\" \"); _i < _a.length; _i++) {\n                var name = _a[_i];\n                direct[name] = map[prop];\n            }\n        return function (node) { return direct[node.name]; };\n    };\n    /// An empty dummy node type to use when no actual type is available.\n    NodeType.none = new NodeType(\"\", Object.create(null), 0);\n    return NodeType;\n}());\nexports.NodeType = NodeType;\n/// A node group holds a collection of node types. It is used to\n/// compactly represent trees by storing their type ids, rather than a\n/// full pointer to the type object, in a number array. Each parser\n/// [has](#lezer.Parser.group) a node group, and [tree\n/// buffers](#tree.TreeBuffer) can only store collections of nodes\n/// from the same group. A group can have a maximum of 2**16 (65536)\n/// node types in it, so that the ids fit into 16-bit typed array\n/// slots.\nvar NodeGroup = /** @class */ (function () {\n    /// Create a group with the given types. The `id` property of each\n    /// type should correspond to its position within the array.\n    function NodeGroup(\n    /// The node types in this group, by id.\n    types) {\n        this.types = types;\n        for (var i = 0; i < types.length; i++)\n            if (types[i].id != i)\n                throw new RangeError(\"Node type ids should correspond to array positions when creating a node group\");\n    }\n    /// Create a copy of this group with some node properties added. The\n    /// arguments to this method should be created with\n    /// [`NodeProp.add`](#tree.NodeProp.add).\n    NodeGroup.prototype.extend = function () {\n        var props = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            props[_i] = arguments[_i];\n        }\n        var newTypes = [];\n        for (var _a = 0, _b = this.types; _a < _b.length; _a++) {\n            var type = _b[_a];\n            var newProps = null;\n            for (var _c = 0, props_1 = props; _c < props_1.length; _c++) {\n                var source = props_1[_c];\n                var value = source.f(type);\n                if (value !== undefined) {\n                    if (!newProps) {\n                        newProps = Object.create(null);\n                        for (var prop in type.props)\n                            newProps[prop] = type.props[prop];\n                    }\n                    newProps[source.prop.id] = value;\n                }\n            }\n            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id) : type);\n        }\n        return new NodeGroup(newTypes);\n    };\n    return NodeGroup;\n}());\nexports.NodeGroup = NodeGroup;\n/// A subtree is a representation of part of the syntax tree. It may\n/// either be the tree root, or a tagged node.\nvar Subtree = /** @class */ (function () {\n    function Subtree() {\n    }\n    Object.defineProperty(Subtree.prototype, \"name\", {\n        // Shorthand for `.type.name`.\n        get: function () { return this.type.name; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Subtree.prototype, \"depth\", {\n        /// The depth (number of parent nodes) of this subtree\n        get: function () {\n            var d = 0;\n            for (var p = this.parent; p; p = p.parent)\n                d++;\n            return d;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Subtree.prototype, \"root\", {\n        /// The root of the tree that this subtree is part of\n        get: function () {\n            var cx = this;\n            while (cx.parent)\n                cx = cx.parent;\n            return cx;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /// Find the node at a given position. By default, this will return\n    /// the lowest-depth subtree that covers the position from both\n    /// sides, meaning that nodes starting or ending at the position\n    /// aren't entered. You can pass a `side` of `-1` to enter nodes\n    /// that end at the position, or `1` to enter nodes that start\n    /// there.\n    Subtree.prototype.resolve = function (pos, side) {\n        if (side === void 0) { side = 0; }\n        var result = this.resolveAt(pos);\n        // FIXME this is slightly inefficient in that it scans the result\n        // of resolveAt twice (but further complicating child-finding\n        // logic seems unattractive as well)\n        if (side != 0)\n            for (;;) {\n                var child = (side < 0 ? result.childBefore(pos) : result.childAfter(pos));\n                if (!child || (side < 0 ? child.end : child.start) != pos)\n                    break;\n                result = child;\n            }\n        return result;\n    };\n    Object.defineProperty(Subtree.prototype, \"firstChild\", {\n        /// Get the first child of this subtree.\n        get: function () { return this.childAfter(this.start - 1); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Subtree.prototype, \"lastChild\", {\n        /// Find the last child of this subtree.\n        get: function () { return this.childBefore(this.end + 1); },\n        enumerable: true,\n        configurable: true\n    });\n    return Subtree;\n}());\nexports.Subtree = Subtree;\n/// A piece of syntax tree. There are two ways to approach these\n/// trees: the way they are actually stored in memory, and the\n/// convenient way.\n///\n/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`\n/// objects. By packing detail information into `TreeBuffer` leaf\n/// nodes, the representation is made a lot more memory-efficient.\n///\n/// However, when you want to actually work with tree nodes, this\n/// representation is very awkward, so most client code will want to\n/// use the `Subtree` interface instead, which provides a view on some\n/// part of this data structure, and can be used (through `resolve`,\n/// for example) to zoom in on any single node.\nvar Tree = /** @class */ (function (_super) {\n    __extends(Tree, _super);\n    /// @internal\n    function Tree(\n    /// @internal\n    type, \n    /// The tree's child nodes. Children small enough to fit in a\n    /// `TreeBuffer` will be represented as such, other children can be\n    /// further `Tree` instances with their own internal structure.\n    children, \n    /// The positions (offsets relative to the start of this tree) of\n    /// the children.\n    positions, \n    /// The total length of this tree @internal\n    length) {\n        var _this = _super.call(this) || this;\n        _this.type = type;\n        _this.children = children;\n        _this.positions = positions;\n        _this.length = length;\n        return _this;\n    }\n    Object.defineProperty(Tree.prototype, \"start\", {\n        /// @internal\n        get: function () { return 0; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Tree.prototype, \"end\", {\n        /// @internal\n        get: function () { return this.length; },\n        enumerable: true,\n        configurable: true\n    });\n    /// @internal\n    Tree.prototype.toString = function () {\n        var children = this.children.map(function (c) { return c.toString(); }).join();\n        return !this.name ? children :\n            (/\\W/.test(this.name) && !this.type.prop(NodeProp.error) ? JSON.stringify(this.name) : this.name) +\n                (children.length ? \"(\" + children + \")\" : \"\");\n    };\n    Tree.prototype.partial = function (start, end, offset, children, positions) {\n        for (var i = 0; i < this.children.length; i++) {\n            var from = this.positions[i];\n            if (from > end)\n                break;\n            var child = this.children[i], to = from + child.length;\n            if (to < start)\n                continue;\n            if (start <= from && end >= to) {\n                children.push(child);\n                positions.push(from + offset);\n            }\n            else if (child instanceof Tree) {\n                child.partial(start - from, end - from, offset + from, children, positions);\n            }\n        }\n    };\n    /// Apply a set of edits to a tree, removing all nodes that were\n    /// touched by the edits, and moving remaining nodes so that their\n    /// positions are updated for insertions/deletions before them. This\n    /// is likely to destroy a lot of the structure of the tree, and\n    /// mostly useful for extracting the nodes that can be reused in a\n    /// subsequent incremental re-parse.\n    Tree.prototype.applyChanges = function (changes) {\n        if (changes.length == 0)\n            return this;\n        var children = [], positions = [];\n        function cutAt(tree, pos, side) {\n            var sub = tree.resolve(pos);\n            for (var cur = pos;;) {\n                var sibling = side < 0 ? sub.childBefore(cur) : sub.childAfter(cur);\n                if (sibling)\n                    return side < 0 ? sibling.end - 1 : sibling.start + 1;\n                if (!sub.parent)\n                    return side < 0 ? 0 : 1e9;\n                cur = side < 0 ? sub.start : sub.end;\n                sub = sub.parent;\n            }\n        }\n        var off = 0;\n        for (var i = 0, pos = 0;; i++) {\n            var next = i == changes.length ? null : changes[i];\n            var nextPos = next ? cutAt(this, next.fromA, -1) : this.length;\n            if (nextPos > pos)\n                this.partial(pos, nextPos, off, children, positions);\n            if (!next)\n                break;\n            pos = cutAt(this, next.toA, 1);\n            off += (next.toB - next.fromB) - (next.toA - next.fromA);\n        }\n        return new Tree(NodeType.none, children, positions, this.length + off);\n    };\n    /// Take the part of the tree up to the given position.\n    Tree.prototype.cut = function (at) {\n        if (at >= this.length)\n            return this;\n        var children = [], positions = [];\n        for (var i = 0; i < this.children.length; i++) {\n            var from = this.positions[i];\n            if (from >= at)\n                break;\n            var child = this.children[i], to = from + child.length;\n            children.push(to <= at ? child : child.cut(at - from));\n            positions.push(from);\n        }\n        return new Tree(this.type, children, positions, at);\n    };\n    /// @internal\n    Tree.prototype.iterate = function (_a) {\n        var _b = _a.from, from = _b === void 0 ? this.start : _b, _c = _a.to, to = _c === void 0 ? this.end : _c, enter = _a.enter, leave = _a.leave;\n        var iter = new Iteration(enter, leave);\n        this.iterInner(from, to, 0, iter);\n        return iter.result;\n    };\n    /// @internal\n    Tree.prototype.iterInner = function (from, to, offset, iter) {\n        if (this.type.name && !iter.doEnter(this.type, offset, offset + this.length))\n            return;\n        if (from <= to) {\n            for (var i = 0; i < this.children.length && !iter.done; i++) {\n                var child = this.children[i], start = this.positions[i] + offset, end = start + child.length;\n                if (start > to)\n                    break;\n                if (end < from)\n                    continue;\n                child.iterInner(from, to, start, iter);\n            }\n        }\n        else {\n            for (var i = this.children.length - 1; i >= 0 && !iter.done; i--) {\n                var child = this.children[i], start = this.positions[i] + offset, end = start + child.length;\n                if (end < to)\n                    break;\n                if (start > from)\n                    continue;\n                child.iterInner(from, to, start, iter);\n            }\n        }\n        if (iter.leave && this.type.name)\n            iter.leave(this.type, offset, offset + this.length);\n        return;\n    };\n    /// @internal\n    Tree.prototype.resolveAt = function (pos) {\n        if (cacheRoot == this) {\n            for (var tree = cached;;) {\n                var next = tree.parent;\n                if (!next)\n                    break;\n                if (tree.start < pos && tree.end > pos)\n                    return tree.resolve(pos);\n                tree = next;\n            }\n        }\n        cacheRoot = this;\n        return cached = this.resolveInner(pos, 0, this);\n    };\n    /// @internal\n    Tree.prototype.childBefore = function (pos) {\n        return this.findChild(pos, -1, 0, this);\n    };\n    /// @internal\n    Tree.prototype.childAfter = function (pos) {\n        return this.findChild(pos, 1, 0, this);\n    };\n    /// @internal\n    Tree.prototype.findChild = function (pos, side, start, parent) {\n        for (var i = 0; i < this.children.length; i++) {\n            var childStart = this.positions[i] + start, select = -1;\n            if (childStart >= pos) {\n                if (side < 0 && i > 0)\n                    select = i - 1;\n                else if (side > 0)\n                    select = i;\n                else\n                    break;\n            }\n            if (select < 0 && (childStart + this.children[i].length > pos || side < 0 && i == this.children.length - 1))\n                select = i;\n            if (select >= 0) {\n                var child = this.children[select], childStart_1 = this.positions[select] + start;\n                if (child.length == 0 && childStart_1 == pos)\n                    continue;\n                if (child instanceof Tree) {\n                    if (child.type.name)\n                        return new NodeSubtree(child, childStart_1, parent);\n                    return child.findChild(pos, side, childStart_1, parent);\n                }\n                else {\n                    var found = child.findIndex(pos, side, childStart_1, 0, child.buffer.length);\n                    if (found > -1)\n                        return new BufferSubtree(child, childStart_1, found, parent);\n                }\n            }\n        }\n        return null;\n    };\n    /// @internal\n    Tree.prototype.resolveInner = function (pos, start, parent) {\n        var found = this.findChild(pos, 0, start, parent);\n        return found ? found.resolveAt(pos) : parent;\n    };\n    /// Append another tree to this tree. `other` must have empty space\n    /// big enough to fit this tree at its start.\n    Tree.prototype.append = function (other) {\n        if (other.children.length && other.positions[0] < this.length)\n            throw new Error(\"Can't append overlapping trees\");\n        return new Tree(this.type, this.children.concat(other.children), this.positions.concat(other.positions), other.length);\n    };\n    /// Balance the direct children of this tree. Should only be used on\n    /// non-tagged trees.\n    Tree.prototype.balance = function (maxBufferLength) {\n        if (maxBufferLength === void 0) { maxBufferLength = exports.DefaultBufferLength; }\n        return this.children.length <= BalanceBranchFactor ? this :\n            balanceRange(this.type, this.children, this.positions, 0, this.children.length, 0, maxBufferLength);\n    };\n    /// Build a tree from a postfix-ordered buffer of node information,\n    /// or a cursor over such a buffer.\n    Tree.build = function (buffer, group, topID, maxBufferLength, reused) {\n        if (topID === void 0) { topID = 0; }\n        if (maxBufferLength === void 0) { maxBufferLength = exports.DefaultBufferLength; }\n        if (reused === void 0) { reused = []; }\n        return buildTree(Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer, group, topID, maxBufferLength, reused);\n    };\n    /// The empty tree\n    Tree.empty = new Tree(NodeType.none, [], [], 0);\n    return Tree;\n}(Subtree));\nexports.Tree = Tree;\nTree.prototype.parent = null;\n// Top-level `resolveAt` calls store their last result here, so that\n// if the next call is near the last, parent trees can be cheaply\n// reused.\nvar cacheRoot = Tree.empty;\nvar cached = Tree.empty;\n/// Tree buffers contain (type, start, end, endIndex) quads for each\n/// node. In such a buffer, nodes are stored in prefix order (parents\n/// before children, with the endIndex of the parent indicating which\n/// children belong to it)\nvar TreeBuffer = /** @class */ (function () {\n    /// Create a tree buffer @internal\n    function TreeBuffer(buffer, length, group) {\n        this.buffer = buffer;\n        this.length = length;\n        this.group = group;\n    }\n    /// @internal\n    TreeBuffer.prototype.toString = function () {\n        var parts = [];\n        for (var index = 0; index < this.buffer.length;)\n            index = this.childToString(index, parts);\n        return parts.join(\",\");\n    };\n    /// @internal\n    TreeBuffer.prototype.childToString = function (index, parts) {\n        var id = this.buffer[index], endIndex = this.buffer[index + 3];\n        var type = this.group.types[id], result = type.name;\n        if (/\\W/.test(result) && !type.prop(NodeProp.error))\n            result = JSON.stringify(result);\n        index += 4;\n        if (endIndex > index) {\n            var children = [];\n            while (index < endIndex)\n                index = this.childToString(index, children);\n            result += \"(\" + children.join(\",\") + \")\";\n        }\n        parts.push(result);\n        return index;\n    };\n    /// @internal\n    TreeBuffer.prototype.cut = function (at) {\n        var cutPoint = 0;\n        while (cutPoint < this.buffer.length && this.buffer[cutPoint + 1] < at)\n            cutPoint += 4;\n        var newBuffer = new Uint16Array(cutPoint);\n        for (var i = 0; i < cutPoint; i += 4) {\n            newBuffer[i] = this.buffer[i];\n            newBuffer[i + 1] = this.buffer[i + 1];\n            newBuffer[i + 2] = Math.min(at, this.buffer[i + 2]);\n            newBuffer[i + 3] = Math.min(this.buffer[i + 3], cutPoint);\n        }\n        return new TreeBuffer(newBuffer, Math.min(at, this.length), this.group);\n    };\n    /// @internal\n    TreeBuffer.prototype.iterInner = function (from, to, offset, iter) {\n        if (from <= to) {\n            for (var index = 0; index < this.buffer.length;)\n                index = this.iterChild(from, to, offset, index, iter);\n        }\n        else {\n            this.iterRev(from, to, offset, 0, this.buffer.length, iter);\n        }\n    };\n    /// @internal\n    TreeBuffer.prototype.iterChild = function (from, to, offset, index, iter) {\n        var type = this.group.types[this.buffer[index++]], start = this.buffer[index++] + offset, end = this.buffer[index++] + offset, endIndex = this.buffer[index++];\n        if (start > to)\n            return this.buffer.length;\n        if (end >= from && iter.doEnter(type, start, end)) {\n            while (index < endIndex && !iter.done)\n                index = this.iterChild(from, to, offset, index, iter);\n            if (iter.leave)\n                iter.leave(type, start, end);\n        }\n        return endIndex;\n    };\n    TreeBuffer.prototype.parentNodesByEnd = function (startIndex, endIndex) {\n        var _this = this;\n        // Build up an array of node indices reflecting the order in which\n        // non-empty nodes end, to avoid having to scan for parent nodes\n        // at every position during reverse iteration.\n        var order = [];\n        var scan = function (index) {\n            var end = _this.buffer[index + 3];\n            if (end == index + 4)\n                return end;\n            for (var i = index + 4; i < end;)\n                i = scan(i);\n            order.push(index);\n            return end;\n        };\n        for (var index = startIndex; index < endIndex;)\n            index = scan(index);\n        return order;\n    };\n    /// @internal\n    TreeBuffer.prototype.iterRev = function (from, to, offset, startIndex, endIndex, iter) {\n        var _this = this;\n        var endOrder = this.parentNodesByEnd(startIndex, endIndex);\n        // Index range for the next non-empty node\n        var nextStart = -1, nextEnd = -1;\n        var takeNext = function () {\n            if (endOrder.length > 0) {\n                nextStart = endOrder.pop();\n                nextEnd = _this.buffer[nextStart + 3];\n            }\n            else {\n                nextEnd = -1;\n            }\n        };\n        takeNext();\n        run: for (var index = endIndex; index > startIndex && !iter.done;) {\n            while (nextEnd == index) {\n                var base = nextStart;\n                var id_1 = this.buffer[base], start_1 = this.buffer[base + 1] + offset, end_1 = this.buffer[base + 2] + offset;\n                takeNext();\n                if (start_1 <= from && end_1 >= to) {\n                    if (!iter.doEnter(this.group.types[id_1], start_1, end_1)) {\n                        // Skip the entire node\n                        index = base;\n                        while (nextEnd > base)\n                            takeNext();\n                        continue run;\n                    }\n                }\n            }\n            var endIndex_1 = this.buffer[--index], end = this.buffer[--index] + offset, start = this.buffer[--index] + offset, id = this.buffer[--index];\n            if (start > from || end < to)\n                continue;\n            if ((endIndex_1 != index + 4 || iter.doEnter(this.group.types[id], start, end)) && iter.leave)\n                iter.leave(this.group.types[id], start, end);\n        }\n    };\n    /// @internal\n    TreeBuffer.prototype.findIndex = function (pos, side, start, from, to) {\n        var lastI = -1;\n        for (var i = from, buf = this.buffer; i < to;) {\n            var start1 = buf[i + 1] + start, end1 = buf[i + 2] + start;\n            var ignore = start1 == end1 && start1 == pos;\n            if (start1 >= pos) {\n                if (side > 0 && !ignore)\n                    return i;\n                break;\n            }\n            if (end1 > pos)\n                return i;\n            if (!ignore)\n                lastI = i;\n            i = buf[i + 3];\n        }\n        return side < 0 ? lastI : -1;\n    };\n    return TreeBuffer;\n}());\nexports.TreeBuffer = TreeBuffer;\nvar NodeSubtree = /** @class */ (function (_super) {\n    __extends(NodeSubtree, _super);\n    function NodeSubtree(node, start, parent) {\n        var _this = _super.call(this) || this;\n        _this.node = node;\n        _this.start = start;\n        _this.parent = parent;\n        return _this;\n    }\n    Object.defineProperty(NodeSubtree.prototype, \"type\", {\n        get: function () { return this.node.type; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NodeSubtree.prototype, \"end\", {\n        get: function () { return this.start + this.node.length; },\n        enumerable: true,\n        configurable: true\n    });\n    NodeSubtree.prototype.resolveAt = function (pos) {\n        if (pos <= this.start || pos >= this.end)\n            return this.parent.resolveAt(pos);\n        return this.node.resolveInner(pos, this.start, this);\n    };\n    NodeSubtree.prototype.childBefore = function (pos) {\n        return this.node.findChild(pos, -1, this.start, this);\n    };\n    NodeSubtree.prototype.childAfter = function (pos) {\n        return this.node.findChild(pos, 1, this.start, this);\n    };\n    NodeSubtree.prototype.toString = function () { return this.node.toString(); };\n    NodeSubtree.prototype.iterate = function (_a) {\n        var _b = _a.from, from = _b === void 0 ? this.start : _b, _c = _a.to, to = _c === void 0 ? this.end : _c, enter = _a.enter, leave = _a.leave;\n        var iter = new Iteration(enter, leave);\n        this.node.iterInner(from, to, this.start, iter);\n        return iter.result;\n    };\n    return NodeSubtree;\n}(Subtree));\nvar BufferSubtree = /** @class */ (function (_super) {\n    __extends(BufferSubtree, _super);\n    function BufferSubtree(buffer, bufferStart, index, parent) {\n        var _this = _super.call(this) || this;\n        _this.buffer = buffer;\n        _this.bufferStart = bufferStart;\n        _this.index = index;\n        _this.parent = parent;\n        return _this;\n    }\n    Object.defineProperty(BufferSubtree.prototype, \"type\", {\n        get: function () { return this.buffer.group.types[this.buffer.buffer[this.index]]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BufferSubtree.prototype, \"start\", {\n        get: function () { return this.buffer.buffer[this.index + 1] + this.bufferStart; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BufferSubtree.prototype, \"end\", {\n        get: function () { return this.buffer.buffer[this.index + 2] + this.bufferStart; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BufferSubtree.prototype, \"endIndex\", {\n        get: function () { return this.buffer.buffer[this.index + 3]; },\n        enumerable: true,\n        configurable: true\n    });\n    BufferSubtree.prototype.childBefore = function (pos) {\n        var index = this.buffer.findIndex(pos, -1, this.bufferStart, this.index + 4, this.endIndex);\n        return index < 0 ? null : new BufferSubtree(this.buffer, this.bufferStart, index, this);\n    };\n    BufferSubtree.prototype.childAfter = function (pos) {\n        var index = this.buffer.findIndex(pos, 1, this.bufferStart, this.index + 4, this.endIndex);\n        return index < 0 ? null : new BufferSubtree(this.buffer, this.bufferStart, index, this);\n    };\n    BufferSubtree.prototype.iterate = function (_a) {\n        var _b = _a.from, from = _b === void 0 ? this.start : _b, _c = _a.to, to = _c === void 0 ? this.end : _c, enter = _a.enter, leave = _a.leave;\n        var iter = new Iteration(enter, leave);\n        if (from <= to)\n            this.buffer.iterChild(from, to, this.bufferStart, this.index, iter);\n        else\n            this.buffer.iterRev(from, to, this.bufferStart, this.index, this.endIndex, iter);\n        return iter.result;\n    };\n    BufferSubtree.prototype.resolveAt = function (pos) {\n        if (pos <= this.start || pos >= this.end)\n            return this.parent.resolveAt(pos);\n        var found = this.buffer.findIndex(pos, 0, this.bufferStart, this.index + 4, this.endIndex);\n        return found < 0 ? this : new BufferSubtree(this.buffer, this.bufferStart, found, this).resolveAt(pos);\n    };\n    BufferSubtree.prototype.toString = function () {\n        var result = [];\n        this.buffer.childToString(this.index, result);\n        return result.join(\"\");\n    };\n    return BufferSubtree;\n}(Subtree));\nvar FlatBufferCursor = /** @class */ (function () {\n    function FlatBufferCursor(buffer, index) {\n        this.buffer = buffer;\n        this.index = index;\n    }\n    Object.defineProperty(FlatBufferCursor.prototype, \"id\", {\n        get: function () { return this.buffer[this.index - 4]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlatBufferCursor.prototype, \"start\", {\n        get: function () { return this.buffer[this.index - 3]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlatBufferCursor.prototype, \"end\", {\n        get: function () { return this.buffer[this.index - 2]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlatBufferCursor.prototype, \"size\", {\n        get: function () { return this.buffer[this.index - 1]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlatBufferCursor.prototype, \"pos\", {\n        get: function () { return this.index; },\n        enumerable: true,\n        configurable: true\n    });\n    FlatBufferCursor.prototype.next = function () { this.index -= 4; };\n    FlatBufferCursor.prototype.fork = function () { return new FlatBufferCursor(this.buffer, this.index); };\n    return FlatBufferCursor;\n}());\nvar BalanceBranchFactor = 8;\nvar repeat = NodeProp.repeated; // Need this one a lot later on\nfunction buildTree(cursor, group, topID, maxBufferLength, reused) {\n    var types = group.types;\n    function takeNode(parentStart, minPos, children, positions) {\n        var id = cursor.id, start = cursor.start, end = cursor.end, size = cursor.size, buffer;\n        var startPos = start - parentStart;\n        if (size < 0) { // Reused node\n            children.push(reused[id]);\n            positions.push(startPos);\n            cursor.next();\n            return;\n        }\n        var type = types[id], node;\n        if (end - start <= maxBufferLength &&\n            (buffer = findBufferSize(cursor.pos - minPos, type.prop(repeat) ? id : -1))) {\n            // Small enough for a buffer, and no reused nodes inside\n            var data = new Uint16Array(buffer.size - buffer.skip);\n            var endPos = cursor.pos - buffer.size, index = data.length;\n            while (cursor.pos > endPos)\n                index = copyToBuffer(buffer.start, data, index);\n            node = new TreeBuffer(data, end - buffer.start, group);\n            // Wrap if this is a repeat node\n            if (type.prop(repeat))\n                node = new Tree(type, [node], [0], end - buffer.start);\n            startPos = buffer.start - parentStart;\n        }\n        else { // Make it a node\n            var endPos = cursor.pos - size;\n            cursor.next();\n            var localChildren = [], localPositions = [];\n            while (cursor.pos > endPos)\n                takeNode(start, endPos, localChildren, localPositions);\n            localChildren.reverse();\n            localPositions.reverse();\n            node = new Tree(type, localChildren, localPositions, end - start);\n        }\n        children.push(node);\n        positions.push(startPos);\n        // End of a (possible) sequence of repeating nodesâ€”might need to balance\n        if (type.prop(repeat) && (cursor.pos == 0 || cursor.id != id))\n            maybeBalanceSiblings(children, positions, type);\n    }\n    function maybeBalanceSiblings(children, positions, type) {\n        var to = children.length, from = to - 1;\n        for (; from > 0; from--) {\n            var prev = children[from - 1];\n            if (!(prev instanceof Tree) || prev.type != type)\n                break;\n        }\n        if (to - from < BalanceBranchFactor)\n            return;\n        var start = positions[to - 1];\n        var wrapped = balanceRange(type, children.slice(from, to).reverse(), positions.slice(from, to).reverse(), 0, to - from, start, maxBufferLength);\n        children.length = positions.length = from + 1;\n        children[from] = wrapped;\n        positions[from] = start;\n    }\n    function findBufferSize(maxSize, id) {\n        // Scan through the buffer to find previous siblings that fit\n        // together in a TreeBuffer, and don't contain any reused nodes\n        // (which can't be stored in a buffer)\n        // If `type` is > -1, only include siblings with that same type\n        // (used to group repeat content into a buffer)\n        var fork = cursor.fork();\n        var size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;\n        scan: for (var minPos = fork.pos - maxSize; fork.pos > minPos;) {\n            var nodeSize = fork.size, startPos = fork.pos - nodeSize;\n            if (nodeSize < 0 || startPos < minPos || fork.start < minStart || id > -1 && fork.id != id)\n                break;\n            var localSkipped = types[fork.id].prop(repeat) ? 4 : 0;\n            var nodeStart = fork.start;\n            fork.next();\n            while (fork.pos > startPos) {\n                if (fork.size < 0)\n                    break scan;\n                if (types[fork.id].prop(repeat))\n                    localSkipped += 4;\n                fork.next();\n            }\n            start = nodeStart;\n            size += nodeSize;\n            skip += localSkipped;\n        }\n        return size > 4 ? { size: size, start: start, skip: skip } : null;\n    }\n    function copyToBuffer(bufferStart, buffer, index) {\n        var id = cursor.id, start = cursor.start, end = cursor.end, size = cursor.size;\n        cursor.next();\n        var startIndex = index;\n        if (size > 4) {\n            var endPos = cursor.pos - (size - 4);\n            while (cursor.pos > endPos)\n                index = copyToBuffer(bufferStart, buffer, index);\n        }\n        if (!types[id].prop(repeat)) { // Don't copy repeat nodes into buffers\n            buffer[--index] = startIndex;\n            buffer[--index] = end - bufferStart;\n            buffer[--index] = start - bufferStart;\n            buffer[--index] = id;\n        }\n        return index;\n    }\n    var children = [], positions = [];\n    while (cursor.pos > 0)\n        takeNode(0, 0, children, positions);\n    var length = children.length ? positions[0] + children[0].length : 0;\n    return new Tree(group.types[topID], children.reverse(), positions.reverse(), length);\n}\nfunction balanceRange(type, children, positions, from, to, start, maxBufferLength) {\n    var length = (positions[to - 1] + children[to - 1].length) - start;\n    if (from == to - 1 && start == 0) {\n        var first = children[from];\n        if (first instanceof Tree)\n            return first;\n    }\n    var localChildren = [], localPositions = [];\n    if (length <= maxBufferLength) {\n        for (var i = from; i < to; i++) {\n            localChildren.push(children[i]);\n            localPositions.push(positions[i] - start);\n        }\n    }\n    else {\n        var maxChild = Math.max(maxBufferLength, Math.ceil(length * 1.5 / BalanceBranchFactor));\n        for (var i = from; i < to;) {\n            var groupFrom = i, groupStart = positions[i];\n            i++;\n            for (; i < to; i++) {\n                var nextEnd = positions[i] + children[i].length;\n                if (nextEnd - groupStart > maxChild)\n                    break;\n            }\n            if (i == groupFrom + 1) {\n                var only = children[groupFrom];\n                if (only instanceof Tree && only.type == type) {\n                    // Already wrapped\n                    if (only.length > maxChild << 1) { // Too big, collapse\n                        for (var j = 0; j < only.children.length; j++) {\n                            localChildren.push(only.children[j]);\n                            localPositions.push(only.positions[j] + groupStart - start);\n                        }\n                        continue;\n                    }\n                }\n                else {\n                    // Wrap with our type to make reuse possible\n                    only = new Tree(type, [only], [0], only.length);\n                }\n                localChildren.push(only);\n            }\n            else {\n                localChildren.push(balanceRange(type, children, positions, groupFrom, i, groupStart, maxBufferLength));\n            }\n            localPositions.push(groupStart - start);\n        }\n    }\n    return new Tree(type, localChildren, localPositions, length);\n}\n//# sourceMappingURL=tree.js.map\n\n//# sourceURL=webpack:///./node_modules/lezer-tree/dist/tree.js?");

/***/ }),

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n\n\n//# sourceURL=webpack:///./node_modules/object-assign/index.js?");

/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar printWarning = function() {};\n\nif (true) {\n  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\n  var loggedTypeFailures = {};\n  var has = Function.call.bind(Object.prototype.hasOwnProperty);\n\n  printWarning = function(text) {\n    var message = 'Warning: ' + text;\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n}\n\n/**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */\nfunction checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n  if (true) {\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error;\n        // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            var err = Error(\n              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +\n              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'\n            );\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n        } catch (ex) {\n          error = ex;\n        }\n        if (error && !(error instanceof Error)) {\n          printWarning(\n            (componentName || 'React class') + ': type specification of ' +\n            location + ' `' + typeSpecName + '` is invalid; the type checker ' +\n            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +\n            'You may have forgotten to pass an argument to the type checker ' +\n            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +\n            'shape all require an argument).'\n          );\n        }\n        if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error.message] = true;\n\n          var stack = getStack ? getStack() : '';\n\n          printWarning(\n            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')\n          );\n        }\n      }\n    }\n  }\n}\n\n/**\n * Resets warning cache when testing.\n *\n * @private\n */\ncheckPropTypes.resetWarningCache = function() {\n  if (true) {\n    loggedTypeFailures = {};\n  }\n}\n\nmodule.exports = checkPropTypes;\n\n\n//# sourceURL=webpack:///./node_modules/prop-types/checkPropTypes.js?");

/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n\n\n//# sourceURL=webpack:///./node_modules/prop-types/lib/ReactPropTypesSecret.js?");

/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/** @license React v16.12.0\n * react.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar _assign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\nvar checkPropTypes = __webpack_require__(/*! prop-types/checkPropTypes */ \"./node_modules/prop-types/checkPropTypes.js\");\n\n// TODO: this is special because it gets imported during build.\n\nvar ReactVersion = '16.12.0';\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;\nvar REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;\nvar REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;\nvar REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;\nvar REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary\n// (unstable) APIs that have been removed. Can we remove the symbols?\n\n\nvar REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;\nvar REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;\nvar REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;\nvar REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;\nvar REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;\nvar REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;\nvar REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;\nvar REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;\nvar REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;\nvar MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\n// Do not require this module directly! Use normal `invariant` calls with\n// template literal strings. The messages will be replaced with error codes\n// during build.\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\n/**\n * Forked from fbjs/warning:\n * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js\n *\n * Only change is we use console.warn instead of console.error,\n * and do nothing when 'console' is not supported.\n * This really simplifies the code.\n * ---\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\nvar lowPriorityWarningWithoutStack = function () {};\n\n{\n  var printWarning = function (format) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var argIndex = 0;\n    var message = 'Warning: ' + format.replace(/%s/g, function () {\n      return args[argIndex++];\n    });\n\n    if (typeof console !== 'undefined') {\n      console.warn(message);\n    }\n\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n\n  lowPriorityWarningWithoutStack = function (condition, format) {\n    if (format === undefined) {\n      throw new Error('`lowPriorityWarningWithoutStack(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n\n    if (!condition) {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      printWarning.apply(void 0, [format].concat(args));\n    }\n  };\n}\n\nvar lowPriorityWarningWithoutStack$1 = lowPriorityWarningWithoutStack;\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\nvar warningWithoutStack = function () {};\n\n{\n  warningWithoutStack = function (condition, format) {\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    if (format === undefined) {\n      throw new Error('`warningWithoutStack(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n\n    if (args.length > 8) {\n      // Check before the condition to catch violations early.\n      throw new Error('warningWithoutStack() currently supports at most 8 arguments.');\n    }\n\n    if (condition) {\n      return;\n    }\n\n    if (typeof console !== 'undefined') {\n      var argsWithFormat = args.map(function (item) {\n        return '' + item;\n      });\n      argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n      // breaks IE9: https://github.com/facebook/react/issues/13610\n\n      Function.prototype.apply.call(console.error, console, argsWithFormat);\n    }\n\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      var argIndex = 0;\n      var message = 'Warning: ' + format.replace(/%s/g, function () {\n        return args[argIndex++];\n      });\n      throw new Error(message);\n    } catch (x) {}\n  };\n}\n\nvar warningWithoutStack$1 = warningWithoutStack;\n\nvar didWarnStateUpdateForUnmountedComponent = {};\n\nfunction warnNoop(publicInstance, callerName) {\n  {\n    var _constructor = publicInstance.constructor;\n    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';\n    var warningKey = componentName + \".\" + callerName;\n\n    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\n      return;\n    }\n\n    warningWithoutStack$1(false, \"Can't call %s on a component that is not yet mounted. \" + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);\n    didWarnStateUpdateForUnmountedComponent[warningKey] = true;\n  }\n}\n/**\n * This is the abstract API for an update queue.\n */\n\n\nvar ReactNoopUpdateQueue = {\n  /**\n   * Checks whether or not this composite component is mounted.\n   * @param {ReactClass} publicInstance The instance we want to test.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */\n  isMounted: function (publicInstance) {\n    return false;\n  },\n\n  /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */\n  enqueueForceUpdate: function (publicInstance, callback, callerName) {\n    warnNoop(publicInstance, 'forceUpdate');\n  },\n\n  /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */\n  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {\n    warnNoop(publicInstance, 'replaceState');\n  },\n\n  /**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} Name of the calling function in the public API.\n   * @internal\n   */\n  enqueueSetState: function (publicInstance, partialState, callback, callerName) {\n    warnNoop(publicInstance, 'setState');\n  }\n};\n\nvar emptyObject = {};\n\n{\n  Object.freeze(emptyObject);\n}\n/**\n * Base class helpers for the updating state of a component.\n */\n\n\nfunction Component(props, context, updater) {\n  this.props = props;\n  this.context = context; // If a component has string refs, we will assign a different object later.\n\n  this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the\n  // renderer.\n\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nComponent.prototype.isReactComponent = {};\n/**\n * Sets a subset of the state. Always use this to mutate\n * state. You should treat `this.state` as immutable.\n *\n * There is no guarantee that `this.state` will be immediately updated, so\n * accessing `this.state` after calling this method may return the old value.\n *\n * There is no guarantee that calls to `setState` will run synchronously,\n * as they may eventually be batched together.  You can provide an optional\n * callback that will be executed when the call to setState is actually\n * completed.\n *\n * When a function is provided to setState, it will be called at some point in\n * the future (not synchronously). It will be called with the up to date\n * component arguments (state, props, context). These values can be different\n * from this.* because your function may be called after receiveProps but before\n * shouldComponentUpdate, and this new state, props, and context will not yet be\n * assigned to this.\n *\n * @param {object|function} partialState Next partial state or function to\n *        produce next partial state to be merged with current state.\n * @param {?function} callback Called after state is updated.\n * @final\n * @protected\n */\n\nComponent.prototype.setState = function (partialState, callback) {\n  if (!(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null)) {\n    {\n      throw Error(\"setState(...): takes an object of state variables to update or a function which returns an object of state variables.\");\n    }\n  }\n\n  this.updater.enqueueSetState(this, partialState, callback, 'setState');\n};\n/**\n * Forces an update. This should only be invoked when it is known with\n * certainty that we are **not** in a DOM transaction.\n *\n * You may want to call this when you know that some deeper aspect of the\n * component's state has changed but `setState` was not called.\n *\n * This will not invoke `shouldComponentUpdate`, but it will invoke\n * `componentWillUpdate` and `componentDidUpdate`.\n *\n * @param {?function} callback Called after update is complete.\n * @final\n * @protected\n */\n\n\nComponent.prototype.forceUpdate = function (callback) {\n  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\n};\n/**\n * Deprecated APIs. These APIs used to exist on classic React classes but since\n * we would like to deprecate them, we're not going to move them over to this\n * modern base class. Instead, we define a getter that warns if it's accessed.\n */\n\n\n{\n  var deprecatedAPIs = {\n    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],\n    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']\n  };\n\n  var defineDeprecationWarning = function (methodName, info) {\n    Object.defineProperty(Component.prototype, methodName, {\n      get: function () {\n        lowPriorityWarningWithoutStack$1(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);\n        return undefined;\n      }\n    });\n  };\n\n  for (var fnName in deprecatedAPIs) {\n    if (deprecatedAPIs.hasOwnProperty(fnName)) {\n      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n    }\n  }\n}\n\nfunction ComponentDummy() {}\n\nComponentDummy.prototype = Component.prototype;\n/**\n * Convenience component with default shallow equality check for sCU.\n */\n\nfunction PureComponent(props, context, updater) {\n  this.props = props;\n  this.context = context; // If a component has string refs, we will assign a different object later.\n\n  this.refs = emptyObject;\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nvar pureComponentPrototype = PureComponent.prototype = new ComponentDummy();\npureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.\n\n_assign(pureComponentPrototype, Component.prototype);\n\npureComponentPrototype.isPureReactComponent = true;\n\n// an immutable object with a single mutable value\nfunction createRef() {\n  var refObject = {\n    current: null\n  };\n\n  {\n    Object.seal(refObject);\n  }\n\n  return refObject;\n}\n\n/**\n * Keeps track of the current dispatcher.\n */\nvar ReactCurrentDispatcher = {\n  /**\n   * @internal\n   * @type {ReactComponent}\n   */\n  current: null\n};\n\n/**\n * Keeps track of the current batch's configuration such as how long an update\n * should suspend for if it needs to.\n */\nvar ReactCurrentBatchConfig = {\n  suspense: null\n};\n\n/**\n * Keeps track of the current owner.\n *\n * The current owner is the component who should own any components that are\n * currently being constructed.\n */\nvar ReactCurrentOwner = {\n  /**\n   * @internal\n   * @type {ReactComponent}\n   */\n  current: null\n};\n\nvar BEFORE_SLASH_RE = /^(.*)[\\\\\\/]/;\nvar describeComponentFrame = function (name, source, ownerName) {\n  var sourceInfo = '';\n\n  if (source) {\n    var path = source.fileName;\n    var fileName = path.replace(BEFORE_SLASH_RE, '');\n\n    {\n      // In DEV, include code for a common special case:\n      // prefer \"folder/index.js\" instead of just \"index.js\".\n      if (/^index\\./.test(fileName)) {\n        var match = path.match(BEFORE_SLASH_RE);\n\n        if (match) {\n          var pathBeforeSlash = match[1];\n\n          if (pathBeforeSlash) {\n            var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, '');\n            fileName = folderName + '/' + fileName;\n          }\n        }\n      }\n    }\n\n    sourceInfo = ' (at ' + fileName + ':' + source.lineNumber + ')';\n  } else if (ownerName) {\n    sourceInfo = ' (created by ' + ownerName + ')';\n  }\n\n  return '\\n    in ' + (name || 'Unknown') + sourceInfo;\n};\n\nvar Resolved = 1;\n\nfunction refineResolvedLazyComponent(lazyComponent) {\n  return lazyComponent._status === Resolved ? lazyComponent._result : null;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var functionName = innerType.displayName || innerType.name || '';\n  return outerType.displayName || (functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName);\n}\n\nfunction getComponentName(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      warningWithoutStack$1(false, 'Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return \"Profiler\";\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        return 'Context.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        return 'Context.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        return getComponentName(type.type);\n\n      case REACT_LAZY_TYPE:\n        {\n          var thenable = type;\n          var resolvedThenable = refineResolvedLazyComponent(thenable);\n\n          if (resolvedThenable) {\n            return getComponentName(resolvedThenable);\n          }\n\n          break;\n        }\n    }\n  }\n\n  return null;\n}\n\nvar ReactDebugCurrentFrame = {};\nvar currentlyValidatingElement = null;\nfunction setCurrentlyValidatingElement(element) {\n  {\n    currentlyValidatingElement = element;\n  }\n}\n\n{\n  // Stack implementation injected by the current renderer.\n  ReactDebugCurrentFrame.getCurrentStack = null;\n\n  ReactDebugCurrentFrame.getStackAddendum = function () {\n    var stack = ''; // Add an extra top frame while an element is being validated\n\n    if (currentlyValidatingElement) {\n      var name = getComponentName(currentlyValidatingElement.type);\n      var owner = currentlyValidatingElement._owner;\n      stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner.type));\n    } // Delegate to the injected renderer-specific implementation\n\n\n    var impl = ReactDebugCurrentFrame.getCurrentStack;\n\n    if (impl) {\n      stack += impl() || '';\n    }\n\n    return stack;\n  };\n}\n\n/**\n * Used by act() to track whether you're inside an act() scope.\n */\nvar IsSomeRendererActing = {\n  current: false\n};\n\nvar ReactSharedInternals = {\n  ReactCurrentDispatcher: ReactCurrentDispatcher,\n  ReactCurrentBatchConfig: ReactCurrentBatchConfig,\n  ReactCurrentOwner: ReactCurrentOwner,\n  IsSomeRendererActing: IsSomeRendererActing,\n  // Used by renderers to avoid bundling object-assign twice in UMD bundles:\n  assign: _assign\n};\n\n{\n  _assign(ReactSharedInternals, {\n    // These should not be included in production.\n    ReactDebugCurrentFrame: ReactDebugCurrentFrame,\n    // Shim for React DOM 16.0.0 which still destructured (but not used) this.\n    // TODO: remove in React 17.0.\n    ReactComponentTreeHook: {}\n  });\n}\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warning = warningWithoutStack$1;\n\n{\n  warning = function (condition, format) {\n    if (condition) {\n      return;\n    }\n\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum(); // eslint-disable-next-line react-internal/warning-and-invariant-args\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    warningWithoutStack$1.apply(void 0, [false, format + '%s'].concat(args, [stack]));\n  };\n}\n\nvar warning$1 = warning;\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  var warnAboutAccessingKey = function () {\n    if (!specialPropKeyWarningShown) {\n      specialPropKeyWarningShown = true;\n      warningWithoutStack$1(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);\n    }\n  };\n\n  warnAboutAccessingKey.isReactWarning = true;\n  Object.defineProperty(props, 'key', {\n    get: warnAboutAccessingKey,\n    configurable: true\n  });\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  var warnAboutAccessingRef = function () {\n    if (!specialPropRefWarningShown) {\n      specialPropRefWarningShown = true;\n      warningWithoutStack$1(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);\n    }\n  };\n\n  warnAboutAccessingRef.isReactWarning = true;\n  Object.defineProperty(props, 'ref', {\n    get: warnAboutAccessingRef,\n    configurable: true\n  });\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\n\n\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV(type, config, maybeKey, source, self) {\n  var propName; // Reserved names are extracted\n\n  var props = {};\n  var key = null;\n  var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n  // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n  // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n  // but as an intermediary step, we will use jsxDEV for everything except\n  // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n  // key is explicitly declared to be undefined or not.\n\n  if (maybeKey !== undefined) {\n    key = '' + maybeKey;\n  }\n\n  if (hasValidKey(config)) {\n    key = '' + config.key;\n  }\n\n  if (hasValidRef(config)) {\n    ref = config.ref;\n  } // Remaining properties are added to a new props object\n\n\n  for (propName in config) {\n    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n      props[propName] = config[propName];\n    }\n  } // Resolve default props\n\n\n  if (type && type.defaultProps) {\n    var defaultProps = type.defaultProps;\n\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n\n  if (key || ref) {\n    var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n    if (key) {\n      defineKeyPropWarningGetter(props, displayName);\n    }\n\n    if (ref) {\n      defineRefPropWarningGetter(props, displayName);\n    }\n  }\n\n  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n}\n/**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */\n\nfunction createElement(type, config, children) {\n  var propName; // Reserved names are extracted\n\n  var props = {};\n  var key = null;\n  var ref = null;\n  var self = null;\n  var source = null;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      ref = config.ref;\n    }\n\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    }\n\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    }\n  } // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n\n\n  var childrenLength = arguments.length - 2;\n\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n\n    {\n      if (Object.freeze) {\n        Object.freeze(childArray);\n      }\n    }\n\n    props.children = childArray;\n  } // Resolve default props\n\n\n  if (type && type.defaultProps) {\n    var defaultProps = type.defaultProps;\n\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n\n  {\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n  }\n\n  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n}\n/**\n * Return a function that produces ReactElements of a given type.\n * See https://reactjs.org/docs/react-api.html#createfactory\n */\n\n\nfunction cloneAndReplaceKey(oldElement, newKey) {\n  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\n  return newElement;\n}\n/**\n * Clone and return a new ReactElement using element as the starting point.\n * See https://reactjs.org/docs/react-api.html#cloneelement\n */\n\nfunction cloneElement(element, config, children) {\n  if (!!(element === null || element === undefined)) {\n    {\n      throw Error(\"React.cloneElement(...): The argument must be a React element, but you passed \" + element + \".\");\n    }\n  }\n\n  var propName; // Original props are copied\n\n  var props = _assign({}, element.props); // Reserved names are extracted\n\n\n  var key = element.key;\n  var ref = element.ref; // Self is preserved since the owner is preserved.\n\n  var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a\n  // transpiler, and the original source is probably a better indicator of the\n  // true owner.\n\n  var source = element._source; // Owner will be preserved, unless ref is overridden\n\n  var owner = element._owner;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      // Silently steal the ref from the parent.\n      ref = config.ref;\n      owner = ReactCurrentOwner.current;\n    }\n\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    } // Remaining properties override existing props\n\n\n    var defaultProps;\n\n    if (element.type && element.type.defaultProps) {\n      defaultProps = element.type.defaultProps;\n    }\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        if (config[propName] === undefined && defaultProps !== undefined) {\n          // Resolve default props\n          props[propName] = defaultProps[propName];\n        } else {\n          props[propName] = config[propName];\n        }\n      }\n    }\n  } // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n\n\n  var childrenLength = arguments.length - 2;\n\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n\n    props.children = childArray;\n  }\n\n  return ReactElement(element.type, key, ref, self, source, owner, props);\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\n\nvar SEPARATOR = '.';\nvar SUBSEPARATOR = ':';\n/**\n * Escape and wrap key so it is safe to use as a reactid\n *\n * @param {string} key to be escaped.\n * @return {string} the escaped key.\n */\n\nfunction escape(key) {\n  var escapeRegex = /[=:]/g;\n  var escaperLookup = {\n    '=': '=0',\n    ':': '=2'\n  };\n  var escapedString = ('' + key).replace(escapeRegex, function (match) {\n    return escaperLookup[match];\n  });\n  return '$' + escapedString;\n}\n/**\n * TODO: Test that a single child and an array with one item have the same key\n * pattern.\n */\n\n\nvar didWarnAboutMaps = false;\nvar userProvidedKeyEscapeRegex = /\\/+/g;\n\nfunction escapeUserProvidedKey(text) {\n  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');\n}\n\nvar POOL_SIZE = 10;\nvar traverseContextPool = [];\n\nfunction getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {\n  if (traverseContextPool.length) {\n    var traverseContext = traverseContextPool.pop();\n    traverseContext.result = mapResult;\n    traverseContext.keyPrefix = keyPrefix;\n    traverseContext.func = mapFunction;\n    traverseContext.context = mapContext;\n    traverseContext.count = 0;\n    return traverseContext;\n  } else {\n    return {\n      result: mapResult,\n      keyPrefix: keyPrefix,\n      func: mapFunction,\n      context: mapContext,\n      count: 0\n    };\n  }\n}\n\nfunction releaseTraverseContext(traverseContext) {\n  traverseContext.result = null;\n  traverseContext.keyPrefix = null;\n  traverseContext.func = null;\n  traverseContext.context = null;\n  traverseContext.count = 0;\n\n  if (traverseContextPool.length < POOL_SIZE) {\n    traverseContextPool.push(traverseContext);\n  }\n}\n/**\n * @param {?*} children Children tree container.\n * @param {!string} nameSoFar Name of the key path so far.\n * @param {!function} callback Callback to invoke with each child found.\n * @param {?*} traverseContext Used to pass information throughout the traversal\n * process.\n * @return {!number} The number of children in this subtree.\n */\n\n\nfunction traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {\n  var type = typeof children;\n\n  if (type === 'undefined' || type === 'boolean') {\n    // All of the above are perceived as null.\n    children = null;\n  }\n\n  var invokeCallback = false;\n\n  if (children === null) {\n    invokeCallback = true;\n  } else {\n    switch (type) {\n      case 'string':\n      case 'number':\n        invokeCallback = true;\n        break;\n\n      case 'object':\n        switch (children.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n          case REACT_PORTAL_TYPE:\n            invokeCallback = true;\n        }\n\n    }\n  }\n\n  if (invokeCallback) {\n    callback(traverseContext, children, // If it's the only child, treat the name as if it was wrapped in an array\n    // so that it's consistent if the number of children grows.\n    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);\n    return 1;\n  }\n\n  var child;\n  var nextName;\n  var subtreeCount = 0; // Count of children found in the current subtree.\n\n  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      child = children[i];\n      nextName = nextNamePrefix + getComponentKey(child, i);\n      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n    }\n  } else {\n    var iteratorFn = getIteratorFn(children);\n\n    if (typeof iteratorFn === 'function') {\n      {\n        // Warn about using Maps as children\n        if (iteratorFn === children.entries) {\n          !didWarnAboutMaps ? warning$1(false, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.') : void 0;\n          didWarnAboutMaps = true;\n        }\n      }\n\n      var iterator = iteratorFn.call(children);\n      var step;\n      var ii = 0;\n\n      while (!(step = iterator.next()).done) {\n        child = step.value;\n        nextName = nextNamePrefix + getComponentKey(child, ii++);\n        subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n      }\n    } else if (type === 'object') {\n      var addendum = '';\n\n      {\n        addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();\n      }\n\n      var childrenString = '' + children;\n\n      {\n        {\n          throw Error(\"Objects are not valid as a React child (found: \" + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + \").\" + addendum);\n        }\n      }\n    }\n  }\n\n  return subtreeCount;\n}\n/**\n * Traverses children that are typically specified as `props.children`, but\n * might also be specified through attributes:\n *\n * - `traverseAllChildren(this.props.children, ...)`\n * - `traverseAllChildren(this.props.leftPanelChildren, ...)`\n *\n * The `traverseContext` is an optional argument that is passed through the\n * entire traversal. It can be used to store accumulations or anything else that\n * the callback might find relevant.\n *\n * @param {?*} children Children tree object.\n * @param {!function} callback To invoke upon traversing each child.\n * @param {?*} traverseContext Context for traversal.\n * @return {!number} The number of children in this subtree.\n */\n\n\nfunction traverseAllChildren(children, callback, traverseContext) {\n  if (children == null) {\n    return 0;\n  }\n\n  return traverseAllChildrenImpl(children, '', callback, traverseContext);\n}\n/**\n * Generate a key string that identifies a component within a set.\n *\n * @param {*} component A component that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */\n\n\nfunction getComponentKey(component, index) {\n  // Do some typechecking here since we call this blindly. We want to ensure\n  // that we don't block potential future ES APIs.\n  if (typeof component === 'object' && component !== null && component.key != null) {\n    // Explicit key\n    return escape(component.key);\n  } // Implicit key determined by the index in the set\n\n\n  return index.toString(36);\n}\n\nfunction forEachSingleChild(bookKeeping, child, name) {\n  var func = bookKeeping.func,\n      context = bookKeeping.context;\n  func.call(context, child, bookKeeping.count++);\n}\n/**\n * Iterates through children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenforeach\n *\n * The provided forEachFunc(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} forEachFunc\n * @param {*} forEachContext Context for forEachContext.\n */\n\n\nfunction forEachChildren(children, forEachFunc, forEachContext) {\n  if (children == null) {\n    return children;\n  }\n\n  var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);\n  traverseAllChildren(children, forEachSingleChild, traverseContext);\n  releaseTraverseContext(traverseContext);\n}\n\nfunction mapSingleChildIntoContext(bookKeeping, child, childKey) {\n  var result = bookKeeping.result,\n      keyPrefix = bookKeeping.keyPrefix,\n      func = bookKeeping.func,\n      context = bookKeeping.context;\n  var mappedChild = func.call(context, child, bookKeeping.count++);\n\n  if (Array.isArray(mappedChild)) {\n    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, function (c) {\n      return c;\n    });\n  } else if (mappedChild != null) {\n    if (isValidElement(mappedChild)) {\n      mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as\n      // traverseAllChildren used to do for objects as children\n      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);\n    }\n\n    result.push(mappedChild);\n  }\n}\n\nfunction mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {\n  var escapedPrefix = '';\n\n  if (prefix != null) {\n    escapedPrefix = escapeUserProvidedKey(prefix) + '/';\n  }\n\n  var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);\n  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);\n  releaseTraverseContext(traverseContext);\n}\n/**\n * Maps children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenmap\n *\n * The provided mapFunction(child, key, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} func The map function.\n * @param {*} context Context for mapFunction.\n * @return {object} Object containing the ordered map of results.\n */\n\n\nfunction mapChildren(children, func, context) {\n  if (children == null) {\n    return children;\n  }\n\n  var result = [];\n  mapIntoWithKeyPrefixInternal(children, result, null, func, context);\n  return result;\n}\n/**\n * Count the number of children that are typically specified as\n * `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrencount\n *\n * @param {?*} children Children tree container.\n * @return {number} The number of children.\n */\n\n\nfunction countChildren(children) {\n  return traverseAllChildren(children, function () {\n    return null;\n  }, null);\n}\n/**\n * Flatten a children object (typically specified as `props.children`) and\n * return an array with appropriately re-keyed children.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrentoarray\n */\n\n\nfunction toArray(children) {\n  var result = [];\n  mapIntoWithKeyPrefixInternal(children, result, null, function (child) {\n    return child;\n  });\n  return result;\n}\n/**\n * Returns the first child in a collection of children and verifies that there\n * is only one child in the collection.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenonly\n *\n * The current implementation of this function assumes that a single child gets\n * passed without a wrapper, but the purpose of this helper function is to\n * abstract away the particular structure of children.\n *\n * @param {?object} children Child collection structure.\n * @return {ReactElement} The first and only `ReactElement` contained in the\n * structure.\n */\n\n\nfunction onlyChild(children) {\n  if (!isValidElement(children)) {\n    {\n      throw Error(\"React.Children.only expected to receive a single React element child.\");\n    }\n  }\n\n  return children;\n}\n\nfunction createContext(defaultValue, calculateChangedBits) {\n  if (calculateChangedBits === undefined) {\n    calculateChangedBits = null;\n  } else {\n    {\n      !(calculateChangedBits === null || typeof calculateChangedBits === 'function') ? warningWithoutStack$1(false, 'createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits) : void 0;\n    }\n  }\n\n  var context = {\n    $$typeof: REACT_CONTEXT_TYPE,\n    _calculateChangedBits: calculateChangedBits,\n    // As a workaround to support multiple concurrent renderers, we categorize\n    // some renderers as primary and others as secondary. We only expect\n    // there to be two concurrent renderers at most: React Native (primary) and\n    // Fabric (secondary); React DOM (primary) and React ART (secondary).\n    // Secondary renderers store their context values on separate fields.\n    _currentValue: defaultValue,\n    _currentValue2: defaultValue,\n    // Used to track how many concurrent renderers this context currently\n    // supports within in a single renderer. Such as parallel server rendering.\n    _threadCount: 0,\n    // These are circular\n    Provider: null,\n    Consumer: null\n  };\n  context.Provider = {\n    $$typeof: REACT_PROVIDER_TYPE,\n    _context: context\n  };\n  var hasWarnedAboutUsingNestedContextConsumers = false;\n  var hasWarnedAboutUsingConsumerProvider = false;\n\n  {\n    // A separate object, but proxies back to the original context object for\n    // backwards compatibility. It has a different $$typeof, so we can properly\n    // warn for the incorrect usage of Context as a Consumer.\n    var Consumer = {\n      $$typeof: REACT_CONTEXT_TYPE,\n      _context: context,\n      _calculateChangedBits: context._calculateChangedBits\n    }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here\n\n    Object.defineProperties(Consumer, {\n      Provider: {\n        get: function () {\n          if (!hasWarnedAboutUsingConsumerProvider) {\n            hasWarnedAboutUsingConsumerProvider = true;\n            warning$1(false, 'Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');\n          }\n\n          return context.Provider;\n        },\n        set: function (_Provider) {\n          context.Provider = _Provider;\n        }\n      },\n      _currentValue: {\n        get: function () {\n          return context._currentValue;\n        },\n        set: function (_currentValue) {\n          context._currentValue = _currentValue;\n        }\n      },\n      _currentValue2: {\n        get: function () {\n          return context._currentValue2;\n        },\n        set: function (_currentValue2) {\n          context._currentValue2 = _currentValue2;\n        }\n      },\n      _threadCount: {\n        get: function () {\n          return context._threadCount;\n        },\n        set: function (_threadCount) {\n          context._threadCount = _threadCount;\n        }\n      },\n      Consumer: {\n        get: function () {\n          if (!hasWarnedAboutUsingNestedContextConsumers) {\n            hasWarnedAboutUsingNestedContextConsumers = true;\n            warning$1(false, 'Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');\n          }\n\n          return context.Consumer;\n        }\n      }\n    }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty\n\n    context.Consumer = Consumer;\n  }\n\n  {\n    context._currentRenderer = null;\n    context._currentRenderer2 = null;\n  }\n\n  return context;\n}\n\nfunction lazy(ctor) {\n  var lazyType = {\n    $$typeof: REACT_LAZY_TYPE,\n    _ctor: ctor,\n    // React uses these fields to store the result.\n    _status: -1,\n    _result: null\n  };\n\n  {\n    // In production, this would just set it on the object.\n    var defaultProps;\n    var propTypes;\n    Object.defineProperties(lazyType, {\n      defaultProps: {\n        configurable: true,\n        get: function () {\n          return defaultProps;\n        },\n        set: function (newDefaultProps) {\n          warning$1(false, 'React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\n          defaultProps = newDefaultProps; // Match production behavior more closely:\n\n          Object.defineProperty(lazyType, 'defaultProps', {\n            enumerable: true\n          });\n        }\n      },\n      propTypes: {\n        configurable: true,\n        get: function () {\n          return propTypes;\n        },\n        set: function (newPropTypes) {\n          warning$1(false, 'React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\n          propTypes = newPropTypes; // Match production behavior more closely:\n\n          Object.defineProperty(lazyType, 'propTypes', {\n            enumerable: true\n          });\n        }\n      }\n    });\n  }\n\n  return lazyType;\n}\n\nfunction forwardRef(render) {\n  {\n    if (render != null && render.$$typeof === REACT_MEMO_TYPE) {\n      warningWithoutStack$1(false, 'forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');\n    } else if (typeof render !== 'function') {\n      warningWithoutStack$1(false, 'forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);\n    } else {\n      !( // Do not warn for 0 arguments because it could be due to usage of the 'arguments' object\n      render.length === 0 || render.length === 2) ? warningWithoutStack$1(false, 'forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.') : void 0;\n    }\n\n    if (render != null) {\n      !(render.defaultProps == null && render.propTypes == null) ? warningWithoutStack$1(false, 'forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?') : void 0;\n    }\n  }\n\n  return {\n    $$typeof: REACT_FORWARD_REF_TYPE,\n    render: render\n  };\n}\n\nfunction isValidElementType(type) {\n  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE);\n}\n\nfunction memo(type, compare) {\n  {\n    if (!isValidElementType(type)) {\n      warningWithoutStack$1(false, 'memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);\n    }\n  }\n\n  return {\n    $$typeof: REACT_MEMO_TYPE,\n    type: type,\n    compare: compare === undefined ? null : compare\n  };\n}\n\nfunction resolveDispatcher() {\n  var dispatcher = ReactCurrentDispatcher.current;\n\n  if (!(dispatcher !== null)) {\n    {\n      throw Error(\"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\\n1. You might have mismatching versions of React and the renderer (such as React DOM)\\n2. You might be breaking the Rules of Hooks\\n3. You might have more than one copy of React in the same app\\nSee https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem.\");\n    }\n  }\n\n  return dispatcher;\n}\n\nfunction useContext(Context, unstable_observedBits) {\n  var dispatcher = resolveDispatcher();\n\n  {\n    !(unstable_observedBits === undefined) ? warning$1(false, 'useContext() second argument is reserved for future ' + 'use in React. Passing it is not supported. ' + 'You passed: %s.%s', unstable_observedBits, typeof unstable_observedBits === 'number' && Array.isArray(arguments[2]) ? '\\n\\nDid you call array.map(useContext)? ' + 'Calling Hooks inside a loop is not supported. ' + 'Learn more at https://fb.me/rules-of-hooks' : '') : void 0; // TODO: add a more generic warning for invalid values.\n\n    if (Context._context !== undefined) {\n      var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs\n      // and nobody should be using this in existing code.\n\n      if (realContext.Consumer === Context) {\n        warning$1(false, 'Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');\n      } else if (realContext.Provider === Context) {\n        warning$1(false, 'Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');\n      }\n    }\n  }\n\n  return dispatcher.useContext(Context, unstable_observedBits);\n}\nfunction useState(initialState) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useState(initialState);\n}\nfunction useReducer(reducer, initialArg, init) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useReducer(reducer, initialArg, init);\n}\nfunction useRef(initialValue) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useRef(initialValue);\n}\nfunction useEffect(create, inputs) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useEffect(create, inputs);\n}\nfunction useLayoutEffect(create, inputs) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useLayoutEffect(create, inputs);\n}\nfunction useCallback(callback, inputs) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useCallback(callback, inputs);\n}\nfunction useMemo(create, inputs) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useMemo(create, inputs);\n}\nfunction useImperativeHandle(ref, create, inputs) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useImperativeHandle(ref, create, inputs);\n}\nfunction useDebugValue(value, formatterFn) {\n  {\n    var dispatcher = resolveDispatcher();\n    return dispatcher.useDebugValue(value, formatterFn);\n  }\n}\nvar emptyObject$1 = {};\nfunction useResponder(responder, listenerProps) {\n  var dispatcher = resolveDispatcher();\n\n  {\n    if (responder == null || responder.$$typeof !== REACT_RESPONDER_TYPE) {\n      warning$1(false, 'useResponder: invalid first argument. Expected an event responder, but instead got %s', responder);\n      return;\n    }\n  }\n\n  return dispatcher.useResponder(responder, listenerProps || emptyObject$1);\n}\nfunction useTransition(config) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useTransition(config);\n}\nfunction useDeferredValue(value, config) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useDeferredValue(value, config);\n}\n\nfunction withSuspenseConfig(scope, config) {\n  var previousConfig = ReactCurrentBatchConfig.suspense;\n  ReactCurrentBatchConfig.suspense = config === undefined ? null : config;\n\n  try {\n    scope();\n  } finally {\n    ReactCurrentBatchConfig.suspense = previousConfig;\n  }\n}\n\n/**\n * ReactElementValidator provides a wrapper around a element factory\n * which validates the props passed to the element. This is intended to be\n * used only in DEV and could be replaced by a static type checker for languages\n * that support it.\n */\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n\nvar hasOwnProperty$1 = Object.prototype.hasOwnProperty;\n\nfunction getDeclarationErrorAddendum() {\n  if (ReactCurrentOwner.current) {\n    var name = getComponentName(ReactCurrentOwner.current.type);\n\n    if (name) {\n      return '\\n\\nCheck the render method of `' + name + '`.';\n    }\n  }\n\n  return '';\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  if (source !== undefined) {\n    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n    var lineNumber = source.lineNumber;\n    return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n  }\n\n  return '';\n}\n\nfunction getSourceInfoErrorAddendumForProps(elementProps) {\n  if (elementProps !== null && elementProps !== undefined) {\n    return getSourceInfoErrorAddendum(elementProps.__source);\n  }\n\n  return '';\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  var info = getDeclarationErrorAddendum();\n\n  if (!info) {\n    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n    if (parentName) {\n      info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n    }\n  }\n\n  return info;\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  if (!element._store || element._store.validated || element.key != null) {\n    return;\n  }\n\n  element._store.validated = true;\n  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n    return;\n  }\n\n  ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n  // property, it may be the creator of the child that's responsible for\n  // assigning it a key.\n\n  var childOwner = '';\n\n  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n    // Give the component that originally created this child.\n    childOwner = \" It was passed a child from \" + getComponentName(element._owner.type) + \".\";\n  }\n\n  setCurrentlyValidatingElement(element);\n\n  {\n    warning$1(false, 'Each child in a list should have a unique \"key\" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.', currentComponentErrorInfo, childOwner);\n  }\n\n  setCurrentlyValidatingElement(null);\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  if (typeof node !== 'object') {\n    return;\n  }\n\n  if (Array.isArray(node)) {\n    for (var i = 0; i < node.length; i++) {\n      var child = node[i];\n\n      if (isValidElement(child)) {\n        validateExplicitKey(child, parentType);\n      }\n    }\n  } else if (isValidElement(node)) {\n    // This element was passed in a valid location.\n    if (node._store) {\n      node._store.validated = true;\n    }\n  } else if (node) {\n    var iteratorFn = getIteratorFn(node);\n\n    if (typeof iteratorFn === 'function') {\n      // Entry iterators used to provide implicit keys,\n      // but now we print a separate warning for them later.\n      if (iteratorFn !== node.entries) {\n        var iterator = iteratorFn.call(node);\n        var step;\n\n        while (!(step = iterator.next()).done) {\n          if (isValidElement(step.value)) {\n            validateExplicitKey(step.value, parentType);\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  var type = element.type;\n\n  if (type === null || type === undefined || typeof type === 'string') {\n    return;\n  }\n\n  var name = getComponentName(type);\n  var propTypes;\n\n  if (typeof type === 'function') {\n    propTypes = type.propTypes;\n  } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n  // Inner props are checked in the reconciler.\n  type.$$typeof === REACT_MEMO_TYPE)) {\n    propTypes = type.propTypes;\n  } else {\n    return;\n  }\n\n  if (propTypes) {\n    setCurrentlyValidatingElement(element);\n    checkPropTypes(propTypes, element.props, 'prop', name, ReactDebugCurrentFrame.getStackAddendum);\n    setCurrentlyValidatingElement(null);\n  } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n    propTypesMisspellWarningShown = true;\n    warningWithoutStack$1(false, 'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');\n  }\n\n  if (typeof type.getDefaultProps === 'function') {\n    !type.getDefaultProps.isReactClassApproved ? warningWithoutStack$1(false, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  setCurrentlyValidatingElement(fragment);\n  var keys = Object.keys(fragment.props);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n\n    if (key !== 'children' && key !== 'key') {\n      warning$1(false, 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n      break;\n    }\n  }\n\n  if (fragment.ref !== null) {\n    warning$1(false, 'Invalid attribute `ref` supplied to `React.Fragment`.');\n  }\n\n  setCurrentlyValidatingElement(null);\n}\n\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n  // succeed and there will likely be errors in render.\n\n  if (!validType) {\n    var info = '';\n\n    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n      info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n    }\n\n    var sourceInfo = getSourceInfoErrorAddendum(source);\n\n    if (sourceInfo) {\n      info += sourceInfo;\n    } else {\n      info += getDeclarationErrorAddendum();\n    }\n\n    var typeString;\n\n    if (type === null) {\n      typeString = 'null';\n    } else if (Array.isArray(type)) {\n      typeString = 'array';\n    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n      typeString = \"<\" + (getComponentName(type.type) || 'Unknown') + \" />\";\n      info = ' Did you accidentally export a JSX literal instead of a component?';\n    } else {\n      typeString = typeof type;\n    }\n\n    warning$1(false, 'React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n  }\n\n  var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n  // TODO: Drop this when these are no longer allowed as the type argument.\n\n  if (element == null) {\n    return element;\n  } // Skip key warning if the type isn't valid since our key validation logic\n  // doesn't expect a non-string/function type and can throw confusing errors.\n  // We don't want exception behavior to differ between dev and prod.\n  // (Rendering will throw with a helpful message and as soon as the type is\n  // fixed, the key warnings will appear.)\n\n\n  if (validType) {\n    var children = props.children;\n\n    if (children !== undefined) {\n      if (isStaticChildren) {\n        if (Array.isArray(children)) {\n          for (var i = 0; i < children.length; i++) {\n            validateChildKeys(children[i], type);\n          }\n\n          if (Object.freeze) {\n            Object.freeze(children);\n          }\n        } else {\n          warning$1(false, 'React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n        }\n      } else {\n        validateChildKeys(children, type);\n      }\n    }\n  }\n\n  if (hasOwnProperty$1.call(props, 'key')) {\n    warning$1(false, 'React.jsx: Spreading a key to JSX is a deprecated pattern. ' + 'Explicitly pass a key after spreading props in your JSX call. ' + 'E.g. <ComponentName {...props} key={key} />');\n  }\n\n  if (type === REACT_FRAGMENT_TYPE) {\n    validateFragmentProps(element);\n  } else {\n    validatePropTypes(element);\n  }\n\n  return element;\n} // These two functions exist to still get child warnings in dev\n// even with the prod transform. This means that jsxDEV is purely\n// opt-in behavior for better messages but that we won't stop\n// giving you warnings if you use production apis.\n\nfunction jsxWithValidationStatic(type, props, key) {\n  return jsxWithValidation(type, props, key, true);\n}\nfunction jsxWithValidationDynamic(type, props, key) {\n  return jsxWithValidation(type, props, key, false);\n}\nfunction createElementWithValidation(type, props, children) {\n  var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n  // succeed and there will likely be errors in render.\n\n  if (!validType) {\n    var info = '';\n\n    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n      info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n    }\n\n    var sourceInfo = getSourceInfoErrorAddendumForProps(props);\n\n    if (sourceInfo) {\n      info += sourceInfo;\n    } else {\n      info += getDeclarationErrorAddendum();\n    }\n\n    var typeString;\n\n    if (type === null) {\n      typeString = 'null';\n    } else if (Array.isArray(type)) {\n      typeString = 'array';\n    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n      typeString = \"<\" + (getComponentName(type.type) || 'Unknown') + \" />\";\n      info = ' Did you accidentally export a JSX literal instead of a component?';\n    } else {\n      typeString = typeof type;\n    }\n\n    warning$1(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n  }\n\n  var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.\n  // TODO: Drop this when these are no longer allowed as the type argument.\n\n  if (element == null) {\n    return element;\n  } // Skip key warning if the type isn't valid since our key validation logic\n  // doesn't expect a non-string/function type and can throw confusing errors.\n  // We don't want exception behavior to differ between dev and prod.\n  // (Rendering will throw with a helpful message and as soon as the type is\n  // fixed, the key warnings will appear.)\n\n\n  if (validType) {\n    for (var i = 2; i < arguments.length; i++) {\n      validateChildKeys(arguments[i], type);\n    }\n  }\n\n  if (type === REACT_FRAGMENT_TYPE) {\n    validateFragmentProps(element);\n  } else {\n    validatePropTypes(element);\n  }\n\n  return element;\n}\nfunction createFactoryWithValidation(type) {\n  var validatedFactory = createElementWithValidation.bind(null, type);\n  validatedFactory.type = type; // Legacy hook: remove it\n\n  {\n    Object.defineProperty(validatedFactory, 'type', {\n      enumerable: false,\n      get: function () {\n        lowPriorityWarningWithoutStack$1(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');\n        Object.defineProperty(this, 'type', {\n          value: type\n        });\n        return type;\n      }\n    });\n  }\n\n  return validatedFactory;\n}\nfunction cloneElementWithValidation(element, props, children) {\n  var newElement = cloneElement.apply(this, arguments);\n\n  for (var i = 2; i < arguments.length; i++) {\n    validateChildKeys(arguments[i], newElement.type);\n  }\n\n  validatePropTypes(newElement);\n  return newElement;\n}\n\nvar hasBadMapPolyfill;\n\n{\n  hasBadMapPolyfill = false;\n\n  try {\n    var frozenObject = Object.freeze({});\n    var testMap = new Map([[frozenObject, null]]);\n    var testSet = new Set([frozenObject]); // This is necessary for Rollup to not consider these unused.\n    // https://github.com/rollup/rollup/issues/1771\n    // TODO: we can remove these if Rollup fixes the bug.\n\n    testMap.set(0, 0);\n    testSet.add(0);\n  } catch (e) {\n    // TODO: Consider warning about bad polyfills\n    hasBadMapPolyfill = true;\n  }\n}\n\nfunction createFundamentalComponent(impl) {\n  // We use responder as a Map key later on. When we have a bad\n  // polyfill, then we can't use it as a key as the polyfill tries\n  // to add a property to the object.\n  if ( true && !hasBadMapPolyfill) {\n    Object.freeze(impl);\n  }\n\n  var fundamantalComponent = {\n    $$typeof: REACT_FUNDAMENTAL_TYPE,\n    impl: impl\n  };\n\n  {\n    Object.freeze(fundamantalComponent);\n  }\n\n  return fundamantalComponent;\n}\n\nfunction createEventResponder(displayName, responderConfig) {\n  var getInitialState = responderConfig.getInitialState,\n      onEvent = responderConfig.onEvent,\n      onMount = responderConfig.onMount,\n      onUnmount = responderConfig.onUnmount,\n      onRootEvent = responderConfig.onRootEvent,\n      rootEventTypes = responderConfig.rootEventTypes,\n      targetEventTypes = responderConfig.targetEventTypes,\n      targetPortalPropagation = responderConfig.targetPortalPropagation;\n  var eventResponder = {\n    $$typeof: REACT_RESPONDER_TYPE,\n    displayName: displayName,\n    getInitialState: getInitialState || null,\n    onEvent: onEvent || null,\n    onMount: onMount || null,\n    onRootEvent: onRootEvent || null,\n    onUnmount: onUnmount || null,\n    rootEventTypes: rootEventTypes || null,\n    targetEventTypes: targetEventTypes || null,\n    targetPortalPropagation: targetPortalPropagation || false\n  }; // We use responder as a Map key later on. When we have a bad\n  // polyfill, then we can't use it as a key as the polyfill tries\n  // to add a property to the object.\n\n  if ( true && !hasBadMapPolyfill) {\n    Object.freeze(eventResponder);\n  }\n\n  return eventResponder;\n}\n\nfunction createScope() {\n  var scopeComponent = {\n    $$typeof: REACT_SCOPE_TYPE\n  };\n\n  {\n    Object.freeze(scopeComponent);\n  }\n\n  return scopeComponent;\n}\n\n// Helps identify side effects in render-phase lifecycle hooks and setState\n// reducers by double invoking them in Strict Mode.\n\n // To preserve the \"Pause on caught exceptions\" behavior of the debugger, we\n// replay the begin phase of a failed component inside invokeGuardedCallback.\n\n // Warn about deprecated, async-unsafe lifecycles; relates to RFC #6:\n\n // Gather advanced timing metrics for Profiler subtrees.\n\n // Trace which interactions trigger each commit.\n\n // SSR experiments\n\n\n // Only used in www builds.\n\n // Only used in www builds.\n\n // Disable javascript: URL strings in href for XSS protection.\n\n // React Fire: prevent the value and checked attributes from syncing\n// with their related DOM properties\n\n // These APIs will no longer be \"unstable\" in the upcoming 16.7 release,\n// Control this behavior with a flag to support 16.6 minor releases in the meanwhile.\n\nvar exposeConcurrentModeAPIs = false;\n // Experimental React Flare event system and event components support.\n\nvar enableFlareAPI = false; // Experimental Host Component support.\n\nvar enableFundamentalAPI = false; // Experimental Scope support.\n\nvar enableScopeAPI = false; // New API for JSX transforms to target - https://github.com/reactjs/rfcs/pull/107\n\nvar enableJSXTransformAPI = false; // We will enforce mocking scheduler with scheduler/unstable_mock at some point. (v17?)\n// Till then, we warn about the missing mock, but still fallback to a legacy mode compatible version\n\n // For tests, we flush suspense fallbacks in an act scope;\n// *except* in some of our own tests, where we test incremental loading states.\n\n // Add a callback property to suspense to notify which promises are currently\n// in the update queue. This allows reporting and tracing of what is causing\n// the user to see a loading state.\n// Also allows hydration callbacks to fire when a dehydrated boundary gets\n// hydrated or deleted.\n\n // Part of the simplification of React.createElement so we can eventually move\n// from React.createElement to React.jsx\n// https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md\n\n\n\n\n\n // Flag to turn event.target and event.currentTarget in ReactNative from a reactTag to a component instance\n\nvar React = {\n  Children: {\n    map: mapChildren,\n    forEach: forEachChildren,\n    count: countChildren,\n    toArray: toArray,\n    only: onlyChild\n  },\n  createRef: createRef,\n  Component: Component,\n  PureComponent: PureComponent,\n  createContext: createContext,\n  forwardRef: forwardRef,\n  lazy: lazy,\n  memo: memo,\n  useCallback: useCallback,\n  useContext: useContext,\n  useEffect: useEffect,\n  useImperativeHandle: useImperativeHandle,\n  useDebugValue: useDebugValue,\n  useLayoutEffect: useLayoutEffect,\n  useMemo: useMemo,\n  useReducer: useReducer,\n  useRef: useRef,\n  useState: useState,\n  Fragment: REACT_FRAGMENT_TYPE,\n  Profiler: REACT_PROFILER_TYPE,\n  StrictMode: REACT_STRICT_MODE_TYPE,\n  Suspense: REACT_SUSPENSE_TYPE,\n  createElement: createElementWithValidation,\n  cloneElement: cloneElementWithValidation,\n  createFactory: createFactoryWithValidation,\n  isValidElement: isValidElement,\n  version: ReactVersion,\n  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: ReactSharedInternals\n};\n\nif (exposeConcurrentModeAPIs) {\n  React.useTransition = useTransition;\n  React.useDeferredValue = useDeferredValue;\n  React.SuspenseList = REACT_SUSPENSE_LIST_TYPE;\n  React.unstable_withSuspenseConfig = withSuspenseConfig;\n}\n\nif (enableFlareAPI) {\n  React.unstable_useResponder = useResponder;\n  React.unstable_createResponder = createEventResponder;\n}\n\nif (enableFundamentalAPI) {\n  React.unstable_createFundamental = createFundamentalComponent;\n}\n\nif (enableScopeAPI) {\n  React.unstable_createScope = createScope;\n} // Note: some APIs are added with feature flags.\n// Make sure that stable builds for open source\n// don't modify the React object to avoid deopts.\n// Also let's not expose their names in stable builds.\n\n\nif (enableJSXTransformAPI) {\n  {\n    React.jsxDEV = jsxWithValidation;\n    React.jsx = jsxWithValidationDynamic;\n    React.jsxs = jsxWithValidationStatic;\n  }\n}\n\n\n\nvar React$2 = Object.freeze({\n\tdefault: React\n});\n\nvar React$3 = ( React$2 && React ) || React$2;\n\n// TODO: decide on the top-level export form.\n// This is hacky but makes it work with both Rollup and Jest.\n\n\nvar react = React$3.default || React$3;\n\nmodule.exports = react;\n  })();\n}\n\n\n//# sourceURL=webpack:///./node_modules/react/cjs/react.development.js?");

/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ \"./node_modules/react/cjs/react.development.js\");\n}\n\n\n//# sourceURL=webpack:///./node_modules/react/index.js?");

/***/ }),

/***/ "./node_modules/style-mod/src/style-mod.js":
/*!*************************************************!*\
  !*** ./node_modules/style-mod/src/style-mod.js ***!
  \*************************************************/
/*! exports provided: StyleModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StyleModule\", function() { return StyleModule; });\nfunction sym(name, random) {\n  return typeof Symbol == \"undefined\"\n    ? \"__\" + name + (random ? Math.floor(Math.random() * 1e8) : \"\")\n    : random ? Symbol(name) : Symbol.for(name)\n}\n\nconst COUNT = sym(\"\\u037c\"), SET = sym(\"styleSet\", 1), RULES = sym(\"rules\", 1)\nconst top = typeof global == \"undefined\" ? window : global\n\n// :: (Object<Style>, ?{generateClasses: ?boolean}) â†’ StyleModule\n// Instances of this class bind the property names from `spec` to CSS\n// class names that assign the styles in the corresponding property\n// values, unless `generateClasses` is `false`, in which case the\n// property names in the spec are treated as plain CSS selectors.\n//\n// A style module can only be used in a given DOM root after it has\n// been _mounted_ there with `StyleModule.mount`.\n//\n// Style modules should be created once and stored somewhere, as\n// opposed to re-creating them every time you need them. The amount of\n// CSS rules generated for a given DOM root is bounded by the amount\n// of style modules that were used. So to avoid leaking rules, don't\n// create these dynamically, but treat them as one-time allocations.\nfunction StyleModule(spec, options) {\n  this[RULES] = []\n  for (let name in spec) {\n    let style = spec[name], specificity = style.specificity || 0\n    let id = StyleModule.newName(), selector = name\n    if ((options && options.generateClasses) !== false) {\n      let className = id\n      selector = \".\" + id\n      for (let i = 0; i < specificity; i++) {\n        let name = \"\\u037c_\" + (i ? i.toString(36) : \"\")\n        selector += \".\" + name\n        className += \" \" + name\n      }\n      this[name] = className\n    }\n    renderStyle(selector, spec[name], this[RULES])\n  }\n}\n\n// :: () â†’ string\n// Generate a new unique CSS class name.\nStyleModule.newName = () => {\n  let id = top[COUNT] || 1\n  top[COUNT] = id + 1\n  return \"\\u037c\" + id.toString(36)\n}\n\nStyleModule.prototype = Object.create(null)\n\n// :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>)\n//\n// Mount the given set of modules in the given DOM root, which ensures\n// that the CSS rules defined by the module are available in that\n// context.\n//\n// Rules are only added to the document once per root.\n//\n// Rule order will follow the order of the modules, so that rules from\n// modules later in the array take precedence of those from earlier\n// modules. If you call this function multiple times for the same root\n// in a way that changes the order of already mounted modules, the old\n// order will be changed.\nStyleModule.mount = function(root, modules) {\n  (root[SET] || new StyleSet(root)).mount(Array.isArray(modules) ? modules : [modules])\n}\n\nclass StyleSet {\n  constructor(root) {\n    this.root = root\n    root[SET] = this\n    this.styleTag = (root.ownerDocument || root).createElement(\"style\")\n    let target = root.head || root\n    target.insertBefore(this.styleTag, target.firstChild)\n    this.modules = []\n  }\n\n  mount(modules) {\n    let sheet = this.styleTag.sheet, reset = !sheet\n    let pos = 0 /* Current rule offset */, j = 0 /* Index into this.modules */\n    for (let i = 0; i < modules.length; i++) {\n      let mod = modules[i], index = this.modules.indexOf(mod)\n      if (index < j && index > -1) { // Ordering conflict\n        this.modules.splice(index, 1)\n        j--\n        index = -1\n      }\n      if (index == -1) {\n        this.modules.splice(j++, 0, mod)\n        if (!reset) for (let k = 0; k < mod[RULES].length; k++)\n          sheet.insertRule(mod[RULES][k], pos++)\n      } else {\n        while (j < index) pos += this.modules[j++][RULES].length\n        pos += mod[RULES].length\n        j++\n      }\n    }\n\n    if (reset) {\n      let text = \"\"\n      for (let i = 0; i < this.modules.length; i++)\n        text += this.modules[i][RULES].join(\"\\n\") + \"\\n\"\n      this.styleTag.textContent = text\n    }\n  }\n}\n\nfunction renderStyle(selector, spec, output) {\n  if (typeof spec != \"object\") throw new RangeError(\"Expected style object, got \" + JSON.stringify(spec))\n  let props = []\n  for (let prop in spec) {\n    if (/^@/.test(prop)) {\n      let local = []\n      renderStyle(selector, spec[prop], local)\n      output.push(prop + \" {\" + local.join(\" \") + \"}\")\n    } else if (/&/.test(prop)) {\n      renderStyle(prop.replace(/&/g, selector), spec[prop], output)\n    } else if (prop != \"specificity\") {\n      if (typeof spec[prop] == \"object\") throw new RangeError(\"The value of a property (\" + prop + \") should be a primitive value.\")\n      props.push(prop.replace(/_.*/, \"\").replace(/[A-Z]/g, l => \"-\" + l.toLowerCase()) + \": \" + spec[prop])\n    }\n  }\n  if (props.length) output.push(selector + \" {\" + props.join(\"; \") + \"}\")\n}\n\n// Style::Object<union<Style,string>>\n//\n// A style is an object that, in the simple case, maps CSS property\n// names to strings holding their values, as in `{color: \"red\",\n// fontWeight: \"bold\"}`. The property names can be given in\n// camel-caseâ€”the library will insert a dash before capital letters\n// when converting them to CSS.\n//\n// If you include an underscore in a property name, it and everything\n// after it will be removed from the output, which can be useful when\n// providing a property multiple times, for browser compatibility\n// reasons.\n//\n// A property called `specificity` has a special meaning: if it holds\n// a number _N_, greater than 0, the selector for the class will have\n// _N_ extra dummy classes added, and those dummy classes will also be\n// present in the class name string created for the style. This allows\n// you to create rules that take precedence over other rules, even\n// when they are defined earlier.\n//\n// A property in a style object can also be a sub-selector, which\n// extends the current context to add a pseudo-selector or a child\n// selector. Such a property should contain a `&` character, which\n// will be replaced by the current selector. For example `{\"&:before\":\n// {content: '\"hi\"'}}`. Sub-selectors and regular properties can\n// freely be mixed in a given object. Any property containing a `&` is\n// assumed to be a sub-selector.\n//\n// Finally, a property can specify an @-block to be wrapped around the\n// styles defined inside the object that's the property's value. For\n// example to create a media query you can do `{\"@media screen and\n// (min-width: 400px)\": {...}}`.\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/style-mod/src/style-mod.js?");

/***/ }),

/***/ "./node_modules/w3c-keyname/index.es.js":
/*!**********************************************!*\
  !*** ./node_modules/w3c-keyname/index.es.js ***!
  \**********************************************/
/*! exports provided: default, base, keyName, shift */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"base\", function() { return base_1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"keyName\", function() { return keyName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shift\", function() { return shift_1; });\nvar base = {\n  8: \"Backspace\",\n  9: \"Tab\",\n  10: \"Enter\",\n  12: \"NumLock\",\n  13: \"Enter\",\n  16: \"Shift\",\n  17: \"Control\",\n  18: \"Alt\",\n  20: \"CapsLock\",\n  27: \"Escape\",\n  32: \" \",\n  33: \"PageUp\",\n  34: \"PageDown\",\n  35: \"End\",\n  36: \"Home\",\n  37: \"ArrowLeft\",\n  38: \"ArrowUp\",\n  39: \"ArrowRight\",\n  40: \"ArrowDown\",\n  44: \"PrintScreen\",\n  45: \"Insert\",\n  46: \"Delete\",\n  59: \";\",\n  61: \"=\",\n  91: \"Meta\",\n  92: \"Meta\",\n  106: \"*\",\n  107: \"+\",\n  108: \",\",\n  109: \"-\",\n  110: \".\",\n  111: \"/\",\n  144: \"NumLock\",\n  145: \"ScrollLock\",\n  160: \"Shift\",\n  161: \"Shift\",\n  162: \"Control\",\n  163: \"Control\",\n  164: \"Alt\",\n  165: \"Alt\",\n  173: \"-\",\n  186: \";\",\n  187: \"=\",\n  188: \",\",\n  189: \"-\",\n  190: \".\",\n  191: \"/\",\n  192: \"`\",\n  219: \"[\",\n  220: \"\\\\\",\n  221: \"]\",\n  222: \"'\",\n  229: \"q\"\n};\nvar base_1 = base;\n\nvar shift = {\n  48: \")\",\n  49: \"!\",\n  50: \"@\",\n  51: \"#\",\n  52: \"$\",\n  53: \"%\",\n  54: \"^\",\n  55: \"&\",\n  56: \"*\",\n  57: \"(\",\n  59: \";\",\n  61: \"+\",\n  173: \"_\",\n  186: \":\",\n  187: \"+\",\n  188: \"<\",\n  189: \"_\",\n  190: \">\",\n  191: \"?\",\n  192: \"~\",\n  219: \"{\",\n  220: \"|\",\n  221: \"}\",\n  222: \"\\\"\",\n  229: \"Q\"\n};\nvar shift_1 = shift;\n\nvar chrome = typeof navigator != \"undefined\" && /Chrome\\/(\\d+)/.exec(navigator.userAgent);\nvar safari = typeof navigator != \"undefined\" && /Apple Computer/.test(navigator.vendor);\nvar gecko = typeof navigator != \"undefined\" && /Gecko\\/\\d+/.test(navigator.userAgent);\nvar mac = typeof navigator != \"undefined\" && /Mac/.test(navigator.platform);\nvar ie = typeof navigator != \"undefined\" && /MSIE \\d|Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent);\nvar brokenModifierNames = chrome && (mac || +chrome[1] < 57) || gecko && mac;\n\n// Fill in the digit keys\nfor (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);\n\n// The function keys\nfor (var i = 1; i <= 24; i++) base[i + 111] = \"F\" + i;\n\n// And the alphabetic keys\nfor (var i = 65; i <= 90; i++) {\n  base[i] = String.fromCharCode(i + 32);\n  shift[i] = String.fromCharCode(i);\n}\n\n// For each code that doesn't have a shift-equivalent, copy the base name\nfor (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];\n\nvar keyName = function(event) {\n  // Don't trust event.key in Chrome when there are modifiers until\n  // they fix https://bugs.chromium.org/p/chromium/issues/detail?id=633838\n  var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) ||\n    (safari || ie) && event.shiftKey && event.key && event.key.length == 1;\n  var name = (!ignoreKey && event.key) ||\n    (event.shiftKey ? shift : base)[event.keyCode] ||\n    event.key || \"Unidentified\";\n  // Edge sometimes produces wrong names (Issue #3)\n  if (name == \"Esc\") name = \"Escape\";\n  if (name == \"Del\") name = \"Delete\";\n  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/\n  if (name == \"Left\") name = \"ArrowLeft\";\n  if (name == \"Up\") name = \"ArrowUp\";\n  if (name == \"Right\") name = \"ArrowRight\";\n  if (name == \"Down\") name = \"ArrowDown\";\n  return name\n};\n\nvar w3cKeyname = {\n\tbase: base_1,\n\tshift: shift_1,\n\tkeyName: keyName\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (w3cKeyname);\n\n\n\n//# sourceURL=webpack:///./node_modules/w3c-keyname/index.es.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/codemirror.tsx":
/*!****************************!*\
  !*** ./src/codemirror.tsx ***!
  \****************************/
/*! exports provided: CodeEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CodeEditor\", function() { return CodeEditor; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _codemirror_next_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/next/view */ \"./node_modules/@codemirror/next/view/dist/index.es.js\");\n/* harmony import */ var _codemirror_next_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/next/state */ \"./node_modules/@codemirror/next/state/dist/index.es.js\");\n/* harmony import */ var _codemirror_next_keymap__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/next/keymap */ \"./node_modules/@codemirror/next/keymap/dist/index.es.js\");\n/* harmony import */ var _codemirror_next_history__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/next/history */ \"./node_modules/@codemirror/next/history/dist/index.es.js\");\n/* harmony import */ var _codemirror_next_commands__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @codemirror/next/commands */ \"./node_modules/@codemirror/next/commands/dist/index.es.js\");\n/* harmony import */ var _codemirror_next_matchbrackets__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @codemirror/next/matchbrackets */ \"./node_modules/@codemirror/next/matchbrackets/dist/index.es.js\");\n/* harmony import */ var _codemirror_next_closebrackets__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @codemirror/next/closebrackets */ \"./node_modules/@codemirror/next/closebrackets/dist/index.es.js\");\n\n\n\n\n\n\n\n\nconst isMac = /Mac/.test(navigator.platform);\nclass CodeEditor extends react__WEBPACK_IMPORTED_MODULE_0__[\"Component\"] {\n    constructor(props) {\n        super(props);\n        const { value, onChange, onSave } = props;\n        this.editor = new _codemirror_next_view__WEBPACK_IMPORTED_MODULE_1__[\"EditorView\"]({\n            state: _codemirror_next_state__WEBPACK_IMPORTED_MODULE_2__[\"EditorState\"].create({\n                doc: value,\n                extensions: [\n                    Object(_codemirror_next_history__WEBPACK_IMPORTED_MODULE_4__[\"history\"])(),\n                    _codemirror_next_closebrackets__WEBPACK_IMPORTED_MODULE_7__[\"closeBrackets\"],\n                    Object(_codemirror_next_matchbrackets__WEBPACK_IMPORTED_MODULE_6__[\"bracketMatching\"])(),\n                    changeListener(onChange),\n                    Object(_codemirror_next_keymap__WEBPACK_IMPORTED_MODULE_3__[\"keymap\"])({\n                        'Mod-s': () => {\n                            onSave();\n                            return true;\n                        },\n                        'Mod-z': _codemirror_next_history__WEBPACK_IMPORTED_MODULE_4__[\"undo\"],\n                        'Mod-Shift-z': _codemirror_next_history__WEBPACK_IMPORTED_MODULE_4__[\"redo\"],\n                        'Ctrl-y': isMac ? undefined : _codemirror_next_history__WEBPACK_IMPORTED_MODULE_4__[\"redo\"],\n                        'Shift-Tab': _codemirror_next_commands__WEBPACK_IMPORTED_MODULE_5__[\"indentSelection\"],\n                    }),\n                    Object(_codemirror_next_keymap__WEBPACK_IMPORTED_MODULE_3__[\"keymap\"])(_codemirror_next_commands__WEBPACK_IMPORTED_MODULE_5__[\"baseKeymap\"])\n                ]\n            })\n        });\n        this.containerRef = react__WEBPACK_IMPORTED_MODULE_0__[\"createRef\"]();\n    }\n    componentDidMount() {\n        if (this.containerRef.current) {\n            this.containerRef.current.appendChild(this.editor.dom);\n        }\n    }\n    componentWillUnmount() {\n        this.editor.destroy();\n    }\n    render() {\n        return (react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"](\"div\", { ref: this.containerRef }));\n    }\n    disconnectedCallback() {\n        this.editor.destroy();\n    }\n}\n// @ts-ignore\nwindow.codemirror = {\n    CodeEditor\n};\nfunction changeListener(callback) {\n    return [\n        _codemirror_next_view__WEBPACK_IMPORTED_MODULE_1__[\"ViewPlugin\"].decoration({\n            create() {\n                return _codemirror_next_view__WEBPACK_IMPORTED_MODULE_1__[\"Decoration\"].none;\n            },\n            update(deco, update) {\n                if (update.docChanged) {\n                    callback(update.state.doc.toString());\n                }\n                return _codemirror_next_view__WEBPACK_IMPORTED_MODULE_1__[\"Decoration\"].none;\n            }\n        })\n    ];\n}\n\n\n//# sourceURL=webpack:///./src/codemirror.tsx?");

/***/ })

/******/ });